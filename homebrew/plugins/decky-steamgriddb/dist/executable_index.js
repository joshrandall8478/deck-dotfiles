// Decky Loader will pass this api in, it's versioned to allow for backwards compatibility.
// @ts-ignore

// Prevents it from being duplicated in output.
const manifest = {"api_version":1,"name":"SteamGridDB","author":"SteamGridDB","flags":["debug"],"publish":{"tags":["artwork","sgdb"],"description":"Customize your library with user-submitted images or local files, and other tweaks like square capsules, changing the recently played size, and more!","image":"https://raw.githubusercontent.com/SteamGridDB/decky-steamgriddb/main/thumb.png"}};
const API_VERSION = 2;
const internalAPIConnection = window.__DECKY_SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED_deckyLoaderAPIInit;
// Initialize
if (!internalAPIConnection) {
    throw new Error('[@decky/api]: Failed to connect to the loader as as the loader API was not initialized. This is likely a bug in Decky Loader.');
}
// Version 1 throws on version mismatch so we have to account for that here.
let api;
try {
    api = internalAPIConnection.connect(API_VERSION, manifest.name);
}
catch {
    api = internalAPIConnection.connect(1, manifest.name);
    console.warn(`[@decky/api] Requested API version ${API_VERSION} but the running loader only supports version 1. Some features may not work.`);
}
if (api._version != API_VERSION) {
    console.warn(`[@decky/api] Requested API version ${API_VERSION} but the running loader only supports version ${api._version}. Some features may not work.`);
}
// TODO these could use a lot of JSDoc
const call = api.call;
const routerHook = api.routerHook;
const toaster = api.toaster;
const openFilePicker$1 = api.openFilePicker;
const fetchNoCors = api.fetchNoCors;

var DefaultContext = {
  color: undefined,
  size: undefined,
  className: undefined,
  style: undefined,
  attr: undefined
};
var IconContext = SP_REACT.createContext && /*#__PURE__*/SP_REACT.createContext(DefaultContext);

var _excluded = ["attr", "size", "title"];
function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }
function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } } return target; }
function _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function Tree2Element(tree) {
  return tree && tree.map((node, i) => /*#__PURE__*/SP_REACT.createElement(node.tag, _objectSpread({
    key: i
  }, node.attr), Tree2Element(node.child)));
}
function GenIcon(data) {
  return props => /*#__PURE__*/SP_REACT.createElement(IconBase, _extends({
    attr: _objectSpread({}, data.attr)
  }, props), Tree2Element(data.child));
}
function IconBase(props) {
  var elem = conf => {
    var {
        attr,
        size,
        title
      } = props,
      svgProps = _objectWithoutProperties(props, _excluded);
    var computedSize = size || conf.size || "1em";
    var className;
    if (conf.className) className = conf.className;
    if (props.className) className = (className ? className + " " : "") + props.className;
    return /*#__PURE__*/SP_REACT.createElement("svg", _extends({
      stroke: "currentColor",
      fill: "currentColor",
      strokeWidth: "0"
    }, conf.attr, attr, svgProps, {
      className: className,
      style: _objectSpread(_objectSpread({
        color: props.color || conf.color
      }, conf.style), props.style),
      height: computedSize,
      width: computedSize,
      xmlns: "http://www.w3.org/2000/svg"
    }), title && /*#__PURE__*/SP_REACT.createElement("title", null, title), props.children);
  };
  return IconContext !== undefined ? /*#__PURE__*/SP_REACT.createElement(IconContext.Consumer, null, conf => elem(conf)) : elem(DefaultContext);
}

// THIS FILE IS AUTO GENERATED
function SiBattledotnet (props) {
  return GenIcon({"tag":"svg","attr":{"role":"img","viewBox":"0 0 24 24"},"child":[{"tag":"path","attr":{"d":"M18.94 8.296C15.9 6.892 11.534 6 7.426 6.332c.206-1.36.714-2.308 1.548-2.508 1.148-.275 2.4.48 3.594 1.854.782.102 1.71.28 2.355.429C12.747 2.013 9.828-.282 7.607.565c-1.688.644-2.553 2.97-2.448 6.094-2.2.468-3.915 1.3-5.013 2.495-.056.065-.181.227-.137.305.034.058.146-.008.194-.04 1.274-.89 2.904-1.373 5.027-1.676.303 3.333 1.713 7.56 4.055 10.952-1.28.502-2.356.536-2.946-.087-.812-.856-.784-2.318-.19-4.04a26.764 26.764 0 0 1-.807-2.254c-2.459 3.934-2.986 7.61-1.143 9.11 1.402 1.14 3.847.725 6.502-.926 1.505 1.672 3.083 2.74 4.667 3.094.084.015.287.043.332-.034.034-.06-.08-.124-.131-.149-1.408-.657-2.64-1.828-3.964-3.515 2.735-1.929 5.691-5.263 7.457-8.988 1.076.86 1.64 1.773 1.398 2.595-.336 1.131-1.615 1.84-3.403 2.185a27.697 27.697 0 0 1-1.548 1.826c4.634.16 8.08-1.22 8.458-3.565.286-1.786-1.295-3.696-4.053-5.17.696-2.139.832-4.04.346-5.588-.029-.08-.106-.27-.196-.27-.068 0-.067.13-.063.187.135 1.547-.263 3.2-1.062 5.19zm-8.533 9.869c-1.96-3.145-3.09-6.849-3.082-10.594 3.702-.124 7.474.748 10.714 2.627-1.743 3.269-4.385 6.1-7.633 7.966h.001z"},"child":[]}]})(props);
}function SiBluesky (props) {
  return GenIcon({"tag":"svg","attr":{"role":"img","viewBox":"0 0 24 24"},"child":[{"tag":"path","attr":{"d":"M12 10.8c-1.087-2.114-4.046-6.053-6.798-7.995C2.566.944 1.561 1.266.902 1.565.139 1.908 0 3.08 0 3.768c0 .69.378 5.65.624 6.479.815 2.736 3.713 3.66 6.383 3.364.136-.02.275-.039.415-.056-.138.022-.276.04-.415.056-3.912.58-7.387 2.005-2.83 7.078 5.013 5.19 6.87-1.113 7.823-4.308.953 3.195 2.05 9.271 7.733 4.308 4.267-4.308 1.172-6.498-2.74-7.078a8.741 8.741 0 0 1-.415-.056c.14.017.279.036.415.056 2.67.297 5.568-.628 6.383-3.364.246-.828.624-5.79.624-6.478 0-.69-.139-1.861-.902-2.206-.659-.298-1.664-.62-4.3 1.24C16.046 4.748 13.087 8.687 12 10.8Z"},"child":[]}]})(props);
}function SiCrowdin (props) {
  return GenIcon({"tag":"svg","attr":{"role":"img","viewBox":"0 0 24 24"},"child":[{"tag":"path","attr":{"d":"M16.119 17.793a2.619 2.619 0 0 1-1.667-.562c-.546-.436-1.004-1.09-1.018-1.858-.008-.388.414-.388.414-.388l1.018-.008c.332.008.43.47.445.586.128 1.04.717 1.495 1.168 1.702.273.123.204.513-.362.528zm-5.695-5.287L8.5 12.252c-.867-.214-.844-.982-.807-1.247a5.119 5.119 0 0 1 .814-2.125c.545-.804 1.303-1.508 2.29-2.073 1.856-1.074 4.45-1.673 7.31-1.673 2.09 0 4.256.27 4.29.27.197.025.328.213.333.437a.377.377 0 0 1-.355.393l-.92-.01c-2.902 0-4.968.394-6.506 1.248-1.527.837-2.57 2.117-3.287 4.012-.076.163-.335 1.12-1.24 1.022zm2.533 7.823c-1.44 0-2.797-.622-3.825-1.746-.87-.96-1.397-1.931-1.493-3.164-.06-.813.3-1.094.788-1.044l1.988.218c.45.092.75.34.825.854.397 2.736 2.122 3.814 3.15 4.046.18.042.292.157.283.365a.412.412 0 0 1-.322.398c-.458.074-.936.073-1.394.073zm-4.101 2.418a14.216 14.216 0 0 1-2.307-.214c-1.202-.214-2.208-.582-3.072-1.13C1.41 20.095.163 17.786.014 15.048c-.037-.65-.11-1.89 1.427-1.797.638.033 1.653.343 2.368.548.887.247 1.314.933 1.314 1.608 0 3.858 3.494 6.408 5.02 6.408.654 0 .414.701.127.779-.502.136-1.15.153-1.413.153zM3.525 11.419c-.605-.109-1.194-.358-1.768-.5C-.018 10.479.284 8.688.45 8.196c1.617-4.757 6.746-6.35 10.887-6.773 3.898-.4 7.978-.092 11.778.967.31.083 1.269.327.718.891-.35.358-1.7-.016-2.073-.041-2.23-.167-4.434-.192-6.656.15-2.349.357-4.768 1.099-6.71 2.665-.938.758-1.76 1.723-2.313 2.866-.144.3-.256.6-.354.9-.11.327-.47 1.91-2.215 1.6zm9.94.917c.332-1.488 1.81-3.848 6.385-3.686 1.05.033.57.749.052.731-2.586-.09-3.815 1.578-4.457 3.27-.219.546-.68.626-1.271.53-.415-.074-.866-.123-.71-.846Z"},"child":[]}]})(props);
}function SiDiscord (props) {
  return GenIcon({"tag":"svg","attr":{"role":"img","viewBox":"0 0 24 24"},"child":[{"tag":"path","attr":{"d":"M20.317 4.3698a19.7913 19.7913 0 00-4.8851-1.5152.0741.0741 0 00-.0785.0371c-.211.3753-.4447.8648-.6083 1.2495-1.8447-.2762-3.68-.2762-5.4868 0-.1636-.3933-.4058-.8742-.6177-1.2495a.077.077 0 00-.0785-.037 19.7363 19.7363 0 00-4.8852 1.515.0699.0699 0 00-.0321.0277C.5334 9.0458-.319 13.5799.0992 18.0578a.0824.0824 0 00.0312.0561c2.0528 1.5076 4.0413 2.4228 5.9929 3.0294a.0777.0777 0 00.0842-.0276c.4616-.6304.8731-1.2952 1.226-1.9942a.076.076 0 00-.0416-.1057c-.6528-.2476-1.2743-.5495-1.8722-.8923a.077.077 0 01-.0076-.1277c.1258-.0943.2517-.1923.3718-.2914a.0743.0743 0 01.0776-.0105c3.9278 1.7933 8.18 1.7933 12.0614 0a.0739.0739 0 01.0785.0095c.1202.099.246.1981.3728.2924a.077.077 0 01-.0066.1276 12.2986 12.2986 0 01-1.873.8914.0766.0766 0 00-.0407.1067c.3604.698.7719 1.3628 1.225 1.9932a.076.076 0 00.0842.0286c1.961-.6067 3.9495-1.5219 6.0023-3.0294a.077.077 0 00.0313-.0552c.5004-5.177-.8382-9.6739-3.5485-13.6604a.061.061 0 00-.0312-.0286zM8.02 15.3312c-1.1825 0-2.1569-1.0857-2.1569-2.419 0-1.3332.9555-2.4189 2.157-2.4189 1.2108 0 2.1757 1.0952 2.1568 2.419 0 1.3332-.9555 2.4189-2.1569 2.4189zm7.9748 0c-1.1825 0-2.1569-1.0857-2.1569-2.419 0-1.3332.9554-2.4189 2.1569-2.4189 1.2108 0 2.1757 1.0952 2.1568 2.419 0 1.3332-.946 2.4189-2.1568 2.4189Z"},"child":[]}]})(props);
}function SiEpicgames (props) {
  return GenIcon({"tag":"svg","attr":{"role":"img","viewBox":"0 0 24 24"},"child":[{"tag":"path","attr":{"d":"M3.537 0C2.165 0 1.66.506 1.66 1.879V18.44a4.262 4.262 0 00.02.433c.031.3.037.59.316.92.027.033.311.245.311.245.153.075.258.13.43.2l8.335 3.491c.433.199.614.276.928.27h.002c.314.006.495-.071.928-.27l8.335-3.492c.172-.07.277-.124.43-.2 0 0 .284-.211.311-.243.28-.33.285-.621.316-.92a4.261 4.261 0 00.02-.434V1.879c0-1.373-.506-1.88-1.878-1.88zm13.366 3.11h.68c1.138 0 1.688.553 1.688 1.696v1.88h-1.374v-1.8c0-.369-.17-.54-.523-.54h-.235c-.367 0-.537.17-.537.539v5.81c0 .369.17.54.537.54h.262c.353 0 .523-.171.523-.54V8.619h1.373v2.143c0 1.144-.562 1.71-1.7 1.71h-.694c-1.138 0-1.7-.566-1.7-1.71V4.82c0-1.144.562-1.709 1.7-1.709zm-12.186.08h3.114v1.274H6.117v2.603h1.648v1.275H6.117v2.774h1.74v1.275h-3.14zm3.816 0h2.198c1.138 0 1.7.564 1.7 1.708v2.445c0 1.144-.562 1.71-1.7 1.71h-.799v3.338h-1.4zm4.53 0h1.4v9.201h-1.4zm-3.13 1.235v3.392h.575c.354 0 .523-.171.523-.54V4.965c0-.368-.17-.54-.523-.54zm-3.74 10.147a1.708 1.708 0 01.591.108 1.745 1.745 0 01.49.299l-.452.546a1.247 1.247 0 00-.308-.195.91.91 0 00-.363-.068.658.658 0 00-.28.06.703.703 0 00-.224.163.783.783 0 00-.151.243.799.799 0 00-.056.299v.008a.852.852 0 00.056.31.7.7 0 00.157.245.736.736 0 00.238.16.774.774 0 00.303.058.79.79 0 00.445-.116v-.339h-.548v-.565H7.37v1.255a2.019 2.019 0 01-.524.307 1.789 1.789 0 01-.683.123 1.642 1.642 0 01-.602-.107 1.46 1.46 0 01-.478-.3 1.371 1.371 0 01-.318-.455 1.438 1.438 0 01-.115-.58v-.008a1.426 1.426 0 01.113-.57 1.449 1.449 0 01.312-.46 1.418 1.418 0 01.474-.309 1.58 1.58 0 01.598-.111 1.708 1.708 0 01.045 0zm11.963.008a2.006 2.006 0 01.612.094 1.61 1.61 0 01.507.277l-.386.546a1.562 1.562 0 00-.39-.205 1.178 1.178 0 00-.388-.07.347.347 0 00-.208.052.154.154 0 00-.07.127v.008a.158.158 0 00.022.084.198.198 0 00.076.066.831.831 0 00.147.06c.062.02.14.04.236.061a3.389 3.389 0 01.43.122 1.292 1.292 0 01.328.17.678.678 0 01.207.24.739.739 0 01.071.337v.008a.865.865 0 01-.081.382.82.82 0 01-.229.285 1.032 1.032 0 01-.353.18 1.606 1.606 0 01-.46.061 2.16 2.16 0 01-.71-.116 1.718 1.718 0 01-.593-.346l.43-.514c.277.223.578.335.9.335a.457.457 0 00.236-.05.157.157 0 00.082-.142v-.008a.15.15 0 00-.02-.077.204.204 0 00-.073-.066.753.753 0 00-.143-.062 2.45 2.45 0 00-.233-.062 5.036 5.036 0 01-.413-.113 1.26 1.26 0 01-.331-.16.72.72 0 01-.222-.243.73.73 0 01-.082-.36v-.008a.863.863 0 01.074-.359.794.794 0 01.214-.283 1.007 1.007 0 01.34-.185 1.423 1.423 0 01.448-.066 2.006 2.006 0 01.025 0zm-9.358.025h.742l1.183 2.81h-.825l-.203-.499H8.623l-.198.498h-.81zm2.197.02h.814l.663 1.08.663-1.08h.814v2.79h-.766v-1.602l-.711 1.091h-.016l-.707-1.083v1.593h-.754zm3.469 0h2.235v.658h-1.473v.422h1.334v.61h-1.334v.442h1.493v.658h-2.255zm-5.3.897l-.315.793h.624zm-1.145 5.19h8.014l-4.09 1.348z"},"child":[]}]})(props);
}function SiGithub (props) {
  return GenIcon({"tag":"svg","attr":{"role":"img","viewBox":"0 0 24 24"},"child":[{"tag":"path","attr":{"d":"M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"},"child":[]}]})(props);
}function SiKofi (props) {
  return GenIcon({"tag":"svg","attr":{"role":"img","viewBox":"0 0 24 24"},"child":[{"tag":"path","attr":{"d":"M23.881 8.948c-.773-4.085-4.859-4.593-4.859-4.593H.723c-.604 0-.679.798-.679.798s-.082 7.324-.022 11.822c.164 2.424 2.586 2.672 2.586 2.672s8.267-.023 11.966-.049c2.438-.426 2.683-2.566 2.658-3.734 4.352.24 7.422-2.831 6.649-6.916zm-11.062 3.511c-1.246 1.453-4.011 3.976-4.011 3.976s-.121.119-.31.023c-.076-.057-.108-.09-.108-.09-.443-.441-3.368-3.049-4.034-3.954-.709-.965-1.041-2.7-.091-3.71.951-1.01 3.005-1.086 4.363.407 0 0 1.565-1.782 3.468-.963 1.904.82 1.832 3.011.723 4.311zm6.173.478c-.928.116-1.682.028-1.682.028V7.284h1.77s1.971.551 1.971 2.638c0 1.913-.985 2.667-2.059 3.015z"},"child":[]}]})(props);
}function SiMastodon (props) {
  return GenIcon({"tag":"svg","attr":{"role":"img","viewBox":"0 0 24 24"},"child":[{"tag":"path","attr":{"d":"M23.268 5.313c-.35-2.578-2.617-4.61-5.304-5.004C17.51.242 15.792 0 11.813 0h-.03c-3.98 0-4.835.242-5.288.309C3.882.692 1.496 2.518.917 5.127.64 6.412.61 7.837.661 9.143c.074 1.874.088 3.745.26 5.611.118 1.24.325 2.47.62 3.68.55 2.237 2.777 4.098 4.96 4.857 2.336.792 4.849.923 7.256.38.265-.061.527-.132.786-.213.585-.184 1.27-.39 1.774-.753a.057.057 0 0 0 .023-.043v-1.809a.052.052 0 0 0-.02-.041.053.053 0 0 0-.046-.01 20.282 20.282 0 0 1-4.709.545c-2.73 0-3.463-1.284-3.674-1.818a5.593 5.593 0 0 1-.319-1.433.053.053 0 0 1 .066-.054c1.517.363 3.072.546 4.632.546.376 0 .75 0 1.125-.01 1.57-.044 3.224-.124 4.768-.422.038-.008.077-.015.11-.024 2.435-.464 4.753-1.92 4.989-5.604.008-.145.03-1.52.03-1.67.002-.512.167-3.63-.024-5.545zm-3.748 9.195h-2.561V8.29c0-1.309-.55-1.976-1.67-1.976-1.23 0-1.846.79-1.846 2.35v3.403h-2.546V8.663c0-1.56-.617-2.35-1.848-2.35-1.112 0-1.668.668-1.67 1.977v6.218H4.822V8.102c0-1.31.337-2.35 1.011-3.12.696-.77 1.608-1.164 2.74-1.164 1.311 0 2.302.5 2.962 1.498l.638 1.06.638-1.06c.66-.999 1.65-1.498 2.96-1.498 1.13 0 2.043.395 2.74 1.164.675.77 1.012 1.81 1.012 3.12z"},"child":[]}]})(props);
}function SiOrigin (props) {
  return GenIcon({"tag":"svg","attr":{"role":"img","viewBox":"0 0 24 24"},"child":[{"tag":"path","attr":{"d":"M12.588 3.11a8.78 8.78 0 013.417.919 8.775 8.775 0 012.706 2.094 9.113 9.113 0 011.715 2.963 8.65 8.65 0 01.465 3.502 8.224 8.224 0 01-.307 1.848 9.174 9.174 0 01-.674 1.703 19.96 19.96 0 01-1.47 2.412 17.61 17.61 0 01-1.762 2.118 18.61 18.61 0 01-4.286 3.281l-.037.026a.196.196 0 01-.109.023.293.293 0 01-.159-.097.266.266 0 01-.062-.173c0-.029.004-.059.012-.085a.186.186 0 01.037-.062c.277-.393.506-.806.686-1.235a5.42 5.42 0 00.368-1.359.118.118 0 00-.038-.085.11.11 0 00-.085-.038 9.155 9.155 0 01-.795.062 4.926 4.926 0 01-.796-.037 8.818 8.818 0 01-6.123-3.013 9.089 9.089 0 01-1.715-2.963 8.662 8.662 0 01-.465-3.502 8.224 8.224 0 01.306-1.848 8.598 8.598 0 01.675-1.68c.439-.864.93-1.676 1.469-2.436a18.035 18.035 0 011.76-2.119A18.801 18.801 0 0111.609.05l.038-.025a.187.187 0 01.11-.025.295.295 0 01.157.098.255.255 0 01.062.174.244.244 0 01-.012.084.164.164 0 01-.036.061 6.447 6.447 0 00-.687 1.237c-.18.433-.3.885-.366 1.358 0 .033.012.063.036.086a.117.117 0 00.085.037c.262-.033.527-.053.795-.06.272-.01.536.002.798.034zm-.807 12.367a3.32 3.32 0 002.521-.855c.72-.64 1.11-1.438 1.176-2.4a3.357 3.357 0 00-.856-2.535 3.294 3.294 0 00-2.4-1.162 3.36 3.36 0 00-2.534.855 3.3 3.3 0 00-1.164 2.4 3.381 3.381 0 00.846 2.535c.628.725 1.432 1.115 2.411 1.162z"},"child":[]}]})(props);
}function SiPatreon (props) {
  return GenIcon({"tag":"svg","attr":{"role":"img","viewBox":"0 0 24 24"},"child":[{"tag":"path","attr":{"d":"M22.957 7.21c-.004-3.064-2.391-5.576-5.191-6.482-3.478-1.125-8.064-.962-11.384.604C2.357 3.231 1.093 7.391 1.046 11.54c-.039 3.411.302 12.396 5.369 12.46 3.765.047 4.326-4.804 6.068-7.141 1.24-1.662 2.836-2.132 4.801-2.618 3.376-.836 5.678-3.501 5.673-7.031Z"},"child":[]}]})(props);
}function SiSteam (props) {
  return GenIcon({"tag":"svg","attr":{"role":"img","viewBox":"0 0 24 24"},"child":[{"tag":"path","attr":{"d":"M11.979 0C5.678 0 .511 4.86.022 11.037l6.432 2.658c.545-.371 1.203-.59 1.912-.59.063 0 .125.004.188.006l2.861-4.142V8.91c0-2.495 2.028-4.524 4.524-4.524 2.494 0 4.524 2.031 4.524 4.527s-2.03 4.525-4.524 4.525h-.105l-4.076 2.911c0 .052.004.105.004.159 0 1.875-1.515 3.396-3.39 3.396-1.635 0-3.016-1.173-3.331-2.727L.436 15.27C1.862 20.307 6.486 24 11.979 24c6.627 0 11.999-5.373 11.999-12S18.605 0 11.979 0zM7.54 18.21l-1.473-.61c.262.543.714.999 1.314 1.25 1.297.539 2.793-.076 3.332-1.375.263-.63.264-1.319.005-1.949s-.75-1.121-1.377-1.383c-.624-.26-1.29-.249-1.878-.03l1.523.63c.956.4 1.409 1.5 1.009 2.455-.397.957-1.497 1.41-2.454 1.012H7.54zm11.415-9.303c0-1.662-1.353-3.015-3.015-3.015-1.665 0-3.015 1.353-3.015 3.015 0 1.665 1.35 3.015 3.015 3.015 1.663 0 3.015-1.35 3.015-3.015zm-5.273-.005c0-1.252 1.013-2.266 2.265-2.266 1.249 0 2.266 1.014 2.266 2.266 0 1.251-1.017 2.265-2.266 2.265-1.253 0-2.265-1.014-2.265-2.265z"},"child":[]}]})(props);
}function SiUbisoft (props) {
  return GenIcon({"tag":"svg","attr":{"role":"img","viewBox":"0 0 24 24"},"child":[{"tag":"path","attr":{"d":"M23.561 11.988C23.301-.304 6.954-4.89.656 6.634c.282.206.661.477.943.672a11.747 11.747 0 00-.976 3.067 11.885 11.885 0 00-.184 2.071C.439 18.818 5.621 24 12.005 24c6.385 0 11.556-5.17 11.556-11.556v-.455zm-20.27 2.06c-.152 1.246-.054 1.636-.054 1.788l-.282.098c-.108-.206-.37-.932-.488-1.908C2.163 10.308 4.7 6.96 8.57 6.33c3.544-.52 6.937 1.68 7.728 4.758l-.282.098c-.087-.087-.228-.336-.77-.878-4.281-4.281-11.002-2.32-11.956 3.74zm11.002 2.081a3.145 3.145 0 01-2.59 1.355 3.15 3.15 0 01-3.155-3.155 3.159 3.159 0 012.927-3.144c1.018-.043 1.972.51 2.416 1.398a2.58 2.58 0 01-.455 2.95c.293.205.575.4.856.595zm6.58.12c-1.669 3.782-5.106 5.766-8.77 5.712-7.034-.347-9.083-8.466-4.38-11.393l.207.206c-.076.108-.358.325-.791 1.182-.51 1.041-.672 2.081-.607 2.732.369 5.67 8.314 6.83 11.045 1.214C21.057 8.217 11.822.401 3.626 6.374l-.184-.184C5.599 2.808 9.816 1.3 13.837 2.309c6.147 1.55 9.453 7.956 7.035 13.94z"},"child":[]}]})(props);
}

const BoopIcon = (props) => (window.SP_REACT.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", xmlSpace: "preserve", fillRule: "evenodd", strokeLinejoin: "round", strokeMiterlimit: "2", clipRule: "evenodd", viewBox: "0 0 350 350", width: "1em", height: "1em", ...props },
    window.SP_REACT.createElement("path", { d: "M350 169v6A175 175 0 1 1 179 0a163 163 0 1 0 171 169Z" }),
    window.SP_REACT.createElement("path", { d: "M198 0h133c11 0 19 8 19 19v133A152 152 0 1 1 198 0Z" })));

const TwitterIcon = (props) => (window.SP_REACT.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", xmlSpace: "preserve", viewBox: "0 0 248 204", width: "1em", height: "1em", ...props },
    window.SP_REACT.createElement("path", { fill: "#1d9bf0", d: "M221.95 51.29c.15 2.17.15 4.34.15 6.53 0 66.73-50.8 143.69-143.69 143.69v-.04c-27.44.04-54.31-7.82-77.41-22.64 3.99.48 8 .72 12.02.73 22.74.02 44.83-7.61 62.72-21.66-21.61-.41-40.56-14.5-47.18-35.07a50.34 50.34 0 0 0 22.8-.87C27.8 117.2 10.85 96.5 10.85 72.46v-.64a50.2 50.2 0 0 0 22.92 6.32C11.58 63.31 4.74 33.79 18.14 10.71a143.33 143.33 0 0 0 104.08 52.76 50.53 50.53 0 0 1 14.61-48.25c20.34-19.12 52.33-18.14 71.45 2.19 11.31-2.23 22.15-6.38 32.07-12.26a50.7 50.7 0 0 1-22.2 27.93c10.01-1.18 19.79-3.86 29-7.95a102.6 102.6 0 0 1-25.2 26.16" })));

var ASSET_TYPE_CAPSULE$n="Výběr";var ASSET_TYPE_WIDECAPSULE$n="Široký výběr";var ASSET_TYPE_HERO$n="Hrdina";var ASSET_TYPE_LOGO$n="Logo";var ASSET_TYPE_ICON$n="Ikona";var LABEL_TAB_CAPSULE$n="Výběr";var LABEL_TAB_WIDECAPSULE$n="Široký výběr";var LABEL_TAB_HERO$n="Hrdina";var LABEL_TAB_LOGO$n="Logo";var LABEL_TAB_ICON$n="Ikona";var LABEL_TAB_MANAGE$n="Spravovat";var MSG_USAGE_INSTRUCTIONS$m="Vyber hru {arrow} {optionsButton} {arrow} \"{ACTION_CHANGE_ARTWORK}\"";var ACTION_CHANGE_ARTWORK$n="Změnit artwork...";var ACTION_SHOW_LINK_QR$n="Ukázat QR odkaz";var MSG_ASSET_TAB_SETTINGS_DESC$l="Přeuspořádat nebo skrýt nepoužité karty a nastavit výchozí záložku, která se otevře při použití \"{ACTION_CHANGE_ARTWORK}\"";var LABEL_USAGE_TITLE$m="Ztracen? Zde je rychlá příručka";var LABEL_SQUARE_CAPSULES$k="Čtvercový výběr";var LABEL_SQUARE_CAPSULES_DESC$j="Použít čtvercové výběr místo výškový vývěr. Čtvercové filtry budou automaticky vybrány.";var LABEL_CAPSULE_GLOW$k="Výběrní záření";var LABEL_CAPSULE_GLOW_DESC$j="Upravte intenzitu výběrního záření v knihovně.";var LABEL_CAPSULE_GLOW_OFF$k="Žádná";var LABEL_SETTINGS_ASSET_TABS$l="Nastavení karty aktiv";var LABEL_TRANSLATION_CREDIT_TITLE$n="Český překlad";var LABEL_MORE_SGDB_TITLE$n="Další z SteamGridDB";var ACTION_SGDB_DISCORD$n="Připojit na Discord";var ACTION_SGDB_GITHUB$m="Projekty s otevřeným zdrojem";var ACTION_SGDB_DONATE$n="Podpořte nás na Patreonu";var ACTION_SGDB_TRANSLATE$n="Pomozte s překladem";var ACTION_SGDB_BOOP$n="Podívejte se na SGDBoop";var LABEL_RESTART_STEAM_TITLE$m="Restartovat Steam?";var ACTION_RESTART_STEAM_LATER$m="Později";var ACTION_RESTART_STEAM_NOW$m="Restartovat nyní";var MSG_RESTART_STEAM_DESC$l="Steam je třeba restartovat, aby se změny projevily.";var LABEL_GAME_SEARCH_TITLE$n="Hledat hru...";var LABEL_FILTER_MODAL_TITLE$n="{assetType} Filtr";var LABEL_FILTER_GAME$n="Hra";var LABEL_FILTER_DIMENSIONS$n="Rozměry";var LABEL_FILTER_STYLES$n="Styly";var LABEL_FILTER_FILE_TYPES$n="Typy souborů";var LABEL_FILTER_ANIMATION_TYPE_TITLE$n="Druhy";var LABEL_FILTER_TYPE_ANIMATED$m="Animovaný";var LABEL_FILTER_TYPE_STATIC$m="Statický";var LABEL_FILTER_TAGS_TITLE$n="Štítky";var LABEL_FILTER_TAG_NSFW$n="Obsah pro dospělé";var MSG_FILTER_TAG_NSFW_ENABLED$m="Možná raději mrknout přes rameno.";var LABEL_FILTER_TAG_HUMOR$m="Humor";var LABEL_FILTER_TAG_EPILEPSY$m="Epilepsie";var LABEL_FILTER_TAG_UNTAGGED$m="Neoznačeno";var ACTION_FILTER_RESET$n="Zrušit Filtry";var LABEL_BEGGING_MODAL_TITLE$k="Děkujeme, že používáte SteamGridDB!";var LABEL_BEGGING_MODAL_DESC$j="Zvažte prosím darování pro pomoc s údržbou a náklady na servery!";var ACTION_HIDE_POS_GUIDES$l="Skrýt návody";var ACTION_SHOW_OUTLINE$l="Zobrazit návody";var ACTION_ADJUST_POS_SIZE$m="Upravit Velikost";var LABEL_ASSET_CURRENT$m="Současný {assetType}";var ACTION_ASSET_CUSTOM_CLEAR$m="Vymazat vlastní šablonu";var ACTION_ASSET_BROWSE_LOCAL$l="Procházet místní soubory";var ACTION_ASSET_APPLY_TRANSPARENT$l="Použít neviditelnou šablonu";var LABEL_NOTES$n="Poznámky";var LABEL_ANIMATED$m="Animovaný";var LABEL_NSFW$n="Obsah pro dospělé";var LABEL_HUMOR$m="Humor";var LABEL_EPILEPSY$m="Epilepsie";var ACTION_OPEN_FILTER$n="Filtr";var ACTION_OPEN_OFFICIAL_ASSETS$m="Oficiální {assetType}";var ACTION_ASSET_APPLY$m="Použít {assetType}";var MSG_GAME_SELECTED$m="Vybrán {gameName}";var MSG_ASSETS_FILTERED$m="Některé položky mohou být skryty kvůli filtru";var MSG_GAME_SELECTED_AND_ASSETS_FILTERED$m="Vybrán {gameName} s filtrem";var MSG_ASSET_APPLY_SUCCESS$m="{assetType} byl úspěšně použit!";var MSG_ASSET_APPLY_ERROR$l="Při použití této šablony došlo k chybě.";var ACTION_OPEN_DETAILS$m="Podrobnosti";var cs = {ASSET_TYPE_CAPSULE:ASSET_TYPE_CAPSULE$n,ASSET_TYPE_WIDECAPSULE:ASSET_TYPE_WIDECAPSULE$n,ASSET_TYPE_HERO:ASSET_TYPE_HERO$n,ASSET_TYPE_LOGO:ASSET_TYPE_LOGO$n,ASSET_TYPE_ICON:ASSET_TYPE_ICON$n,LABEL_TAB_CAPSULE:LABEL_TAB_CAPSULE$n,LABEL_TAB_WIDECAPSULE:LABEL_TAB_WIDECAPSULE$n,LABEL_TAB_HERO:LABEL_TAB_HERO$n,LABEL_TAB_LOGO:LABEL_TAB_LOGO$n,LABEL_TAB_ICON:LABEL_TAB_ICON$n,LABEL_TAB_MANAGE:LABEL_TAB_MANAGE$n,MSG_USAGE_INSTRUCTIONS:MSG_USAGE_INSTRUCTIONS$m,ACTION_CHANGE_ARTWORK:ACTION_CHANGE_ARTWORK$n,ACTION_SHOW_LINK_QR:ACTION_SHOW_LINK_QR$n,MSG_ASSET_TAB_SETTINGS_DESC:MSG_ASSET_TAB_SETTINGS_DESC$l,LABEL_USAGE_TITLE:LABEL_USAGE_TITLE$m,LABEL_SQUARE_CAPSULES:LABEL_SQUARE_CAPSULES$k,LABEL_SQUARE_CAPSULES_DESC:LABEL_SQUARE_CAPSULES_DESC$j,LABEL_CAPSULE_GLOW:LABEL_CAPSULE_GLOW$k,LABEL_CAPSULE_GLOW_DESC:LABEL_CAPSULE_GLOW_DESC$j,LABEL_CAPSULE_GLOW_OFF:LABEL_CAPSULE_GLOW_OFF$k,LABEL_SETTINGS_ASSET_TABS:LABEL_SETTINGS_ASSET_TABS$l,LABEL_TRANSLATION_CREDIT_TITLE:LABEL_TRANSLATION_CREDIT_TITLE$n,LABEL_MORE_SGDB_TITLE:LABEL_MORE_SGDB_TITLE$n,ACTION_SGDB_DISCORD:ACTION_SGDB_DISCORD$n,ACTION_SGDB_GITHUB:ACTION_SGDB_GITHUB$m,ACTION_SGDB_DONATE:ACTION_SGDB_DONATE$n,ACTION_SGDB_TRANSLATE:ACTION_SGDB_TRANSLATE$n,ACTION_SGDB_BOOP:ACTION_SGDB_BOOP$n,LABEL_RESTART_STEAM_TITLE:LABEL_RESTART_STEAM_TITLE$m,ACTION_RESTART_STEAM_LATER:ACTION_RESTART_STEAM_LATER$m,ACTION_RESTART_STEAM_NOW:ACTION_RESTART_STEAM_NOW$m,MSG_RESTART_STEAM_DESC:MSG_RESTART_STEAM_DESC$l,LABEL_GAME_SEARCH_TITLE:LABEL_GAME_SEARCH_TITLE$n,LABEL_FILTER_MODAL_TITLE:LABEL_FILTER_MODAL_TITLE$n,LABEL_FILTER_GAME:LABEL_FILTER_GAME$n,LABEL_FILTER_DIMENSIONS:LABEL_FILTER_DIMENSIONS$n,LABEL_FILTER_STYLES:LABEL_FILTER_STYLES$n,LABEL_FILTER_FILE_TYPES:LABEL_FILTER_FILE_TYPES$n,LABEL_FILTER_ANIMATION_TYPE_TITLE:LABEL_FILTER_ANIMATION_TYPE_TITLE$n,LABEL_FILTER_TYPE_ANIMATED:LABEL_FILTER_TYPE_ANIMATED$m,LABEL_FILTER_TYPE_STATIC:LABEL_FILTER_TYPE_STATIC$m,LABEL_FILTER_TAGS_TITLE:LABEL_FILTER_TAGS_TITLE$n,LABEL_FILTER_TAG_NSFW:LABEL_FILTER_TAG_NSFW$n,MSG_FILTER_TAG_NSFW_ENABLED:MSG_FILTER_TAG_NSFW_ENABLED$m,LABEL_FILTER_TAG_HUMOR:LABEL_FILTER_TAG_HUMOR$m,LABEL_FILTER_TAG_EPILEPSY:LABEL_FILTER_TAG_EPILEPSY$m,LABEL_FILTER_TAG_UNTAGGED:LABEL_FILTER_TAG_UNTAGGED$m,ACTION_FILTER_RESET:ACTION_FILTER_RESET$n,LABEL_BEGGING_MODAL_TITLE:LABEL_BEGGING_MODAL_TITLE$k,LABEL_BEGGING_MODAL_DESC:LABEL_BEGGING_MODAL_DESC$j,ACTION_HIDE_POS_GUIDES:ACTION_HIDE_POS_GUIDES$l,ACTION_SHOW_OUTLINE:ACTION_SHOW_OUTLINE$l,ACTION_ADJUST_POS_SIZE:ACTION_ADJUST_POS_SIZE$m,LABEL_ASSET_CURRENT:LABEL_ASSET_CURRENT$m,ACTION_ASSET_CUSTOM_CLEAR:ACTION_ASSET_CUSTOM_CLEAR$m,ACTION_ASSET_BROWSE_LOCAL:ACTION_ASSET_BROWSE_LOCAL$l,ACTION_ASSET_APPLY_TRANSPARENT:ACTION_ASSET_APPLY_TRANSPARENT$l,LABEL_NOTES:LABEL_NOTES$n,LABEL_ANIMATED:LABEL_ANIMATED$m,LABEL_NSFW:LABEL_NSFW$n,LABEL_HUMOR:LABEL_HUMOR$m,LABEL_EPILEPSY:LABEL_EPILEPSY$m,ACTION_OPEN_FILTER:ACTION_OPEN_FILTER$n,ACTION_OPEN_OFFICIAL_ASSETS:ACTION_OPEN_OFFICIAL_ASSETS$m,ACTION_ASSET_APPLY:ACTION_ASSET_APPLY$m,MSG_GAME_SELECTED:MSG_GAME_SELECTED$m,MSG_ASSETS_FILTERED:MSG_ASSETS_FILTERED$m,MSG_GAME_SELECTED_AND_ASSETS_FILTERED:MSG_GAME_SELECTED_AND_ASSETS_FILTERED$m,MSG_ASSET_APPLY_SUCCESS:MSG_ASSET_APPLY_SUCCESS$m,MSG_ASSET_APPLY_ERROR:MSG_ASSET_APPLY_ERROR$l,ACTION_OPEN_DETAILS:ACTION_OPEN_DETAILS$m};

var cs$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    ACTION_ADJUST_POS_SIZE: ACTION_ADJUST_POS_SIZE$m,
    ACTION_ASSET_APPLY: ACTION_ASSET_APPLY$m,
    ACTION_ASSET_APPLY_TRANSPARENT: ACTION_ASSET_APPLY_TRANSPARENT$l,
    ACTION_ASSET_BROWSE_LOCAL: ACTION_ASSET_BROWSE_LOCAL$l,
    ACTION_ASSET_CUSTOM_CLEAR: ACTION_ASSET_CUSTOM_CLEAR$m,
    ACTION_CHANGE_ARTWORK: ACTION_CHANGE_ARTWORK$n,
    ACTION_FILTER_RESET: ACTION_FILTER_RESET$n,
    ACTION_HIDE_POS_GUIDES: ACTION_HIDE_POS_GUIDES$l,
    ACTION_OPEN_DETAILS: ACTION_OPEN_DETAILS$m,
    ACTION_OPEN_FILTER: ACTION_OPEN_FILTER$n,
    ACTION_OPEN_OFFICIAL_ASSETS: ACTION_OPEN_OFFICIAL_ASSETS$m,
    ACTION_RESTART_STEAM_LATER: ACTION_RESTART_STEAM_LATER$m,
    ACTION_RESTART_STEAM_NOW: ACTION_RESTART_STEAM_NOW$m,
    ACTION_SGDB_BOOP: ACTION_SGDB_BOOP$n,
    ACTION_SGDB_DISCORD: ACTION_SGDB_DISCORD$n,
    ACTION_SGDB_DONATE: ACTION_SGDB_DONATE$n,
    ACTION_SGDB_GITHUB: ACTION_SGDB_GITHUB$m,
    ACTION_SGDB_TRANSLATE: ACTION_SGDB_TRANSLATE$n,
    ACTION_SHOW_LINK_QR: ACTION_SHOW_LINK_QR$n,
    ACTION_SHOW_OUTLINE: ACTION_SHOW_OUTLINE$l,
    ASSET_TYPE_CAPSULE: ASSET_TYPE_CAPSULE$n,
    ASSET_TYPE_HERO: ASSET_TYPE_HERO$n,
    ASSET_TYPE_ICON: ASSET_TYPE_ICON$n,
    ASSET_TYPE_LOGO: ASSET_TYPE_LOGO$n,
    ASSET_TYPE_WIDECAPSULE: ASSET_TYPE_WIDECAPSULE$n,
    LABEL_ANIMATED: LABEL_ANIMATED$m,
    LABEL_ASSET_CURRENT: LABEL_ASSET_CURRENT$m,
    LABEL_BEGGING_MODAL_DESC: LABEL_BEGGING_MODAL_DESC$j,
    LABEL_BEGGING_MODAL_TITLE: LABEL_BEGGING_MODAL_TITLE$k,
    LABEL_CAPSULE_GLOW: LABEL_CAPSULE_GLOW$k,
    LABEL_CAPSULE_GLOW_DESC: LABEL_CAPSULE_GLOW_DESC$j,
    LABEL_CAPSULE_GLOW_OFF: LABEL_CAPSULE_GLOW_OFF$k,
    LABEL_EPILEPSY: LABEL_EPILEPSY$m,
    LABEL_FILTER_ANIMATION_TYPE_TITLE: LABEL_FILTER_ANIMATION_TYPE_TITLE$n,
    LABEL_FILTER_DIMENSIONS: LABEL_FILTER_DIMENSIONS$n,
    LABEL_FILTER_FILE_TYPES: LABEL_FILTER_FILE_TYPES$n,
    LABEL_FILTER_GAME: LABEL_FILTER_GAME$n,
    LABEL_FILTER_MODAL_TITLE: LABEL_FILTER_MODAL_TITLE$n,
    LABEL_FILTER_STYLES: LABEL_FILTER_STYLES$n,
    LABEL_FILTER_TAGS_TITLE: LABEL_FILTER_TAGS_TITLE$n,
    LABEL_FILTER_TAG_EPILEPSY: LABEL_FILTER_TAG_EPILEPSY$m,
    LABEL_FILTER_TAG_HUMOR: LABEL_FILTER_TAG_HUMOR$m,
    LABEL_FILTER_TAG_NSFW: LABEL_FILTER_TAG_NSFW$n,
    LABEL_FILTER_TAG_UNTAGGED: LABEL_FILTER_TAG_UNTAGGED$m,
    LABEL_FILTER_TYPE_ANIMATED: LABEL_FILTER_TYPE_ANIMATED$m,
    LABEL_FILTER_TYPE_STATIC: LABEL_FILTER_TYPE_STATIC$m,
    LABEL_GAME_SEARCH_TITLE: LABEL_GAME_SEARCH_TITLE$n,
    LABEL_HUMOR: LABEL_HUMOR$m,
    LABEL_MORE_SGDB_TITLE: LABEL_MORE_SGDB_TITLE$n,
    LABEL_NOTES: LABEL_NOTES$n,
    LABEL_NSFW: LABEL_NSFW$n,
    LABEL_RESTART_STEAM_TITLE: LABEL_RESTART_STEAM_TITLE$m,
    LABEL_SETTINGS_ASSET_TABS: LABEL_SETTINGS_ASSET_TABS$l,
    LABEL_SQUARE_CAPSULES: LABEL_SQUARE_CAPSULES$k,
    LABEL_SQUARE_CAPSULES_DESC: LABEL_SQUARE_CAPSULES_DESC$j,
    LABEL_TAB_CAPSULE: LABEL_TAB_CAPSULE$n,
    LABEL_TAB_HERO: LABEL_TAB_HERO$n,
    LABEL_TAB_ICON: LABEL_TAB_ICON$n,
    LABEL_TAB_LOGO: LABEL_TAB_LOGO$n,
    LABEL_TAB_MANAGE: LABEL_TAB_MANAGE$n,
    LABEL_TAB_WIDECAPSULE: LABEL_TAB_WIDECAPSULE$n,
    LABEL_TRANSLATION_CREDIT_TITLE: LABEL_TRANSLATION_CREDIT_TITLE$n,
    LABEL_USAGE_TITLE: LABEL_USAGE_TITLE$m,
    MSG_ASSETS_FILTERED: MSG_ASSETS_FILTERED$m,
    MSG_ASSET_APPLY_ERROR: MSG_ASSET_APPLY_ERROR$l,
    MSG_ASSET_APPLY_SUCCESS: MSG_ASSET_APPLY_SUCCESS$m,
    MSG_ASSET_TAB_SETTINGS_DESC: MSG_ASSET_TAB_SETTINGS_DESC$l,
    MSG_FILTER_TAG_NSFW_ENABLED: MSG_FILTER_TAG_NSFW_ENABLED$m,
    MSG_GAME_SELECTED: MSG_GAME_SELECTED$m,
    MSG_GAME_SELECTED_AND_ASSETS_FILTERED: MSG_GAME_SELECTED_AND_ASSETS_FILTERED$m,
    MSG_RESTART_STEAM_DESC: MSG_RESTART_STEAM_DESC$l,
    MSG_USAGE_INSTRUCTIONS: MSG_USAGE_INSTRUCTIONS$m,
    default: cs
});

var ASSET_TYPE_CAPSULE$m="Kapsel";var ASSET_TYPE_WIDECAPSULE$m="Bred Kapsel";var ASSET_TYPE_HERO$m="Megabanner";var ASSET_TYPE_LOGO$m="Logo";var ASSET_TYPE_ICON$m="Ikon";var LABEL_TAB_CAPSULE$m="Kapsel";var LABEL_TAB_WIDECAPSULE$m="Bred Kapsel";var LABEL_TAB_HERO$m="Megabanner";var LABEL_TAB_LOGO$m="Logo";var LABEL_TAB_ICON$m="Ikon";var LABEL_TAB_MANAGE$m="Administrer";var MSG_USAGE_INSTRUCTIONS$l="Vælg et spil {arrow} {optionsButton} {arrow} \"{ACTION_CHANGE_ARTWORK}\"";var ACTION_CHANGE_ARTWORK$m="Ændr kunstværk...";var ACTION_SHOW_LINK_QR$m="Vis link som QR";var MSG_ASSET_TAB_SETTINGS_DESC$k="Flyt rundt på eller skjul faner du ikke bruger, og indstil hvilken fane, der åbnes som standard, når der trykkes på \"{ACTION_CHANGE_ARTWORK}\"";var LABEL_USAGE_TITLE$l="Forvirret? Her er en hurtig-guide";var LABEL_SQUARE_CAPSULES$j="Kvadratiske kapsler";var LABEL_SQUARE_CAPSULES_DESC$i="Anvend kvadratiske kapsler i stedet for portræt-kapsler. Kvadratiske filtre vælges automatisk.";var LABEL_UNIFORM_RECENT$e="Match kapsel for seneste spil";var LABEL_UNIFORM_RECENT_DESC$e="Får det senest spillede spil på startskærmen til at matche de øvrige kapsler. ";var LABEL_CAPSULE_GLOW$j="Glød-effekt";var LABEL_CAPSULE_GLOW_DESC$i="Juster intensiteten af kapslens glød-effekt i biblioteket.";var LABEL_CAPSULE_GLOW_OFF$j="Ingen";var LABEL_SETTINGS_ASSET_TABS$k="Faneindstillinger";var LABEL_SETTINGS_DISABLE_MOTD$g="Deaktiver meddelelser";var LABEL_SETTINGS_DISABLE_MOTD_DESC$f="Meddelelser bruges sparsomt til at vise vigtige oplysninger eller fællesskabsbegivenheder.";var LABEL_TRANSLATION_CREDIT_TITLE$m="Dansk oversættelse";var LABEL_MORE_SGDB_TITLE$m="Mere fra SteamgridDB";var ACTION_SGDB_DISCORD$m="Deltag i vores Discord";var ACTION_SGDB_GITHUB$l="Open Source-projekter";var ACTION_SGDB_DONATE$m="Støt os via Patreon";var ACTION_SGDB_TRANSLATE$m="Hjælp med oversættelser";var ACTION_SGDB_BOOP$m="Tjek SGDBoop ud";var LABEL_RESTART_STEAM_TITLE$l="Genstart Steam?";var ACTION_RESTART_STEAM_LATER$l="Senere";var ACTION_RESTART_STEAM_NOW$l="Genstart nu";var MSG_RESTART_STEAM_DESC$k="Steam skal genstartes før ændringerne træder i kraft.";var LABEL_GAME_SEARCH_TITLE$m="Søg efter et spil...";var LABEL_FILTER_MODAL_TITLE$m="{assetType} Filter";var LABEL_FILTER_GAME$m="Spil";var LABEL_FILTER_DIMENSIONS$m="Opløsninger";var LABEL_FILTER_STYLES$m="Stilarter";var LABEL_FILTER_FILE_TYPES$m="Filtyper";var LABEL_FILTER_ANIMATION_TYPE_TITLE$m="Typer";var LABEL_FILTER_TYPE_ANIMATED$l="Animeret";var LABEL_FILTER_TYPE_STATIC$l="Statisk";var LABEL_FILTER_TAGS_TITLE$m="Tags";var LABEL_FILTER_TAG_NSFW$m="Voksenindhold";var MSG_FILTER_TAG_NSFW_ENABLED$l="Har du tjekket dine omgivelser?";var LABEL_FILTER_TAG_HUMOR$l="Humor";var LABEL_FILTER_TAG_EPILEPSY$l="Epilepsi";var LABEL_FILTER_TAG_UNTAGGED$l="Ikke tagget";var ACTION_FILTER_RESET$m="Nulstil filtre";var LABEL_BEGGING_MODAL_TITLE$j="Tak fordi du bruger SteamGridDB!";var LABEL_BEGGING_MODAL_DESC$i="Overvej venligst at donere for at hjælpe med vedligeholdelse og serveromkostninger!";var ACTION_HIDE_POS_GUIDES$k="Skjul hjælpelinjer";var ACTION_SHOW_OUTLINE$k="Vis hjælpelinjer";var ACTION_ADJUST_POS_SIZE$l="Tilpas størrelse";var ACTION_CHANGE_POS_LOGO_ANCHOR_POINT$e="Skift ankerpunkt";var LABEL_ASSET_CURRENT$l="Nuværende {assetType}";var ACTION_ASSET_CUSTOM_CLEAR$l="Ryd den brugervalgte grafik";var ACTION_ASSET_BROWSE_LOCAL$k="Gennemse lokale filer";var ACTION_ASSET_APPLY_TRANSPARENT$k="Anvend usynlig grafik";var LABEL_NOTES$m="Noter";var LABEL_ANIMATED$l="Animeret";var LABEL_NSFW$m="Voksenindhold";var LABEL_HUMOR$l="Humor";var LABEL_EPILEPSY$l="Epilepsi";var ACTION_OPEN_FILTER$m="Filtrér";var ACTION_OPEN_OFFICIAL_ASSETS$l="Officiel grafik";var ACTION_ASSET_APPLY$l="Anvend {assetType}";var MSG_GAME_SELECTED$l="Valgte {gameName}";var MSG_ASSETS_FILTERED$l="Nogle grafiske elementer kan være skjult som følge af filtre";var MSG_GAME_SELECTED_AND_ASSETS_FILTERED$l="Valgte {gameName} med filter";var TITLE_MOTD_HIDE$f="Skjul meddelelser?";var LABEL_MOTD_THIS$f="Kun denne meddelelse";var LABEL_MOTD_ALL$f="Alle meddelelser";var MSG_ASSET_APPLY_SUCCESS$l="Valgte {assetType} anvendes!";var MSG_ASSET_APPLY_ERROR$k="Der opstod et problem ved anvendelse af dette element.";var ACTION_OPEN_DETAILS$l="Detaljer";var da = {ASSET_TYPE_CAPSULE:ASSET_TYPE_CAPSULE$m,ASSET_TYPE_WIDECAPSULE:ASSET_TYPE_WIDECAPSULE$m,ASSET_TYPE_HERO:ASSET_TYPE_HERO$m,ASSET_TYPE_LOGO:ASSET_TYPE_LOGO$m,ASSET_TYPE_ICON:ASSET_TYPE_ICON$m,LABEL_TAB_CAPSULE:LABEL_TAB_CAPSULE$m,LABEL_TAB_WIDECAPSULE:LABEL_TAB_WIDECAPSULE$m,LABEL_TAB_HERO:LABEL_TAB_HERO$m,LABEL_TAB_LOGO:LABEL_TAB_LOGO$m,LABEL_TAB_ICON:LABEL_TAB_ICON$m,LABEL_TAB_MANAGE:LABEL_TAB_MANAGE$m,MSG_USAGE_INSTRUCTIONS:MSG_USAGE_INSTRUCTIONS$l,ACTION_CHANGE_ARTWORK:ACTION_CHANGE_ARTWORK$m,ACTION_SHOW_LINK_QR:ACTION_SHOW_LINK_QR$m,MSG_ASSET_TAB_SETTINGS_DESC:MSG_ASSET_TAB_SETTINGS_DESC$k,LABEL_USAGE_TITLE:LABEL_USAGE_TITLE$l,LABEL_SQUARE_CAPSULES:LABEL_SQUARE_CAPSULES$j,LABEL_SQUARE_CAPSULES_DESC:LABEL_SQUARE_CAPSULES_DESC$i,LABEL_UNIFORM_RECENT:LABEL_UNIFORM_RECENT$e,LABEL_UNIFORM_RECENT_DESC:LABEL_UNIFORM_RECENT_DESC$e,LABEL_CAPSULE_GLOW:LABEL_CAPSULE_GLOW$j,LABEL_CAPSULE_GLOW_DESC:LABEL_CAPSULE_GLOW_DESC$i,LABEL_CAPSULE_GLOW_OFF:LABEL_CAPSULE_GLOW_OFF$j,LABEL_SETTINGS_ASSET_TABS:LABEL_SETTINGS_ASSET_TABS$k,LABEL_SETTINGS_DISABLE_MOTD:LABEL_SETTINGS_DISABLE_MOTD$g,LABEL_SETTINGS_DISABLE_MOTD_DESC:LABEL_SETTINGS_DISABLE_MOTD_DESC$f,LABEL_TRANSLATION_CREDIT_TITLE:LABEL_TRANSLATION_CREDIT_TITLE$m,LABEL_MORE_SGDB_TITLE:LABEL_MORE_SGDB_TITLE$m,ACTION_SGDB_DISCORD:ACTION_SGDB_DISCORD$m,ACTION_SGDB_GITHUB:ACTION_SGDB_GITHUB$l,ACTION_SGDB_DONATE:ACTION_SGDB_DONATE$m,ACTION_SGDB_TRANSLATE:ACTION_SGDB_TRANSLATE$m,ACTION_SGDB_BOOP:ACTION_SGDB_BOOP$m,LABEL_RESTART_STEAM_TITLE:LABEL_RESTART_STEAM_TITLE$l,ACTION_RESTART_STEAM_LATER:ACTION_RESTART_STEAM_LATER$l,ACTION_RESTART_STEAM_NOW:ACTION_RESTART_STEAM_NOW$l,MSG_RESTART_STEAM_DESC:MSG_RESTART_STEAM_DESC$k,LABEL_GAME_SEARCH_TITLE:LABEL_GAME_SEARCH_TITLE$m,LABEL_FILTER_MODAL_TITLE:LABEL_FILTER_MODAL_TITLE$m,LABEL_FILTER_GAME:LABEL_FILTER_GAME$m,LABEL_FILTER_DIMENSIONS:LABEL_FILTER_DIMENSIONS$m,LABEL_FILTER_STYLES:LABEL_FILTER_STYLES$m,LABEL_FILTER_FILE_TYPES:LABEL_FILTER_FILE_TYPES$m,LABEL_FILTER_ANIMATION_TYPE_TITLE:LABEL_FILTER_ANIMATION_TYPE_TITLE$m,LABEL_FILTER_TYPE_ANIMATED:LABEL_FILTER_TYPE_ANIMATED$l,LABEL_FILTER_TYPE_STATIC:LABEL_FILTER_TYPE_STATIC$l,LABEL_FILTER_TAGS_TITLE:LABEL_FILTER_TAGS_TITLE$m,LABEL_FILTER_TAG_NSFW:LABEL_FILTER_TAG_NSFW$m,MSG_FILTER_TAG_NSFW_ENABLED:MSG_FILTER_TAG_NSFW_ENABLED$l,LABEL_FILTER_TAG_HUMOR:LABEL_FILTER_TAG_HUMOR$l,LABEL_FILTER_TAG_EPILEPSY:LABEL_FILTER_TAG_EPILEPSY$l,LABEL_FILTER_TAG_UNTAGGED:LABEL_FILTER_TAG_UNTAGGED$l,ACTION_FILTER_RESET:ACTION_FILTER_RESET$m,LABEL_BEGGING_MODAL_TITLE:LABEL_BEGGING_MODAL_TITLE$j,LABEL_BEGGING_MODAL_DESC:LABEL_BEGGING_MODAL_DESC$i,ACTION_HIDE_POS_GUIDES:ACTION_HIDE_POS_GUIDES$k,ACTION_SHOW_OUTLINE:ACTION_SHOW_OUTLINE$k,ACTION_ADJUST_POS_SIZE:ACTION_ADJUST_POS_SIZE$l,ACTION_CHANGE_POS_LOGO_ANCHOR_POINT:ACTION_CHANGE_POS_LOGO_ANCHOR_POINT$e,LABEL_ASSET_CURRENT:LABEL_ASSET_CURRENT$l,ACTION_ASSET_CUSTOM_CLEAR:ACTION_ASSET_CUSTOM_CLEAR$l,ACTION_ASSET_BROWSE_LOCAL:ACTION_ASSET_BROWSE_LOCAL$k,ACTION_ASSET_APPLY_TRANSPARENT:ACTION_ASSET_APPLY_TRANSPARENT$k,LABEL_NOTES:LABEL_NOTES$m,LABEL_ANIMATED:LABEL_ANIMATED$l,LABEL_NSFW:LABEL_NSFW$m,LABEL_HUMOR:LABEL_HUMOR$l,LABEL_EPILEPSY:LABEL_EPILEPSY$l,ACTION_OPEN_FILTER:ACTION_OPEN_FILTER$m,ACTION_OPEN_OFFICIAL_ASSETS:ACTION_OPEN_OFFICIAL_ASSETS$l,ACTION_ASSET_APPLY:ACTION_ASSET_APPLY$l,MSG_GAME_SELECTED:MSG_GAME_SELECTED$l,MSG_ASSETS_FILTERED:MSG_ASSETS_FILTERED$l,MSG_GAME_SELECTED_AND_ASSETS_FILTERED:MSG_GAME_SELECTED_AND_ASSETS_FILTERED$l,TITLE_MOTD_HIDE:TITLE_MOTD_HIDE$f,LABEL_MOTD_THIS:LABEL_MOTD_THIS$f,LABEL_MOTD_ALL:LABEL_MOTD_ALL$f,MSG_ASSET_APPLY_SUCCESS:MSG_ASSET_APPLY_SUCCESS$l,MSG_ASSET_APPLY_ERROR:MSG_ASSET_APPLY_ERROR$k,ACTION_OPEN_DETAILS:ACTION_OPEN_DETAILS$l};

var da$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    ACTION_ADJUST_POS_SIZE: ACTION_ADJUST_POS_SIZE$l,
    ACTION_ASSET_APPLY: ACTION_ASSET_APPLY$l,
    ACTION_ASSET_APPLY_TRANSPARENT: ACTION_ASSET_APPLY_TRANSPARENT$k,
    ACTION_ASSET_BROWSE_LOCAL: ACTION_ASSET_BROWSE_LOCAL$k,
    ACTION_ASSET_CUSTOM_CLEAR: ACTION_ASSET_CUSTOM_CLEAR$l,
    ACTION_CHANGE_ARTWORK: ACTION_CHANGE_ARTWORK$m,
    ACTION_CHANGE_POS_LOGO_ANCHOR_POINT: ACTION_CHANGE_POS_LOGO_ANCHOR_POINT$e,
    ACTION_FILTER_RESET: ACTION_FILTER_RESET$m,
    ACTION_HIDE_POS_GUIDES: ACTION_HIDE_POS_GUIDES$k,
    ACTION_OPEN_DETAILS: ACTION_OPEN_DETAILS$l,
    ACTION_OPEN_FILTER: ACTION_OPEN_FILTER$m,
    ACTION_OPEN_OFFICIAL_ASSETS: ACTION_OPEN_OFFICIAL_ASSETS$l,
    ACTION_RESTART_STEAM_LATER: ACTION_RESTART_STEAM_LATER$l,
    ACTION_RESTART_STEAM_NOW: ACTION_RESTART_STEAM_NOW$l,
    ACTION_SGDB_BOOP: ACTION_SGDB_BOOP$m,
    ACTION_SGDB_DISCORD: ACTION_SGDB_DISCORD$m,
    ACTION_SGDB_DONATE: ACTION_SGDB_DONATE$m,
    ACTION_SGDB_GITHUB: ACTION_SGDB_GITHUB$l,
    ACTION_SGDB_TRANSLATE: ACTION_SGDB_TRANSLATE$m,
    ACTION_SHOW_LINK_QR: ACTION_SHOW_LINK_QR$m,
    ACTION_SHOW_OUTLINE: ACTION_SHOW_OUTLINE$k,
    ASSET_TYPE_CAPSULE: ASSET_TYPE_CAPSULE$m,
    ASSET_TYPE_HERO: ASSET_TYPE_HERO$m,
    ASSET_TYPE_ICON: ASSET_TYPE_ICON$m,
    ASSET_TYPE_LOGO: ASSET_TYPE_LOGO$m,
    ASSET_TYPE_WIDECAPSULE: ASSET_TYPE_WIDECAPSULE$m,
    LABEL_ANIMATED: LABEL_ANIMATED$l,
    LABEL_ASSET_CURRENT: LABEL_ASSET_CURRENT$l,
    LABEL_BEGGING_MODAL_DESC: LABEL_BEGGING_MODAL_DESC$i,
    LABEL_BEGGING_MODAL_TITLE: LABEL_BEGGING_MODAL_TITLE$j,
    LABEL_CAPSULE_GLOW: LABEL_CAPSULE_GLOW$j,
    LABEL_CAPSULE_GLOW_DESC: LABEL_CAPSULE_GLOW_DESC$i,
    LABEL_CAPSULE_GLOW_OFF: LABEL_CAPSULE_GLOW_OFF$j,
    LABEL_EPILEPSY: LABEL_EPILEPSY$l,
    LABEL_FILTER_ANIMATION_TYPE_TITLE: LABEL_FILTER_ANIMATION_TYPE_TITLE$m,
    LABEL_FILTER_DIMENSIONS: LABEL_FILTER_DIMENSIONS$m,
    LABEL_FILTER_FILE_TYPES: LABEL_FILTER_FILE_TYPES$m,
    LABEL_FILTER_GAME: LABEL_FILTER_GAME$m,
    LABEL_FILTER_MODAL_TITLE: LABEL_FILTER_MODAL_TITLE$m,
    LABEL_FILTER_STYLES: LABEL_FILTER_STYLES$m,
    LABEL_FILTER_TAGS_TITLE: LABEL_FILTER_TAGS_TITLE$m,
    LABEL_FILTER_TAG_EPILEPSY: LABEL_FILTER_TAG_EPILEPSY$l,
    LABEL_FILTER_TAG_HUMOR: LABEL_FILTER_TAG_HUMOR$l,
    LABEL_FILTER_TAG_NSFW: LABEL_FILTER_TAG_NSFW$m,
    LABEL_FILTER_TAG_UNTAGGED: LABEL_FILTER_TAG_UNTAGGED$l,
    LABEL_FILTER_TYPE_ANIMATED: LABEL_FILTER_TYPE_ANIMATED$l,
    LABEL_FILTER_TYPE_STATIC: LABEL_FILTER_TYPE_STATIC$l,
    LABEL_GAME_SEARCH_TITLE: LABEL_GAME_SEARCH_TITLE$m,
    LABEL_HUMOR: LABEL_HUMOR$l,
    LABEL_MORE_SGDB_TITLE: LABEL_MORE_SGDB_TITLE$m,
    LABEL_MOTD_ALL: LABEL_MOTD_ALL$f,
    LABEL_MOTD_THIS: LABEL_MOTD_THIS$f,
    LABEL_NOTES: LABEL_NOTES$m,
    LABEL_NSFW: LABEL_NSFW$m,
    LABEL_RESTART_STEAM_TITLE: LABEL_RESTART_STEAM_TITLE$l,
    LABEL_SETTINGS_ASSET_TABS: LABEL_SETTINGS_ASSET_TABS$k,
    LABEL_SETTINGS_DISABLE_MOTD: LABEL_SETTINGS_DISABLE_MOTD$g,
    LABEL_SETTINGS_DISABLE_MOTD_DESC: LABEL_SETTINGS_DISABLE_MOTD_DESC$f,
    LABEL_SQUARE_CAPSULES: LABEL_SQUARE_CAPSULES$j,
    LABEL_SQUARE_CAPSULES_DESC: LABEL_SQUARE_CAPSULES_DESC$i,
    LABEL_TAB_CAPSULE: LABEL_TAB_CAPSULE$m,
    LABEL_TAB_HERO: LABEL_TAB_HERO$m,
    LABEL_TAB_ICON: LABEL_TAB_ICON$m,
    LABEL_TAB_LOGO: LABEL_TAB_LOGO$m,
    LABEL_TAB_MANAGE: LABEL_TAB_MANAGE$m,
    LABEL_TAB_WIDECAPSULE: LABEL_TAB_WIDECAPSULE$m,
    LABEL_TRANSLATION_CREDIT_TITLE: LABEL_TRANSLATION_CREDIT_TITLE$m,
    LABEL_UNIFORM_RECENT: LABEL_UNIFORM_RECENT$e,
    LABEL_UNIFORM_RECENT_DESC: LABEL_UNIFORM_RECENT_DESC$e,
    LABEL_USAGE_TITLE: LABEL_USAGE_TITLE$l,
    MSG_ASSETS_FILTERED: MSG_ASSETS_FILTERED$l,
    MSG_ASSET_APPLY_ERROR: MSG_ASSET_APPLY_ERROR$k,
    MSG_ASSET_APPLY_SUCCESS: MSG_ASSET_APPLY_SUCCESS$l,
    MSG_ASSET_TAB_SETTINGS_DESC: MSG_ASSET_TAB_SETTINGS_DESC$k,
    MSG_FILTER_TAG_NSFW_ENABLED: MSG_FILTER_TAG_NSFW_ENABLED$l,
    MSG_GAME_SELECTED: MSG_GAME_SELECTED$l,
    MSG_GAME_SELECTED_AND_ASSETS_FILTERED: MSG_GAME_SELECTED_AND_ASSETS_FILTERED$l,
    MSG_RESTART_STEAM_DESC: MSG_RESTART_STEAM_DESC$k,
    MSG_USAGE_INSTRUCTIONS: MSG_USAGE_INSTRUCTIONS$l,
    TITLE_MOTD_HIDE: TITLE_MOTD_HIDE$f,
    default: da
});

var ASSET_TYPE_CAPSULE$l="Kapsel";var ASSET_TYPE_WIDECAPSULE$l="Breite Kapsel";var ASSET_TYPE_HERO$l="Heldenbild";var ASSET_TYPE_LOGO$l="Logo";var ASSET_TYPE_ICON$l="Symbol";var LABEL_TAB_CAPSULE$l="Kapsel";var LABEL_TAB_WIDECAPSULE$l="Breite Kapsel";var LABEL_TAB_HERO$l="Heldenbild";var LABEL_TAB_LOGO$l="Logo";var LABEL_TAB_ICON$l="Symbol";var LABEL_TAB_MANAGE$l="Verwalten";var MSG_USAGE_INSTRUCTIONS$k="Wähle ein Spiel {arrow} {optionsButton} {arrow} \"{ACTION_CHANGE_ARTWORK}\"";var ACTION_CHANGE_ARTWORK$l="Kunstwerk ändern...";var ACTION_SHOW_LINK_QR$l="QR Link anzeigen";var MSG_ASSET_TAB_SETTINGS_DESC$j="Ungenutzte Tabs ausblenden, neu anordnen oder einen Standard Tab auswählen der bei  \"{ACTION_CHANGE_ARTWORK}\" als erstes geöffnet werden soll.";var LABEL_USAGE_TITLE$k="Verlaufen? Hier ist eine Kurzanleitung";var LABEL_SQUARE_CAPSULES$i="Quadratische Kapseln";var LABEL_SQUARE_CAPSULES_DESC$h="Benutze quadratische Kapseln anstelle von Kapseln im Hochformat. Quadratische Filter werden automatisch ausgewählt.";var LABEL_UNIFORM_RECENT$d="Passende Zuletzt-Gespielt Kapsel";var LABEL_UNIFORM_RECENT_DESC$d="Passt die Kapsel des zuletzt gespielten Spieles an das Aussehen der regulären Kapseln an.";var LABEL_CAPSULE_GLOW$i="Kapsel-Glühen";var LABEL_CAPSULE_GLOW_DESC$h="Passe die Intensität des Glühens der Kapseln in der Bibliothek an.";var LABEL_CAPSULE_GLOW_OFF$i="Keine Auswahl";var LABEL_SETTINGS_ASSET_TABS$j="Asset-Tab Einstellungen";var LABEL_SETTINGS_DISABLE_MOTD$f="Ankündigungen Deaktivieren";var LABEL_SETTINGS_DISABLE_MOTD_DESC$e="Ankündigungen werden sparsam verwendet, um wichtige Informationen oder Community-Ereignisse anzuzeigen.";var LABEL_TRANSLATION_CREDIT_TITLE$l="Deutsche Übersetzung";var LABEL_MORE_SGDB_TITLE$l="Mehr Steamgriddb Plattformen";var ACTION_SGDB_DISCORD$l="Tritt dem Discord bei";var ACTION_SGDB_GITHUB$k="Open Source Projekte";var ACTION_SGDB_DONATE$l="Unterstütze uns auf Patreon";var ACTION_SGDB_TRANSLATE$l="Hilf beim Übersetzen";var ACTION_SGDB_BOOP$l="Schau dir SGDBoop an";var LABEL_RESTART_STEAM_TITLE$k="Steam neu starten?";var ACTION_RESTART_STEAM_LATER$k="Später";var ACTION_RESTART_STEAM_NOW$k="Jetzt Neustarten";var MSG_RESTART_STEAM_DESC$j="Steam muss neu gestartet werden, um die Änderungen zu übernehmen.";var LABEL_GAME_SEARCH_TITLE$l="Suche nach einem Spiel...";var LABEL_FILTER_MODAL_TITLE$l="{assetType} Filter";var LABEL_FILTER_GAME$l="Spiel";var LABEL_FILTER_DIMENSIONS$l="Dimensionen";var LABEL_FILTER_STYLES$l="Stile";var LABEL_FILTER_FILE_TYPES$l="Dateitypen";var LABEL_FILTER_ANIMATION_TYPE_TITLE$l="Typen";var LABEL_FILTER_TYPE_ANIMATED$k="Animiert";var LABEL_FILTER_TYPE_STATIC$k="Einzelbild / Statisch";var LABEL_FILTER_TAGS_TITLE$l="Tags / Schlagwort";var LABEL_FILTER_TAG_NSFW$l="Inhalt für Erwachsene";var MSG_FILTER_TAG_NSFW_ENABLED$k="Vielleicht möchtest du noch einmal drüber schauen.";var LABEL_FILTER_TAG_HUMOR$k="Humor";var LABEL_FILTER_TAG_EPILEPSY$k="Epilepsie";var LABEL_FILTER_TAG_UNTAGGED$k="Ohne Tag";var ACTION_FILTER_RESET$l="Filter Zurücksetzen";var LABEL_BEGGING_MODAL_TITLE$i="Vielen Dank, dass du SteamGridDB verwendest!";var LABEL_BEGGING_MODAL_DESC$h="Bitte denke über eine Spende nach! Sie hilft, die Kosten für Wartung und Server zu decken!";var ACTION_HIDE_POS_GUIDES$j="Anleitungen ausblenden";var ACTION_SHOW_OUTLINE$j="Anleitung anzeigen";var ACTION_ADJUST_POS_SIZE$k="Größe anpassen";var ACTION_CHANGE_POS_LOGO_ANCHOR_POINT$d="Ankerpunkt ändern";var LABEL_ASSET_CURRENT$k="Aktuelle {assetType}";var ACTION_ASSET_CUSTOM_CLEAR$k="Eigenen Inhalt löschen";var ACTION_ASSET_BROWSE_LOCAL$j="Nach lokalen Dateien suchen";var ACTION_ASSET_APPLY_TRANSPARENT$j="Unsichtbaren Inhalt verwenden";var LABEL_NOTES$l="Notizen";var LABEL_ANIMATED$k="Animiert";var LABEL_NSFW$l="Inhalt für Erwachsene";var LABEL_HUMOR$k="Humor";var LABEL_EPILEPSY$k="Epilepsie";var ACTION_OPEN_FILTER$l="Filter";var ACTION_OPEN_OFFICIAL_ASSETS$k="Offizielle {assetType}";var ACTION_ASSET_APPLY$k="{assetType} Übernehmen";var MSG_GAME_SELECTED$k="{gameName} ausgewählt";var MSG_ASSETS_FILTERED$k="Einige Inhalte könnten durch Filter ausgeblendet werden";var MSG_GAME_SELECTED_AND_ASSETS_FILTERED$k="{gameName} mit Filter ausgewählt";var TITLE_MOTD_HIDE$e="Ankündigung ausblenden?";var LABEL_MOTD_THIS$e="Diese Ankündigung";var LABEL_MOTD_ALL$e="Alle Ankündigungen";var MSG_ASSET_APPLY_SUCCESS$k="{assetType} Wurde erfolgreich angewendet!";var MSG_ASSET_APPLY_ERROR$j="Es gab ein Problem beim hinzufügen des Inhalts.";var ACTION_OPEN_DETAILS$k="Eigenschaften";var de = {ASSET_TYPE_CAPSULE:ASSET_TYPE_CAPSULE$l,ASSET_TYPE_WIDECAPSULE:ASSET_TYPE_WIDECAPSULE$l,ASSET_TYPE_HERO:ASSET_TYPE_HERO$l,ASSET_TYPE_LOGO:ASSET_TYPE_LOGO$l,ASSET_TYPE_ICON:ASSET_TYPE_ICON$l,LABEL_TAB_CAPSULE:LABEL_TAB_CAPSULE$l,LABEL_TAB_WIDECAPSULE:LABEL_TAB_WIDECAPSULE$l,LABEL_TAB_HERO:LABEL_TAB_HERO$l,LABEL_TAB_LOGO:LABEL_TAB_LOGO$l,LABEL_TAB_ICON:LABEL_TAB_ICON$l,LABEL_TAB_MANAGE:LABEL_TAB_MANAGE$l,MSG_USAGE_INSTRUCTIONS:MSG_USAGE_INSTRUCTIONS$k,ACTION_CHANGE_ARTWORK:ACTION_CHANGE_ARTWORK$l,ACTION_SHOW_LINK_QR:ACTION_SHOW_LINK_QR$l,MSG_ASSET_TAB_SETTINGS_DESC:MSG_ASSET_TAB_SETTINGS_DESC$j,LABEL_USAGE_TITLE:LABEL_USAGE_TITLE$k,LABEL_SQUARE_CAPSULES:LABEL_SQUARE_CAPSULES$i,LABEL_SQUARE_CAPSULES_DESC:LABEL_SQUARE_CAPSULES_DESC$h,LABEL_UNIFORM_RECENT:LABEL_UNIFORM_RECENT$d,LABEL_UNIFORM_RECENT_DESC:LABEL_UNIFORM_RECENT_DESC$d,LABEL_CAPSULE_GLOW:LABEL_CAPSULE_GLOW$i,LABEL_CAPSULE_GLOW_DESC:LABEL_CAPSULE_GLOW_DESC$h,LABEL_CAPSULE_GLOW_OFF:LABEL_CAPSULE_GLOW_OFF$i,LABEL_SETTINGS_ASSET_TABS:LABEL_SETTINGS_ASSET_TABS$j,LABEL_SETTINGS_DISABLE_MOTD:LABEL_SETTINGS_DISABLE_MOTD$f,LABEL_SETTINGS_DISABLE_MOTD_DESC:LABEL_SETTINGS_DISABLE_MOTD_DESC$e,LABEL_TRANSLATION_CREDIT_TITLE:LABEL_TRANSLATION_CREDIT_TITLE$l,LABEL_MORE_SGDB_TITLE:LABEL_MORE_SGDB_TITLE$l,ACTION_SGDB_DISCORD:ACTION_SGDB_DISCORD$l,ACTION_SGDB_GITHUB:ACTION_SGDB_GITHUB$k,ACTION_SGDB_DONATE:ACTION_SGDB_DONATE$l,ACTION_SGDB_TRANSLATE:ACTION_SGDB_TRANSLATE$l,ACTION_SGDB_BOOP:ACTION_SGDB_BOOP$l,LABEL_RESTART_STEAM_TITLE:LABEL_RESTART_STEAM_TITLE$k,ACTION_RESTART_STEAM_LATER:ACTION_RESTART_STEAM_LATER$k,ACTION_RESTART_STEAM_NOW:ACTION_RESTART_STEAM_NOW$k,MSG_RESTART_STEAM_DESC:MSG_RESTART_STEAM_DESC$j,LABEL_GAME_SEARCH_TITLE:LABEL_GAME_SEARCH_TITLE$l,LABEL_FILTER_MODAL_TITLE:LABEL_FILTER_MODAL_TITLE$l,LABEL_FILTER_GAME:LABEL_FILTER_GAME$l,LABEL_FILTER_DIMENSIONS:LABEL_FILTER_DIMENSIONS$l,LABEL_FILTER_STYLES:LABEL_FILTER_STYLES$l,LABEL_FILTER_FILE_TYPES:LABEL_FILTER_FILE_TYPES$l,LABEL_FILTER_ANIMATION_TYPE_TITLE:LABEL_FILTER_ANIMATION_TYPE_TITLE$l,LABEL_FILTER_TYPE_ANIMATED:LABEL_FILTER_TYPE_ANIMATED$k,LABEL_FILTER_TYPE_STATIC:LABEL_FILTER_TYPE_STATIC$k,LABEL_FILTER_TAGS_TITLE:LABEL_FILTER_TAGS_TITLE$l,LABEL_FILTER_TAG_NSFW:LABEL_FILTER_TAG_NSFW$l,MSG_FILTER_TAG_NSFW_ENABLED:MSG_FILTER_TAG_NSFW_ENABLED$k,LABEL_FILTER_TAG_HUMOR:LABEL_FILTER_TAG_HUMOR$k,LABEL_FILTER_TAG_EPILEPSY:LABEL_FILTER_TAG_EPILEPSY$k,LABEL_FILTER_TAG_UNTAGGED:LABEL_FILTER_TAG_UNTAGGED$k,ACTION_FILTER_RESET:ACTION_FILTER_RESET$l,LABEL_BEGGING_MODAL_TITLE:LABEL_BEGGING_MODAL_TITLE$i,LABEL_BEGGING_MODAL_DESC:LABEL_BEGGING_MODAL_DESC$h,ACTION_HIDE_POS_GUIDES:ACTION_HIDE_POS_GUIDES$j,ACTION_SHOW_OUTLINE:ACTION_SHOW_OUTLINE$j,ACTION_ADJUST_POS_SIZE:ACTION_ADJUST_POS_SIZE$k,ACTION_CHANGE_POS_LOGO_ANCHOR_POINT:ACTION_CHANGE_POS_LOGO_ANCHOR_POINT$d,LABEL_ASSET_CURRENT:LABEL_ASSET_CURRENT$k,ACTION_ASSET_CUSTOM_CLEAR:ACTION_ASSET_CUSTOM_CLEAR$k,ACTION_ASSET_BROWSE_LOCAL:ACTION_ASSET_BROWSE_LOCAL$j,ACTION_ASSET_APPLY_TRANSPARENT:ACTION_ASSET_APPLY_TRANSPARENT$j,LABEL_NOTES:LABEL_NOTES$l,LABEL_ANIMATED:LABEL_ANIMATED$k,LABEL_NSFW:LABEL_NSFW$l,LABEL_HUMOR:LABEL_HUMOR$k,LABEL_EPILEPSY:LABEL_EPILEPSY$k,ACTION_OPEN_FILTER:ACTION_OPEN_FILTER$l,ACTION_OPEN_OFFICIAL_ASSETS:ACTION_OPEN_OFFICIAL_ASSETS$k,ACTION_ASSET_APPLY:ACTION_ASSET_APPLY$k,MSG_GAME_SELECTED:MSG_GAME_SELECTED$k,MSG_ASSETS_FILTERED:MSG_ASSETS_FILTERED$k,MSG_GAME_SELECTED_AND_ASSETS_FILTERED:MSG_GAME_SELECTED_AND_ASSETS_FILTERED$k,TITLE_MOTD_HIDE:TITLE_MOTD_HIDE$e,LABEL_MOTD_THIS:LABEL_MOTD_THIS$e,LABEL_MOTD_ALL:LABEL_MOTD_ALL$e,MSG_ASSET_APPLY_SUCCESS:MSG_ASSET_APPLY_SUCCESS$k,MSG_ASSET_APPLY_ERROR:MSG_ASSET_APPLY_ERROR$j,ACTION_OPEN_DETAILS:ACTION_OPEN_DETAILS$k};

var de$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    ACTION_ADJUST_POS_SIZE: ACTION_ADJUST_POS_SIZE$k,
    ACTION_ASSET_APPLY: ACTION_ASSET_APPLY$k,
    ACTION_ASSET_APPLY_TRANSPARENT: ACTION_ASSET_APPLY_TRANSPARENT$j,
    ACTION_ASSET_BROWSE_LOCAL: ACTION_ASSET_BROWSE_LOCAL$j,
    ACTION_ASSET_CUSTOM_CLEAR: ACTION_ASSET_CUSTOM_CLEAR$k,
    ACTION_CHANGE_ARTWORK: ACTION_CHANGE_ARTWORK$l,
    ACTION_CHANGE_POS_LOGO_ANCHOR_POINT: ACTION_CHANGE_POS_LOGO_ANCHOR_POINT$d,
    ACTION_FILTER_RESET: ACTION_FILTER_RESET$l,
    ACTION_HIDE_POS_GUIDES: ACTION_HIDE_POS_GUIDES$j,
    ACTION_OPEN_DETAILS: ACTION_OPEN_DETAILS$k,
    ACTION_OPEN_FILTER: ACTION_OPEN_FILTER$l,
    ACTION_OPEN_OFFICIAL_ASSETS: ACTION_OPEN_OFFICIAL_ASSETS$k,
    ACTION_RESTART_STEAM_LATER: ACTION_RESTART_STEAM_LATER$k,
    ACTION_RESTART_STEAM_NOW: ACTION_RESTART_STEAM_NOW$k,
    ACTION_SGDB_BOOP: ACTION_SGDB_BOOP$l,
    ACTION_SGDB_DISCORD: ACTION_SGDB_DISCORD$l,
    ACTION_SGDB_DONATE: ACTION_SGDB_DONATE$l,
    ACTION_SGDB_GITHUB: ACTION_SGDB_GITHUB$k,
    ACTION_SGDB_TRANSLATE: ACTION_SGDB_TRANSLATE$l,
    ACTION_SHOW_LINK_QR: ACTION_SHOW_LINK_QR$l,
    ACTION_SHOW_OUTLINE: ACTION_SHOW_OUTLINE$j,
    ASSET_TYPE_CAPSULE: ASSET_TYPE_CAPSULE$l,
    ASSET_TYPE_HERO: ASSET_TYPE_HERO$l,
    ASSET_TYPE_ICON: ASSET_TYPE_ICON$l,
    ASSET_TYPE_LOGO: ASSET_TYPE_LOGO$l,
    ASSET_TYPE_WIDECAPSULE: ASSET_TYPE_WIDECAPSULE$l,
    LABEL_ANIMATED: LABEL_ANIMATED$k,
    LABEL_ASSET_CURRENT: LABEL_ASSET_CURRENT$k,
    LABEL_BEGGING_MODAL_DESC: LABEL_BEGGING_MODAL_DESC$h,
    LABEL_BEGGING_MODAL_TITLE: LABEL_BEGGING_MODAL_TITLE$i,
    LABEL_CAPSULE_GLOW: LABEL_CAPSULE_GLOW$i,
    LABEL_CAPSULE_GLOW_DESC: LABEL_CAPSULE_GLOW_DESC$h,
    LABEL_CAPSULE_GLOW_OFF: LABEL_CAPSULE_GLOW_OFF$i,
    LABEL_EPILEPSY: LABEL_EPILEPSY$k,
    LABEL_FILTER_ANIMATION_TYPE_TITLE: LABEL_FILTER_ANIMATION_TYPE_TITLE$l,
    LABEL_FILTER_DIMENSIONS: LABEL_FILTER_DIMENSIONS$l,
    LABEL_FILTER_FILE_TYPES: LABEL_FILTER_FILE_TYPES$l,
    LABEL_FILTER_GAME: LABEL_FILTER_GAME$l,
    LABEL_FILTER_MODAL_TITLE: LABEL_FILTER_MODAL_TITLE$l,
    LABEL_FILTER_STYLES: LABEL_FILTER_STYLES$l,
    LABEL_FILTER_TAGS_TITLE: LABEL_FILTER_TAGS_TITLE$l,
    LABEL_FILTER_TAG_EPILEPSY: LABEL_FILTER_TAG_EPILEPSY$k,
    LABEL_FILTER_TAG_HUMOR: LABEL_FILTER_TAG_HUMOR$k,
    LABEL_FILTER_TAG_NSFW: LABEL_FILTER_TAG_NSFW$l,
    LABEL_FILTER_TAG_UNTAGGED: LABEL_FILTER_TAG_UNTAGGED$k,
    LABEL_FILTER_TYPE_ANIMATED: LABEL_FILTER_TYPE_ANIMATED$k,
    LABEL_FILTER_TYPE_STATIC: LABEL_FILTER_TYPE_STATIC$k,
    LABEL_GAME_SEARCH_TITLE: LABEL_GAME_SEARCH_TITLE$l,
    LABEL_HUMOR: LABEL_HUMOR$k,
    LABEL_MORE_SGDB_TITLE: LABEL_MORE_SGDB_TITLE$l,
    LABEL_MOTD_ALL: LABEL_MOTD_ALL$e,
    LABEL_MOTD_THIS: LABEL_MOTD_THIS$e,
    LABEL_NOTES: LABEL_NOTES$l,
    LABEL_NSFW: LABEL_NSFW$l,
    LABEL_RESTART_STEAM_TITLE: LABEL_RESTART_STEAM_TITLE$k,
    LABEL_SETTINGS_ASSET_TABS: LABEL_SETTINGS_ASSET_TABS$j,
    LABEL_SETTINGS_DISABLE_MOTD: LABEL_SETTINGS_DISABLE_MOTD$f,
    LABEL_SETTINGS_DISABLE_MOTD_DESC: LABEL_SETTINGS_DISABLE_MOTD_DESC$e,
    LABEL_SQUARE_CAPSULES: LABEL_SQUARE_CAPSULES$i,
    LABEL_SQUARE_CAPSULES_DESC: LABEL_SQUARE_CAPSULES_DESC$h,
    LABEL_TAB_CAPSULE: LABEL_TAB_CAPSULE$l,
    LABEL_TAB_HERO: LABEL_TAB_HERO$l,
    LABEL_TAB_ICON: LABEL_TAB_ICON$l,
    LABEL_TAB_LOGO: LABEL_TAB_LOGO$l,
    LABEL_TAB_MANAGE: LABEL_TAB_MANAGE$l,
    LABEL_TAB_WIDECAPSULE: LABEL_TAB_WIDECAPSULE$l,
    LABEL_TRANSLATION_CREDIT_TITLE: LABEL_TRANSLATION_CREDIT_TITLE$l,
    LABEL_UNIFORM_RECENT: LABEL_UNIFORM_RECENT$d,
    LABEL_UNIFORM_RECENT_DESC: LABEL_UNIFORM_RECENT_DESC$d,
    LABEL_USAGE_TITLE: LABEL_USAGE_TITLE$k,
    MSG_ASSETS_FILTERED: MSG_ASSETS_FILTERED$k,
    MSG_ASSET_APPLY_ERROR: MSG_ASSET_APPLY_ERROR$j,
    MSG_ASSET_APPLY_SUCCESS: MSG_ASSET_APPLY_SUCCESS$k,
    MSG_ASSET_TAB_SETTINGS_DESC: MSG_ASSET_TAB_SETTINGS_DESC$j,
    MSG_FILTER_TAG_NSFW_ENABLED: MSG_FILTER_TAG_NSFW_ENABLED$k,
    MSG_GAME_SELECTED: MSG_GAME_SELECTED$k,
    MSG_GAME_SELECTED_AND_ASSETS_FILTERED: MSG_GAME_SELECTED_AND_ASSETS_FILTERED$k,
    MSG_RESTART_STEAM_DESC: MSG_RESTART_STEAM_DESC$j,
    MSG_USAGE_INSTRUCTIONS: MSG_USAGE_INSTRUCTIONS$k,
    TITLE_MOTD_HIDE: TITLE_MOTD_HIDE$e,
    default: de
});

var ASSET_TYPE_CAPSULE$k="Capsule";var ASSET_TYPE_WIDECAPSULE$k="Φαρδύ Capsule";var ASSET_TYPE_HERO$k="Hero";var ASSET_TYPE_LOGO$k="Logo";var ASSET_TYPE_ICON$k="Icon";var LABEL_TAB_CAPSULE$k="Capsule";var LABEL_TAB_WIDECAPSULE$k="Φαρδύ Capsule";var LABEL_TAB_HERO$k="Hero";var LABEL_TAB_LOGO$k="Logo";var LABEL_TAB_ICON$k="Icon";var LABEL_TAB_MANAGE$k="ΔΙΑΧΕΙΡΙΣΗ";var MSG_USAGE_INSTRUCTIONS$j="Επιλέξτε ένα παιχνίδι {arrow} {optionsButton} {arrow} \"{ACTION_CHANGE_ARTWORK}\"";var ACTION_CHANGE_ARTWORK$k="Αλλαγή στοιχείων τέχνης...";var ACTION_SHOW_LINK_QR$k="ΕΜΦΑΝΙΣΗ QR ΣΥΝΔΕΣΜΟΥ";var MSG_ASSET_TAB_SETTINGS_DESC$i="Αλλάξτε τη σειρά των tabs, κρύψτε όσα δε χρειάζεστε και θέστε το default tab που ανοίγει μέσω του \"{ACTION_CHANGE_ARTWORK}\"";var LABEL_USAGE_TITLE$j="ΧΑΘΗΚΕΣ; ΟΔΗΓΟΣ ΧΡΗΣΗΣ";var LABEL_SQUARE_CAPSULES$h="Τετράγωνα Capsules";var LABEL_SQUARE_CAPSULES_DESC$g="Χρήση τετράγωνων capsules αντί για κάθετων. Τα φίλτρα για τετράγωνα θα επιλέγονται αυτόματα.";var LABEL_UNIFORM_RECENT$c="Όμοιο Πρόσφατο Capsule";var LABEL_UNIFORM_RECENT_DESC$c="Κάνε το πιο πρόσφατο παιχνίδι στην αρχική οθόνη να ταιριάζει με τα υπόλοιπα capsules.";var LABEL_CAPSULE_GLOW$h="Λάμψη Capsules";var LABEL_CAPSULE_GLOW_DESC$g="Προσαρμόστε τη λάμψη των capsules στη βιβλιοθήκη.";var LABEL_CAPSULE_GLOW_OFF$h="ΚΑΘΟΛΟΥ";var LABEL_SETTINGS_ASSET_TABS$i="Ρυθμίσεις των Asset Tabs";var LABEL_SETTINGS_DISABLE_MOTD$e="Απενεργοποίηση Ανακοινώσεων";var LABEL_SETTINGS_DISABLE_MOTD_DESC$d="Οι ανακοινώσεις χρησιμοποιούνται σποραδικά για να εμφανίσουν σημαντικές πληροφορίες ή κοινωνικές εκδηλώσεις.";var LABEL_TRANSLATION_CREDIT_TITLE$k="ΕΛΛΗΝΙΚΗ ΜΕΤΑΦΡΑΣΗ";var LABEL_MORE_SGDB_TITLE$k="ΣΧΕΤΙΚΑ ΜΕ STEAMGRIDDB";var ACTION_SGDB_DISCORD$k="Βρείτε μας στο Discord";var ACTION_SGDB_GITHUB$j="Έργα Ανοικτού Κώδικα";var ACTION_SGDB_DONATE$k="Στηρίξτε μέσω Patreon";var ACTION_SGDB_TRANSLATE$k="Βοήθεια Μετάφρασης";var ACTION_SGDB_BOOP$k="Τσεκάρετε το SGDBoop";var LABEL_RESTART_STEAM_TITLE$j="Επανεκκίνηση Steam;";var ACTION_RESTART_STEAM_LATER$j="Αργότερα";var ACTION_RESTART_STEAM_NOW$j="Επανεκκίνηση τώρα";var MSG_RESTART_STEAM_DESC$i="Το Steam πρέπει να επανεκκινηθεί για να εφαρμοστούν οι αλλαγές.";var LABEL_GAME_SEARCH_TITLE$k="Αναζήτηση παιχνιδιού...";var LABEL_FILTER_MODAL_TITLE$k="Φίλτρο {assetType}";var LABEL_FILTER_GAME$k="Παιχνίδι";var LABEL_FILTER_DIMENSIONS$k="Διαστάσεις";var LABEL_FILTER_STYLES$k="Στυλ";var LABEL_FILTER_FILE_TYPES$k="Τύποι αρχείων";var LABEL_FILTER_ANIMATION_TYPE_TITLE$k="ΤΥΠΟΙ";var LABEL_FILTER_TYPE_ANIMATED$j="Κινούμενα";var LABEL_FILTER_TYPE_STATIC$j="Στατικά";var LABEL_FILTER_TAGS_TITLE$k="ΕΤΙΚΕΤΕΣ";var LABEL_FILTER_TAG_NSFW$k="Για ενήλικες";var MSG_FILTER_TAG_NSFW_ENABLED$j="Σιγουρευτείτε πως δεν βρίσκεται κάποιος πίσω σας.";var LABEL_FILTER_TAG_HUMOR$j="Χιούμορ";var LABEL_FILTER_TAG_EPILEPSY$j="Επιληψία";var LABEL_FILTER_TAG_UNTAGGED$j="Χωρίς ετικέτα";var ACTION_FILTER_RESET$k="Επαναφορά φίλτρων";var LABEL_BEGGING_MODAL_TITLE$h="Ευχαριστούμε που χρησιμοποιείτε το SteamGridDB!";var LABEL_BEGGING_MODAL_DESC$g="Σας παρακαλούμε, σκεφτείτε να κάνετε μια δωρεά ώστε να μας βοηθήσετε με τη συντήρηση και το κόστος των servers.";var ACTION_HIDE_POS_GUIDES$i="Απόκρυψη Οδηγών";var ACTION_SHOW_OUTLINE$i="Εμφάνιση οδηγών";var ACTION_ADJUST_POS_SIZE$j="Προσαρμογή μεγέθους";var ACTION_CHANGE_POS_LOGO_ANCHOR_POINT$c="Αλλαγή Σημείου Aγκύρωσης";var LABEL_ASSET_CURRENT$j="ΤΡΕΧΩΝ {assetType}";var ACTION_ASSET_CUSTOM_CLEAR$j="ΕΚΚΑΘΑΡΙΣΗ ΣΤΟΙΧΕΙΟΥ";var ACTION_ASSET_BROWSE_LOCAL$i="ΧΡΗΣΗ ΤΟΠΙΚΟΥ ΑΡΧΕΙΟΥ";var ACTION_ASSET_APPLY_TRANSPARENT$i="ΧΡΗΣΗ ΑΟΡΑΤΟΥ ΣΤΟΙΧΕΙΟΥ";var LABEL_NOTES$k="ΣΗΜΕΙΩΣΕΙΣ";var LABEL_ANIMATED$j="ΚΙΝΟΥΜΕΝΟ";var LABEL_NSFW$k="ΓΙΑ ΕΝΗΛΙΚΕΣ";var LABEL_HUMOR$j="ΧΙΟΥΜΟΡ";var LABEL_EPILEPSY$j="ΕΠΙΛΗΨΙΑ";var ACTION_OPEN_FILTER$k="ΦΙΛΤΡΟ";var ACTION_OPEN_OFFICIAL_ASSETS$j="Επίσημο {assetType}";var ACTION_ASSET_APPLY$j="ΕΦΑΡΜΟΓΗ {assetType}";var MSG_GAME_SELECTED$j="ΕΠΙΛΕΧΘΗΚΕ ΤΟ {gameName}";var MSG_ASSETS_FILTERED$j="ΚΑΠΟΙΑ ΣΤΟΙΧΕΙΑ ΜΠΟΡΕΙ ΝΑ ΕΙΝΑΙ ΚΡΥΜΜΕΝΑ ΛΟΓΩ ΦΙΛΤΡΟΥ";var MSG_GAME_SELECTED_AND_ASSETS_FILTERED$j="ΕΠΙΛΕΧΘΗΚΕ ΤΟ {gameName} ΜΕ ΦΙΛΤΡΑ";var TITLE_MOTD_HIDE$d="Θέλετε να κρύψετε τις ανακοινώσεις;";var LABEL_MOTD_THIS$d="Αυτή την ανακοίνωση";var LABEL_MOTD_ALL$d="Όλες τις ανακοινώσεις";var MSG_ASSET_APPLY_SUCCESS$j="{assetType} εφαρμόστηκε επιτυχώς!";var MSG_ASSET_APPLY_ERROR$i="Υπήρξε ένα πρόβλημα κατά την εφαρμογή του στοιχείου.";var ACTION_OPEN_DETAILS$j="ΛΕΠΤΟΜΕΡΕΙΕΣ";var el = {ASSET_TYPE_CAPSULE:ASSET_TYPE_CAPSULE$k,ASSET_TYPE_WIDECAPSULE:ASSET_TYPE_WIDECAPSULE$k,ASSET_TYPE_HERO:ASSET_TYPE_HERO$k,ASSET_TYPE_LOGO:ASSET_TYPE_LOGO$k,ASSET_TYPE_ICON:ASSET_TYPE_ICON$k,LABEL_TAB_CAPSULE:LABEL_TAB_CAPSULE$k,LABEL_TAB_WIDECAPSULE:LABEL_TAB_WIDECAPSULE$k,LABEL_TAB_HERO:LABEL_TAB_HERO$k,LABEL_TAB_LOGO:LABEL_TAB_LOGO$k,LABEL_TAB_ICON:LABEL_TAB_ICON$k,LABEL_TAB_MANAGE:LABEL_TAB_MANAGE$k,MSG_USAGE_INSTRUCTIONS:MSG_USAGE_INSTRUCTIONS$j,ACTION_CHANGE_ARTWORK:ACTION_CHANGE_ARTWORK$k,ACTION_SHOW_LINK_QR:ACTION_SHOW_LINK_QR$k,MSG_ASSET_TAB_SETTINGS_DESC:MSG_ASSET_TAB_SETTINGS_DESC$i,LABEL_USAGE_TITLE:LABEL_USAGE_TITLE$j,LABEL_SQUARE_CAPSULES:LABEL_SQUARE_CAPSULES$h,LABEL_SQUARE_CAPSULES_DESC:LABEL_SQUARE_CAPSULES_DESC$g,LABEL_UNIFORM_RECENT:LABEL_UNIFORM_RECENT$c,LABEL_UNIFORM_RECENT_DESC:LABEL_UNIFORM_RECENT_DESC$c,LABEL_CAPSULE_GLOW:LABEL_CAPSULE_GLOW$h,LABEL_CAPSULE_GLOW_DESC:LABEL_CAPSULE_GLOW_DESC$g,LABEL_CAPSULE_GLOW_OFF:LABEL_CAPSULE_GLOW_OFF$h,LABEL_SETTINGS_ASSET_TABS:LABEL_SETTINGS_ASSET_TABS$i,LABEL_SETTINGS_DISABLE_MOTD:LABEL_SETTINGS_DISABLE_MOTD$e,LABEL_SETTINGS_DISABLE_MOTD_DESC:LABEL_SETTINGS_DISABLE_MOTD_DESC$d,LABEL_TRANSLATION_CREDIT_TITLE:LABEL_TRANSLATION_CREDIT_TITLE$k,LABEL_MORE_SGDB_TITLE:LABEL_MORE_SGDB_TITLE$k,ACTION_SGDB_DISCORD:ACTION_SGDB_DISCORD$k,ACTION_SGDB_GITHUB:ACTION_SGDB_GITHUB$j,ACTION_SGDB_DONATE:ACTION_SGDB_DONATE$k,ACTION_SGDB_TRANSLATE:ACTION_SGDB_TRANSLATE$k,ACTION_SGDB_BOOP:ACTION_SGDB_BOOP$k,LABEL_RESTART_STEAM_TITLE:LABEL_RESTART_STEAM_TITLE$j,ACTION_RESTART_STEAM_LATER:ACTION_RESTART_STEAM_LATER$j,ACTION_RESTART_STEAM_NOW:ACTION_RESTART_STEAM_NOW$j,MSG_RESTART_STEAM_DESC:MSG_RESTART_STEAM_DESC$i,LABEL_GAME_SEARCH_TITLE:LABEL_GAME_SEARCH_TITLE$k,LABEL_FILTER_MODAL_TITLE:LABEL_FILTER_MODAL_TITLE$k,LABEL_FILTER_GAME:LABEL_FILTER_GAME$k,LABEL_FILTER_DIMENSIONS:LABEL_FILTER_DIMENSIONS$k,LABEL_FILTER_STYLES:LABEL_FILTER_STYLES$k,LABEL_FILTER_FILE_TYPES:LABEL_FILTER_FILE_TYPES$k,LABEL_FILTER_ANIMATION_TYPE_TITLE:LABEL_FILTER_ANIMATION_TYPE_TITLE$k,LABEL_FILTER_TYPE_ANIMATED:LABEL_FILTER_TYPE_ANIMATED$j,LABEL_FILTER_TYPE_STATIC:LABEL_FILTER_TYPE_STATIC$j,LABEL_FILTER_TAGS_TITLE:LABEL_FILTER_TAGS_TITLE$k,LABEL_FILTER_TAG_NSFW:LABEL_FILTER_TAG_NSFW$k,MSG_FILTER_TAG_NSFW_ENABLED:MSG_FILTER_TAG_NSFW_ENABLED$j,LABEL_FILTER_TAG_HUMOR:LABEL_FILTER_TAG_HUMOR$j,LABEL_FILTER_TAG_EPILEPSY:LABEL_FILTER_TAG_EPILEPSY$j,LABEL_FILTER_TAG_UNTAGGED:LABEL_FILTER_TAG_UNTAGGED$j,ACTION_FILTER_RESET:ACTION_FILTER_RESET$k,LABEL_BEGGING_MODAL_TITLE:LABEL_BEGGING_MODAL_TITLE$h,LABEL_BEGGING_MODAL_DESC:LABEL_BEGGING_MODAL_DESC$g,ACTION_HIDE_POS_GUIDES:ACTION_HIDE_POS_GUIDES$i,ACTION_SHOW_OUTLINE:ACTION_SHOW_OUTLINE$i,ACTION_ADJUST_POS_SIZE:ACTION_ADJUST_POS_SIZE$j,ACTION_CHANGE_POS_LOGO_ANCHOR_POINT:ACTION_CHANGE_POS_LOGO_ANCHOR_POINT$c,LABEL_ASSET_CURRENT:LABEL_ASSET_CURRENT$j,ACTION_ASSET_CUSTOM_CLEAR:ACTION_ASSET_CUSTOM_CLEAR$j,ACTION_ASSET_BROWSE_LOCAL:ACTION_ASSET_BROWSE_LOCAL$i,ACTION_ASSET_APPLY_TRANSPARENT:ACTION_ASSET_APPLY_TRANSPARENT$i,LABEL_NOTES:LABEL_NOTES$k,LABEL_ANIMATED:LABEL_ANIMATED$j,LABEL_NSFW:LABEL_NSFW$k,LABEL_HUMOR:LABEL_HUMOR$j,LABEL_EPILEPSY:LABEL_EPILEPSY$j,ACTION_OPEN_FILTER:ACTION_OPEN_FILTER$k,ACTION_OPEN_OFFICIAL_ASSETS:ACTION_OPEN_OFFICIAL_ASSETS$j,ACTION_ASSET_APPLY:ACTION_ASSET_APPLY$j,MSG_GAME_SELECTED:MSG_GAME_SELECTED$j,MSG_ASSETS_FILTERED:MSG_ASSETS_FILTERED$j,MSG_GAME_SELECTED_AND_ASSETS_FILTERED:MSG_GAME_SELECTED_AND_ASSETS_FILTERED$j,TITLE_MOTD_HIDE:TITLE_MOTD_HIDE$d,LABEL_MOTD_THIS:LABEL_MOTD_THIS$d,LABEL_MOTD_ALL:LABEL_MOTD_ALL$d,MSG_ASSET_APPLY_SUCCESS:MSG_ASSET_APPLY_SUCCESS$j,MSG_ASSET_APPLY_ERROR:MSG_ASSET_APPLY_ERROR$i,ACTION_OPEN_DETAILS:ACTION_OPEN_DETAILS$j};

var el$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    ACTION_ADJUST_POS_SIZE: ACTION_ADJUST_POS_SIZE$j,
    ACTION_ASSET_APPLY: ACTION_ASSET_APPLY$j,
    ACTION_ASSET_APPLY_TRANSPARENT: ACTION_ASSET_APPLY_TRANSPARENT$i,
    ACTION_ASSET_BROWSE_LOCAL: ACTION_ASSET_BROWSE_LOCAL$i,
    ACTION_ASSET_CUSTOM_CLEAR: ACTION_ASSET_CUSTOM_CLEAR$j,
    ACTION_CHANGE_ARTWORK: ACTION_CHANGE_ARTWORK$k,
    ACTION_CHANGE_POS_LOGO_ANCHOR_POINT: ACTION_CHANGE_POS_LOGO_ANCHOR_POINT$c,
    ACTION_FILTER_RESET: ACTION_FILTER_RESET$k,
    ACTION_HIDE_POS_GUIDES: ACTION_HIDE_POS_GUIDES$i,
    ACTION_OPEN_DETAILS: ACTION_OPEN_DETAILS$j,
    ACTION_OPEN_FILTER: ACTION_OPEN_FILTER$k,
    ACTION_OPEN_OFFICIAL_ASSETS: ACTION_OPEN_OFFICIAL_ASSETS$j,
    ACTION_RESTART_STEAM_LATER: ACTION_RESTART_STEAM_LATER$j,
    ACTION_RESTART_STEAM_NOW: ACTION_RESTART_STEAM_NOW$j,
    ACTION_SGDB_BOOP: ACTION_SGDB_BOOP$k,
    ACTION_SGDB_DISCORD: ACTION_SGDB_DISCORD$k,
    ACTION_SGDB_DONATE: ACTION_SGDB_DONATE$k,
    ACTION_SGDB_GITHUB: ACTION_SGDB_GITHUB$j,
    ACTION_SGDB_TRANSLATE: ACTION_SGDB_TRANSLATE$k,
    ACTION_SHOW_LINK_QR: ACTION_SHOW_LINK_QR$k,
    ACTION_SHOW_OUTLINE: ACTION_SHOW_OUTLINE$i,
    ASSET_TYPE_CAPSULE: ASSET_TYPE_CAPSULE$k,
    ASSET_TYPE_HERO: ASSET_TYPE_HERO$k,
    ASSET_TYPE_ICON: ASSET_TYPE_ICON$k,
    ASSET_TYPE_LOGO: ASSET_TYPE_LOGO$k,
    ASSET_TYPE_WIDECAPSULE: ASSET_TYPE_WIDECAPSULE$k,
    LABEL_ANIMATED: LABEL_ANIMATED$j,
    LABEL_ASSET_CURRENT: LABEL_ASSET_CURRENT$j,
    LABEL_BEGGING_MODAL_DESC: LABEL_BEGGING_MODAL_DESC$g,
    LABEL_BEGGING_MODAL_TITLE: LABEL_BEGGING_MODAL_TITLE$h,
    LABEL_CAPSULE_GLOW: LABEL_CAPSULE_GLOW$h,
    LABEL_CAPSULE_GLOW_DESC: LABEL_CAPSULE_GLOW_DESC$g,
    LABEL_CAPSULE_GLOW_OFF: LABEL_CAPSULE_GLOW_OFF$h,
    LABEL_EPILEPSY: LABEL_EPILEPSY$j,
    LABEL_FILTER_ANIMATION_TYPE_TITLE: LABEL_FILTER_ANIMATION_TYPE_TITLE$k,
    LABEL_FILTER_DIMENSIONS: LABEL_FILTER_DIMENSIONS$k,
    LABEL_FILTER_FILE_TYPES: LABEL_FILTER_FILE_TYPES$k,
    LABEL_FILTER_GAME: LABEL_FILTER_GAME$k,
    LABEL_FILTER_MODAL_TITLE: LABEL_FILTER_MODAL_TITLE$k,
    LABEL_FILTER_STYLES: LABEL_FILTER_STYLES$k,
    LABEL_FILTER_TAGS_TITLE: LABEL_FILTER_TAGS_TITLE$k,
    LABEL_FILTER_TAG_EPILEPSY: LABEL_FILTER_TAG_EPILEPSY$j,
    LABEL_FILTER_TAG_HUMOR: LABEL_FILTER_TAG_HUMOR$j,
    LABEL_FILTER_TAG_NSFW: LABEL_FILTER_TAG_NSFW$k,
    LABEL_FILTER_TAG_UNTAGGED: LABEL_FILTER_TAG_UNTAGGED$j,
    LABEL_FILTER_TYPE_ANIMATED: LABEL_FILTER_TYPE_ANIMATED$j,
    LABEL_FILTER_TYPE_STATIC: LABEL_FILTER_TYPE_STATIC$j,
    LABEL_GAME_SEARCH_TITLE: LABEL_GAME_SEARCH_TITLE$k,
    LABEL_HUMOR: LABEL_HUMOR$j,
    LABEL_MORE_SGDB_TITLE: LABEL_MORE_SGDB_TITLE$k,
    LABEL_MOTD_ALL: LABEL_MOTD_ALL$d,
    LABEL_MOTD_THIS: LABEL_MOTD_THIS$d,
    LABEL_NOTES: LABEL_NOTES$k,
    LABEL_NSFW: LABEL_NSFW$k,
    LABEL_RESTART_STEAM_TITLE: LABEL_RESTART_STEAM_TITLE$j,
    LABEL_SETTINGS_ASSET_TABS: LABEL_SETTINGS_ASSET_TABS$i,
    LABEL_SETTINGS_DISABLE_MOTD: LABEL_SETTINGS_DISABLE_MOTD$e,
    LABEL_SETTINGS_DISABLE_MOTD_DESC: LABEL_SETTINGS_DISABLE_MOTD_DESC$d,
    LABEL_SQUARE_CAPSULES: LABEL_SQUARE_CAPSULES$h,
    LABEL_SQUARE_CAPSULES_DESC: LABEL_SQUARE_CAPSULES_DESC$g,
    LABEL_TAB_CAPSULE: LABEL_TAB_CAPSULE$k,
    LABEL_TAB_HERO: LABEL_TAB_HERO$k,
    LABEL_TAB_ICON: LABEL_TAB_ICON$k,
    LABEL_TAB_LOGO: LABEL_TAB_LOGO$k,
    LABEL_TAB_MANAGE: LABEL_TAB_MANAGE$k,
    LABEL_TAB_WIDECAPSULE: LABEL_TAB_WIDECAPSULE$k,
    LABEL_TRANSLATION_CREDIT_TITLE: LABEL_TRANSLATION_CREDIT_TITLE$k,
    LABEL_UNIFORM_RECENT: LABEL_UNIFORM_RECENT$c,
    LABEL_UNIFORM_RECENT_DESC: LABEL_UNIFORM_RECENT_DESC$c,
    LABEL_USAGE_TITLE: LABEL_USAGE_TITLE$j,
    MSG_ASSETS_FILTERED: MSG_ASSETS_FILTERED$j,
    MSG_ASSET_APPLY_ERROR: MSG_ASSET_APPLY_ERROR$i,
    MSG_ASSET_APPLY_SUCCESS: MSG_ASSET_APPLY_SUCCESS$j,
    MSG_ASSET_TAB_SETTINGS_DESC: MSG_ASSET_TAB_SETTINGS_DESC$i,
    MSG_FILTER_TAG_NSFW_ENABLED: MSG_FILTER_TAG_NSFW_ENABLED$j,
    MSG_GAME_SELECTED: MSG_GAME_SELECTED$j,
    MSG_GAME_SELECTED_AND_ASSETS_FILTERED: MSG_GAME_SELECTED_AND_ASSETS_FILTERED$j,
    MSG_RESTART_STEAM_DESC: MSG_RESTART_STEAM_DESC$i,
    MSG_USAGE_INSTRUCTIONS: MSG_USAGE_INSTRUCTIONS$j,
    TITLE_MOTD_HIDE: TITLE_MOTD_HIDE$d,
    default: el
});

var ASSET_TYPE_CAPSULE$j="Cápsula";var ASSET_TYPE_WIDECAPSULE$j="Cápsula ancha";var ASSET_TYPE_HERO$j="Imagen principal";var ASSET_TYPE_LOGO$j="Logotipo";var ASSET_TYPE_ICON$j="Icono";var LABEL_TAB_CAPSULE$j="Cápsula";var LABEL_TAB_WIDECAPSULE$j="Cápsula ancha";var LABEL_TAB_HERO$j="Imagen principal";var LABEL_TAB_LOGO$j="Logo";var LABEL_TAB_ICON$j="Icono";var LABEL_TAB_MANAGE$j="Gestionar";var MSG_USAGE_INSTRUCTIONS$i="Selecciona un juego {arrow} {optionsButton} {arrow} \"{ACTION_CHANGE_ARTWORK}\"";var ACTION_CHANGE_ARTWORK$j="Cambiar arte...";var ACTION_SHOW_LINK_QR$j="Mostrar código QR del enlace";var MSG_ASSET_TAB_SETTINGS_DESC$h="Reordenar u ocultar pestañas no usadas, y establecer la pestaña por defecto que se abre al usar \"{ACTION_CHANGE_ARTWORK}\"";var LABEL_USAGE_TITLE$i="Tutorial";var LABEL_SQUARE_CAPSULES$g="Cápsulas cuadradas";var LABEL_SQUARE_CAPSULES_DESC$f="Usa cápsulas cuadradas en vez de verticales. Los filtros correspondientes serán seleccionados automáticamente.";var LABEL_CAPSULE_GLOW$g="Brillo de cápsula";var LABEL_CAPSULE_GLOW_DESC$f="Ajusta la intensidad del brillo de la cápsula en la biblioteca.";var LABEL_CAPSULE_GLOW_OFF$g="Ninguno";var LABEL_SETTINGS_ASSET_TABS$h="Ajustes de pestaña de arte";var LABEL_TRANSLATION_CREDIT_TITLE$j="Traducción al Castellano";var LABEL_MORE_SGDB_TITLE$j="Más cosas de SteamGridDB";var ACTION_SGDB_DISCORD$j="Únete al Discord";var ACTION_SGDB_GITHUB$i="Proyectos de código abierto";var ACTION_SGDB_DONATE$j="Apóyanos en Patreon";var ACTION_SGDB_TRANSLATE$j="Ayuda a traducir";var ACTION_SGDB_BOOP$j="Mira SGDBoop";var LABEL_RESTART_STEAM_TITLE$i="¿Reiniciar Steam?";var ACTION_RESTART_STEAM_LATER$i="Reiniciar más tarde";var ACTION_RESTART_STEAM_NOW$i="Reiniciar ahora";var MSG_RESTART_STEAM_DESC$h="Steam necesita reiniciarse para que los cambios surtan efecto.";var LABEL_GAME_SEARCH_TITLE$j="Busca un juego...";var LABEL_FILTER_MODAL_TITLE$j="Filtro de {assetType}";var LABEL_FILTER_GAME$j="Juego";var LABEL_FILTER_DIMENSIONS$j="Dimensiones";var LABEL_FILTER_STYLES$j="Estilos";var LABEL_FILTER_FILE_TYPES$j="Tipos de archivo";var LABEL_FILTER_ANIMATION_TYPE_TITLE$j="Tipos";var LABEL_FILTER_TYPE_ANIMATED$i="Animada";var LABEL_FILTER_TYPE_STATIC$i="Estática";var LABEL_FILTER_TAGS_TITLE$j="Etiquetas";var LABEL_FILTER_TAG_NSFW$j="Contenido adulto";var MSG_FILTER_TAG_NSFW_ENABLED$i="Quizás quieras comprobar que no haya nadie detrás de ti.";var LABEL_FILTER_TAG_HUMOR$i="Humor";var LABEL_FILTER_TAG_EPILEPSY$i="Epilepsia";var LABEL_FILTER_TAG_UNTAGGED$i="Sin etiquetar";var ACTION_FILTER_RESET$j="Restablecer filtros";var LABEL_BEGGING_MODAL_TITLE$g="¡Gracias por usar SteamGridDB!";var LABEL_BEGGING_MODAL_DESC$f="¡Por favor considera donar para ayudar con el mantenimiento y los costos del servidor!";var ACTION_HIDE_POS_GUIDES$h="Ocultar guías";var ACTION_SHOW_OUTLINE$h="Mostrar guías";var ACTION_ADJUST_POS_SIZE$i="Ajustar el tamaño";var LABEL_ASSET_CURRENT$i="{assetType} actual";var ACTION_ASSET_CUSTOM_CLEAR$i="Eliminar arte personalizado";var ACTION_ASSET_BROWSE_LOCAL$h="Buscar archivos locales";var ACTION_ASSET_APPLY_TRANSPARENT$h="Usar imagen invisible";var LABEL_NOTES$j="Anotación";var LABEL_ANIMATED$i="Animada";var LABEL_NSFW$j="Contenido adulto";var LABEL_HUMOR$i="Humor";var LABEL_EPILEPSY$i="Epilepsia";var ACTION_OPEN_FILTER$j="Filtros";var ACTION_OPEN_OFFICIAL_ASSETS$i="{assetType} oficial";var ACTION_ASSET_APPLY$i="Usar {assetType}";var MSG_GAME_SELECTED$i="{gameName} seleccionado";var MSG_ASSETS_FILTERED$i="Algunas imágenes podrían no mostrarse debido al filtro";var MSG_GAME_SELECTED_AND_ASSETS_FILTERED$i="{gameName} seleccionado con filtro";var MSG_ASSET_APPLY_SUCCESS$i="¡La imagen ha sido aplicada con éxito!";var MSG_ASSET_APPLY_ERROR$h="Hubo un problema al aplicar esta imagen.";var ACTION_OPEN_DETAILS$i="Detalles";var es = {ASSET_TYPE_CAPSULE:ASSET_TYPE_CAPSULE$j,ASSET_TYPE_WIDECAPSULE:ASSET_TYPE_WIDECAPSULE$j,ASSET_TYPE_HERO:ASSET_TYPE_HERO$j,ASSET_TYPE_LOGO:ASSET_TYPE_LOGO$j,ASSET_TYPE_ICON:ASSET_TYPE_ICON$j,LABEL_TAB_CAPSULE:LABEL_TAB_CAPSULE$j,LABEL_TAB_WIDECAPSULE:LABEL_TAB_WIDECAPSULE$j,LABEL_TAB_HERO:LABEL_TAB_HERO$j,LABEL_TAB_LOGO:LABEL_TAB_LOGO$j,LABEL_TAB_ICON:LABEL_TAB_ICON$j,LABEL_TAB_MANAGE:LABEL_TAB_MANAGE$j,MSG_USAGE_INSTRUCTIONS:MSG_USAGE_INSTRUCTIONS$i,ACTION_CHANGE_ARTWORK:ACTION_CHANGE_ARTWORK$j,ACTION_SHOW_LINK_QR:ACTION_SHOW_LINK_QR$j,MSG_ASSET_TAB_SETTINGS_DESC:MSG_ASSET_TAB_SETTINGS_DESC$h,LABEL_USAGE_TITLE:LABEL_USAGE_TITLE$i,LABEL_SQUARE_CAPSULES:LABEL_SQUARE_CAPSULES$g,LABEL_SQUARE_CAPSULES_DESC:LABEL_SQUARE_CAPSULES_DESC$f,LABEL_CAPSULE_GLOW:LABEL_CAPSULE_GLOW$g,LABEL_CAPSULE_GLOW_DESC:LABEL_CAPSULE_GLOW_DESC$f,LABEL_CAPSULE_GLOW_OFF:LABEL_CAPSULE_GLOW_OFF$g,LABEL_SETTINGS_ASSET_TABS:LABEL_SETTINGS_ASSET_TABS$h,LABEL_TRANSLATION_CREDIT_TITLE:LABEL_TRANSLATION_CREDIT_TITLE$j,LABEL_MORE_SGDB_TITLE:LABEL_MORE_SGDB_TITLE$j,ACTION_SGDB_DISCORD:ACTION_SGDB_DISCORD$j,ACTION_SGDB_GITHUB:ACTION_SGDB_GITHUB$i,ACTION_SGDB_DONATE:ACTION_SGDB_DONATE$j,ACTION_SGDB_TRANSLATE:ACTION_SGDB_TRANSLATE$j,ACTION_SGDB_BOOP:ACTION_SGDB_BOOP$j,LABEL_RESTART_STEAM_TITLE:LABEL_RESTART_STEAM_TITLE$i,ACTION_RESTART_STEAM_LATER:ACTION_RESTART_STEAM_LATER$i,ACTION_RESTART_STEAM_NOW:ACTION_RESTART_STEAM_NOW$i,MSG_RESTART_STEAM_DESC:MSG_RESTART_STEAM_DESC$h,LABEL_GAME_SEARCH_TITLE:LABEL_GAME_SEARCH_TITLE$j,LABEL_FILTER_MODAL_TITLE:LABEL_FILTER_MODAL_TITLE$j,LABEL_FILTER_GAME:LABEL_FILTER_GAME$j,LABEL_FILTER_DIMENSIONS:LABEL_FILTER_DIMENSIONS$j,LABEL_FILTER_STYLES:LABEL_FILTER_STYLES$j,LABEL_FILTER_FILE_TYPES:LABEL_FILTER_FILE_TYPES$j,LABEL_FILTER_ANIMATION_TYPE_TITLE:LABEL_FILTER_ANIMATION_TYPE_TITLE$j,LABEL_FILTER_TYPE_ANIMATED:LABEL_FILTER_TYPE_ANIMATED$i,LABEL_FILTER_TYPE_STATIC:LABEL_FILTER_TYPE_STATIC$i,LABEL_FILTER_TAGS_TITLE:LABEL_FILTER_TAGS_TITLE$j,LABEL_FILTER_TAG_NSFW:LABEL_FILTER_TAG_NSFW$j,MSG_FILTER_TAG_NSFW_ENABLED:MSG_FILTER_TAG_NSFW_ENABLED$i,LABEL_FILTER_TAG_HUMOR:LABEL_FILTER_TAG_HUMOR$i,LABEL_FILTER_TAG_EPILEPSY:LABEL_FILTER_TAG_EPILEPSY$i,LABEL_FILTER_TAG_UNTAGGED:LABEL_FILTER_TAG_UNTAGGED$i,ACTION_FILTER_RESET:ACTION_FILTER_RESET$j,LABEL_BEGGING_MODAL_TITLE:LABEL_BEGGING_MODAL_TITLE$g,LABEL_BEGGING_MODAL_DESC:LABEL_BEGGING_MODAL_DESC$f,ACTION_HIDE_POS_GUIDES:ACTION_HIDE_POS_GUIDES$h,ACTION_SHOW_OUTLINE:ACTION_SHOW_OUTLINE$h,ACTION_ADJUST_POS_SIZE:ACTION_ADJUST_POS_SIZE$i,LABEL_ASSET_CURRENT:LABEL_ASSET_CURRENT$i,ACTION_ASSET_CUSTOM_CLEAR:ACTION_ASSET_CUSTOM_CLEAR$i,ACTION_ASSET_BROWSE_LOCAL:ACTION_ASSET_BROWSE_LOCAL$h,ACTION_ASSET_APPLY_TRANSPARENT:ACTION_ASSET_APPLY_TRANSPARENT$h,LABEL_NOTES:LABEL_NOTES$j,LABEL_ANIMATED:LABEL_ANIMATED$i,LABEL_NSFW:LABEL_NSFW$j,LABEL_HUMOR:LABEL_HUMOR$i,LABEL_EPILEPSY:LABEL_EPILEPSY$i,ACTION_OPEN_FILTER:ACTION_OPEN_FILTER$j,ACTION_OPEN_OFFICIAL_ASSETS:ACTION_OPEN_OFFICIAL_ASSETS$i,ACTION_ASSET_APPLY:ACTION_ASSET_APPLY$i,MSG_GAME_SELECTED:MSG_GAME_SELECTED$i,MSG_ASSETS_FILTERED:MSG_ASSETS_FILTERED$i,MSG_GAME_SELECTED_AND_ASSETS_FILTERED:MSG_GAME_SELECTED_AND_ASSETS_FILTERED$i,MSG_ASSET_APPLY_SUCCESS:MSG_ASSET_APPLY_SUCCESS$i,MSG_ASSET_APPLY_ERROR:MSG_ASSET_APPLY_ERROR$h,ACTION_OPEN_DETAILS:ACTION_OPEN_DETAILS$i};

var es$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    ACTION_ADJUST_POS_SIZE: ACTION_ADJUST_POS_SIZE$i,
    ACTION_ASSET_APPLY: ACTION_ASSET_APPLY$i,
    ACTION_ASSET_APPLY_TRANSPARENT: ACTION_ASSET_APPLY_TRANSPARENT$h,
    ACTION_ASSET_BROWSE_LOCAL: ACTION_ASSET_BROWSE_LOCAL$h,
    ACTION_ASSET_CUSTOM_CLEAR: ACTION_ASSET_CUSTOM_CLEAR$i,
    ACTION_CHANGE_ARTWORK: ACTION_CHANGE_ARTWORK$j,
    ACTION_FILTER_RESET: ACTION_FILTER_RESET$j,
    ACTION_HIDE_POS_GUIDES: ACTION_HIDE_POS_GUIDES$h,
    ACTION_OPEN_DETAILS: ACTION_OPEN_DETAILS$i,
    ACTION_OPEN_FILTER: ACTION_OPEN_FILTER$j,
    ACTION_OPEN_OFFICIAL_ASSETS: ACTION_OPEN_OFFICIAL_ASSETS$i,
    ACTION_RESTART_STEAM_LATER: ACTION_RESTART_STEAM_LATER$i,
    ACTION_RESTART_STEAM_NOW: ACTION_RESTART_STEAM_NOW$i,
    ACTION_SGDB_BOOP: ACTION_SGDB_BOOP$j,
    ACTION_SGDB_DISCORD: ACTION_SGDB_DISCORD$j,
    ACTION_SGDB_DONATE: ACTION_SGDB_DONATE$j,
    ACTION_SGDB_GITHUB: ACTION_SGDB_GITHUB$i,
    ACTION_SGDB_TRANSLATE: ACTION_SGDB_TRANSLATE$j,
    ACTION_SHOW_LINK_QR: ACTION_SHOW_LINK_QR$j,
    ACTION_SHOW_OUTLINE: ACTION_SHOW_OUTLINE$h,
    ASSET_TYPE_CAPSULE: ASSET_TYPE_CAPSULE$j,
    ASSET_TYPE_HERO: ASSET_TYPE_HERO$j,
    ASSET_TYPE_ICON: ASSET_TYPE_ICON$j,
    ASSET_TYPE_LOGO: ASSET_TYPE_LOGO$j,
    ASSET_TYPE_WIDECAPSULE: ASSET_TYPE_WIDECAPSULE$j,
    LABEL_ANIMATED: LABEL_ANIMATED$i,
    LABEL_ASSET_CURRENT: LABEL_ASSET_CURRENT$i,
    LABEL_BEGGING_MODAL_DESC: LABEL_BEGGING_MODAL_DESC$f,
    LABEL_BEGGING_MODAL_TITLE: LABEL_BEGGING_MODAL_TITLE$g,
    LABEL_CAPSULE_GLOW: LABEL_CAPSULE_GLOW$g,
    LABEL_CAPSULE_GLOW_DESC: LABEL_CAPSULE_GLOW_DESC$f,
    LABEL_CAPSULE_GLOW_OFF: LABEL_CAPSULE_GLOW_OFF$g,
    LABEL_EPILEPSY: LABEL_EPILEPSY$i,
    LABEL_FILTER_ANIMATION_TYPE_TITLE: LABEL_FILTER_ANIMATION_TYPE_TITLE$j,
    LABEL_FILTER_DIMENSIONS: LABEL_FILTER_DIMENSIONS$j,
    LABEL_FILTER_FILE_TYPES: LABEL_FILTER_FILE_TYPES$j,
    LABEL_FILTER_GAME: LABEL_FILTER_GAME$j,
    LABEL_FILTER_MODAL_TITLE: LABEL_FILTER_MODAL_TITLE$j,
    LABEL_FILTER_STYLES: LABEL_FILTER_STYLES$j,
    LABEL_FILTER_TAGS_TITLE: LABEL_FILTER_TAGS_TITLE$j,
    LABEL_FILTER_TAG_EPILEPSY: LABEL_FILTER_TAG_EPILEPSY$i,
    LABEL_FILTER_TAG_HUMOR: LABEL_FILTER_TAG_HUMOR$i,
    LABEL_FILTER_TAG_NSFW: LABEL_FILTER_TAG_NSFW$j,
    LABEL_FILTER_TAG_UNTAGGED: LABEL_FILTER_TAG_UNTAGGED$i,
    LABEL_FILTER_TYPE_ANIMATED: LABEL_FILTER_TYPE_ANIMATED$i,
    LABEL_FILTER_TYPE_STATIC: LABEL_FILTER_TYPE_STATIC$i,
    LABEL_GAME_SEARCH_TITLE: LABEL_GAME_SEARCH_TITLE$j,
    LABEL_HUMOR: LABEL_HUMOR$i,
    LABEL_MORE_SGDB_TITLE: LABEL_MORE_SGDB_TITLE$j,
    LABEL_NOTES: LABEL_NOTES$j,
    LABEL_NSFW: LABEL_NSFW$j,
    LABEL_RESTART_STEAM_TITLE: LABEL_RESTART_STEAM_TITLE$i,
    LABEL_SETTINGS_ASSET_TABS: LABEL_SETTINGS_ASSET_TABS$h,
    LABEL_SQUARE_CAPSULES: LABEL_SQUARE_CAPSULES$g,
    LABEL_SQUARE_CAPSULES_DESC: LABEL_SQUARE_CAPSULES_DESC$f,
    LABEL_TAB_CAPSULE: LABEL_TAB_CAPSULE$j,
    LABEL_TAB_HERO: LABEL_TAB_HERO$j,
    LABEL_TAB_ICON: LABEL_TAB_ICON$j,
    LABEL_TAB_LOGO: LABEL_TAB_LOGO$j,
    LABEL_TAB_MANAGE: LABEL_TAB_MANAGE$j,
    LABEL_TAB_WIDECAPSULE: LABEL_TAB_WIDECAPSULE$j,
    LABEL_TRANSLATION_CREDIT_TITLE: LABEL_TRANSLATION_CREDIT_TITLE$j,
    LABEL_USAGE_TITLE: LABEL_USAGE_TITLE$i,
    MSG_ASSETS_FILTERED: MSG_ASSETS_FILTERED$i,
    MSG_ASSET_APPLY_ERROR: MSG_ASSET_APPLY_ERROR$h,
    MSG_ASSET_APPLY_SUCCESS: MSG_ASSET_APPLY_SUCCESS$i,
    MSG_ASSET_TAB_SETTINGS_DESC: MSG_ASSET_TAB_SETTINGS_DESC$h,
    MSG_FILTER_TAG_NSFW_ENABLED: MSG_FILTER_TAG_NSFW_ENABLED$i,
    MSG_GAME_SELECTED: MSG_GAME_SELECTED$i,
    MSG_GAME_SELECTED_AND_ASSETS_FILTERED: MSG_GAME_SELECTED_AND_ASSETS_FILTERED$i,
    MSG_RESTART_STEAM_DESC: MSG_RESTART_STEAM_DESC$h,
    MSG_USAGE_INSTRUCTIONS: MSG_USAGE_INSTRUCTIONS$i,
    default: es
});

var ASSET_TYPE_CAPSULE$i="Cápsula";var ASSET_TYPE_WIDECAPSULE$i="Cápsula ancha";var ASSET_TYPE_HERO$i="Arte principal";var ASSET_TYPE_LOGO$i="Logotipo";var ASSET_TYPE_ICON$i="Ícono";var LABEL_TAB_CAPSULE$i="Cápsula";var LABEL_TAB_WIDECAPSULE$i="Cápsula ancha";var LABEL_TAB_HERO$i="Imagen principal";var LABEL_TAB_LOGO$i="Logotipo";var LABEL_TAB_ICON$i="Ícono";var LABEL_TAB_MANAGE$i="Gestionar";var MSG_USAGE_INSTRUCTIONS$h="Selcciona un juego {arrow} {optionsButton} {arrow} \"{ACTION_CHANGE_ARTWORK}\"";var ACTION_CHANGE_ARTWORK$i="Cambiar arte...";var ACTION_SHOW_LINK_QR$i="Mostrar código QR del enlace";var MSG_ASSET_TAB_SETTINGS_DESC$g="Reordena o oculta pestañas sin uso, y establece una pestaña por defecto que se abre al usar \"{ACTION_CHANGE_ARTWORK}\"";var LABEL_USAGE_TITLE$h="Tutorial";var LABEL_SQUARE_CAPSULES$f="Cápsula cuadrada";var LABEL_SQUARE_CAPSULES_DESC$e="Usa cápsulas cuadradas en vez de verticales. Los filtros correspondientes serán seleccionados automáticamente.";var LABEL_UNIFORM_RECENT$b="Coincidencias De Cápsulas Recientes";var LABEL_UNIFORM_RECENT_DESC$b="Haz que el juego jugado más recientemente en la pantalla de inicio concuerde con el resto de las cápsulas.";var LABEL_CAPSULE_GLOW$f="Brillo de la cápsula";var LABEL_CAPSULE_GLOW_DESC$e="Ajusta la intensidad del brillo de las cápsulas en la biblioteca";var LABEL_CAPSULE_GLOW_OFF$f="Nada";var LABEL_SETTINGS_ASSET_TABS$g="Ajustes de pestaña al buscar imágenes";var LABEL_SETTINGS_DISABLE_MOTD$d="Deshabilitar Anuncios";var LABEL_SETTINGS_DISABLE_MOTD_DESC$c="Los anuncios se utilizan moderadamente para mostrar información importante o para eventos en la comunidad.";var LABEL_TRANSLATION_CREDIT_TITLE$i="Traducción al Español";var LABEL_MORE_SGDB_TITLE$i="Más cosas de SteamGridDB";var ACTION_SGDB_DISCORD$i="Únete al Discord";var ACTION_SGDB_GITHUB$h="Proyectos de código abierto";var ACTION_SGDB_DONATE$i="Apoyanos en Patreon";var ACTION_SGDB_TRANSLATE$i="Ayuda a traducir";var ACTION_SGDB_BOOP$i="Chequea SteamGridDB";var LABEL_RESTART_STEAM_TITLE$h="¿Quieres reiniciar Steam?";var ACTION_RESTART_STEAM_LATER$h="Reiniciar más tarde";var ACTION_RESTART_STEAM_NOW$h="Reiniciar ahora";var MSG_RESTART_STEAM_DESC$g="Steam necesita reiniciarse para que los cambios surtan efecto.";var LABEL_GAME_SEARCH_TITLE$i="Busca un juego...";var LABEL_FILTER_MODAL_TITLE$i="Filtro de {assetType}";var LABEL_FILTER_GAME$i="Juego";var LABEL_FILTER_DIMENSIONS$i="Dimensiones";var LABEL_FILTER_STYLES$i="Estilos";var LABEL_FILTER_FILE_TYPES$i="Tipos de archivo";var LABEL_FILTER_ANIMATION_TYPE_TITLE$i="Tipos";var LABEL_FILTER_TYPE_ANIMATED$h="Animada";var LABEL_FILTER_TYPE_STATIC$h="Estática";var LABEL_FILTER_TAGS_TITLE$i="Etiquetas";var LABEL_FILTER_TAG_NSFW$i="Contenido para adultos";var MSG_FILTER_TAG_NSFW_ENABLED$h="Revisa que no haya nadie detrás de ti.";var LABEL_FILTER_TAG_HUMOR$h="Humor";var LABEL_FILTER_TAG_EPILEPSY$h="Epilepsia";var LABEL_FILTER_TAG_UNTAGGED$h="Sin etiquetar";var ACTION_FILTER_RESET$i="Restablecer filtros";var LABEL_BEGGING_MODAL_TITLE$f="¡Gracias por usar SteamGridDB!";var LABEL_BEGGING_MODAL_DESC$e="¡Por favor considera donar para ayudar con el mantenimiento y los costos del servidor!";var ACTION_HIDE_POS_GUIDES$g="Ocultar guías";var ACTION_SHOW_OUTLINE$g="Mostrar guías";var ACTION_ADJUST_POS_SIZE$h="Ajustar tamaño";var ACTION_CHANGE_POS_LOGO_ANCHOR_POINT$b="Cambiar El Punto De Anclaje";var LABEL_ASSET_CURRENT$h="{assetType} actual";var ACTION_ASSET_CUSTOM_CLEAR$h="Eliminar arte personalizado";var ACTION_ASSET_BROWSE_LOCAL$g="Buscar archivos locales";var ACTION_ASSET_APPLY_TRANSPARENT$g="Usar imagen invisible";var LABEL_NOTES$i="Anotación";var LABEL_ANIMATED$h="Animada";var LABEL_NSFW$i="Contenido para adultos";var LABEL_HUMOR$h="Humor";var LABEL_EPILEPSY$h="Epilepsia";var ACTION_OPEN_FILTER$i="Filtros";var ACTION_OPEN_OFFICIAL_ASSETS$h="{assetType} oficial";var ACTION_ASSET_APPLY$h="Usar {assetType}";var MSG_GAME_SELECTED$h="{gameName} seleccionado";var MSG_ASSETS_FILTERED$h="Algunas imágenes podrían estar ocultas debido al filtro";var MSG_GAME_SELECTED_AND_ASSETS_FILTERED$h="{gameName} seleccionado con filtro";var TITLE_MOTD_HIDE$c="¿Ocultar Anuncios?";var LABEL_MOTD_THIS$c="Este Anuncio";var LABEL_MOTD_ALL$c="Todos Los Anuncios";var MSG_ASSET_APPLY_SUCCESS$h="¡La imagen ha sido aplicada con éxito!";var MSG_ASSET_APPLY_ERROR$g="Hubo un problema al aplicar esta imagen.";var ACTION_OPEN_DETAILS$h="Detalles";var es419 = {ASSET_TYPE_CAPSULE:ASSET_TYPE_CAPSULE$i,ASSET_TYPE_WIDECAPSULE:ASSET_TYPE_WIDECAPSULE$i,ASSET_TYPE_HERO:ASSET_TYPE_HERO$i,ASSET_TYPE_LOGO:ASSET_TYPE_LOGO$i,ASSET_TYPE_ICON:ASSET_TYPE_ICON$i,LABEL_TAB_CAPSULE:LABEL_TAB_CAPSULE$i,LABEL_TAB_WIDECAPSULE:LABEL_TAB_WIDECAPSULE$i,LABEL_TAB_HERO:LABEL_TAB_HERO$i,LABEL_TAB_LOGO:LABEL_TAB_LOGO$i,LABEL_TAB_ICON:LABEL_TAB_ICON$i,LABEL_TAB_MANAGE:LABEL_TAB_MANAGE$i,MSG_USAGE_INSTRUCTIONS:MSG_USAGE_INSTRUCTIONS$h,ACTION_CHANGE_ARTWORK:ACTION_CHANGE_ARTWORK$i,ACTION_SHOW_LINK_QR:ACTION_SHOW_LINK_QR$i,MSG_ASSET_TAB_SETTINGS_DESC:MSG_ASSET_TAB_SETTINGS_DESC$g,LABEL_USAGE_TITLE:LABEL_USAGE_TITLE$h,LABEL_SQUARE_CAPSULES:LABEL_SQUARE_CAPSULES$f,LABEL_SQUARE_CAPSULES_DESC:LABEL_SQUARE_CAPSULES_DESC$e,LABEL_UNIFORM_RECENT:LABEL_UNIFORM_RECENT$b,LABEL_UNIFORM_RECENT_DESC:LABEL_UNIFORM_RECENT_DESC$b,LABEL_CAPSULE_GLOW:LABEL_CAPSULE_GLOW$f,LABEL_CAPSULE_GLOW_DESC:LABEL_CAPSULE_GLOW_DESC$e,LABEL_CAPSULE_GLOW_OFF:LABEL_CAPSULE_GLOW_OFF$f,LABEL_SETTINGS_ASSET_TABS:LABEL_SETTINGS_ASSET_TABS$g,LABEL_SETTINGS_DISABLE_MOTD:LABEL_SETTINGS_DISABLE_MOTD$d,LABEL_SETTINGS_DISABLE_MOTD_DESC:LABEL_SETTINGS_DISABLE_MOTD_DESC$c,LABEL_TRANSLATION_CREDIT_TITLE:LABEL_TRANSLATION_CREDIT_TITLE$i,LABEL_MORE_SGDB_TITLE:LABEL_MORE_SGDB_TITLE$i,ACTION_SGDB_DISCORD:ACTION_SGDB_DISCORD$i,ACTION_SGDB_GITHUB:ACTION_SGDB_GITHUB$h,ACTION_SGDB_DONATE:ACTION_SGDB_DONATE$i,ACTION_SGDB_TRANSLATE:ACTION_SGDB_TRANSLATE$i,ACTION_SGDB_BOOP:ACTION_SGDB_BOOP$i,LABEL_RESTART_STEAM_TITLE:LABEL_RESTART_STEAM_TITLE$h,ACTION_RESTART_STEAM_LATER:ACTION_RESTART_STEAM_LATER$h,ACTION_RESTART_STEAM_NOW:ACTION_RESTART_STEAM_NOW$h,MSG_RESTART_STEAM_DESC:MSG_RESTART_STEAM_DESC$g,LABEL_GAME_SEARCH_TITLE:LABEL_GAME_SEARCH_TITLE$i,LABEL_FILTER_MODAL_TITLE:LABEL_FILTER_MODAL_TITLE$i,LABEL_FILTER_GAME:LABEL_FILTER_GAME$i,LABEL_FILTER_DIMENSIONS:LABEL_FILTER_DIMENSIONS$i,LABEL_FILTER_STYLES:LABEL_FILTER_STYLES$i,LABEL_FILTER_FILE_TYPES:LABEL_FILTER_FILE_TYPES$i,LABEL_FILTER_ANIMATION_TYPE_TITLE:LABEL_FILTER_ANIMATION_TYPE_TITLE$i,LABEL_FILTER_TYPE_ANIMATED:LABEL_FILTER_TYPE_ANIMATED$h,LABEL_FILTER_TYPE_STATIC:LABEL_FILTER_TYPE_STATIC$h,LABEL_FILTER_TAGS_TITLE:LABEL_FILTER_TAGS_TITLE$i,LABEL_FILTER_TAG_NSFW:LABEL_FILTER_TAG_NSFW$i,MSG_FILTER_TAG_NSFW_ENABLED:MSG_FILTER_TAG_NSFW_ENABLED$h,LABEL_FILTER_TAG_HUMOR:LABEL_FILTER_TAG_HUMOR$h,LABEL_FILTER_TAG_EPILEPSY:LABEL_FILTER_TAG_EPILEPSY$h,LABEL_FILTER_TAG_UNTAGGED:LABEL_FILTER_TAG_UNTAGGED$h,ACTION_FILTER_RESET:ACTION_FILTER_RESET$i,LABEL_BEGGING_MODAL_TITLE:LABEL_BEGGING_MODAL_TITLE$f,LABEL_BEGGING_MODAL_DESC:LABEL_BEGGING_MODAL_DESC$e,ACTION_HIDE_POS_GUIDES:ACTION_HIDE_POS_GUIDES$g,ACTION_SHOW_OUTLINE:ACTION_SHOW_OUTLINE$g,ACTION_ADJUST_POS_SIZE:ACTION_ADJUST_POS_SIZE$h,ACTION_CHANGE_POS_LOGO_ANCHOR_POINT:ACTION_CHANGE_POS_LOGO_ANCHOR_POINT$b,LABEL_ASSET_CURRENT:LABEL_ASSET_CURRENT$h,ACTION_ASSET_CUSTOM_CLEAR:ACTION_ASSET_CUSTOM_CLEAR$h,ACTION_ASSET_BROWSE_LOCAL:ACTION_ASSET_BROWSE_LOCAL$g,ACTION_ASSET_APPLY_TRANSPARENT:ACTION_ASSET_APPLY_TRANSPARENT$g,LABEL_NOTES:LABEL_NOTES$i,LABEL_ANIMATED:LABEL_ANIMATED$h,LABEL_NSFW:LABEL_NSFW$i,LABEL_HUMOR:LABEL_HUMOR$h,LABEL_EPILEPSY:LABEL_EPILEPSY$h,ACTION_OPEN_FILTER:ACTION_OPEN_FILTER$i,ACTION_OPEN_OFFICIAL_ASSETS:ACTION_OPEN_OFFICIAL_ASSETS$h,ACTION_ASSET_APPLY:ACTION_ASSET_APPLY$h,MSG_GAME_SELECTED:MSG_GAME_SELECTED$h,MSG_ASSETS_FILTERED:MSG_ASSETS_FILTERED$h,MSG_GAME_SELECTED_AND_ASSETS_FILTERED:MSG_GAME_SELECTED_AND_ASSETS_FILTERED$h,TITLE_MOTD_HIDE:TITLE_MOTD_HIDE$c,LABEL_MOTD_THIS:LABEL_MOTD_THIS$c,LABEL_MOTD_ALL:LABEL_MOTD_ALL$c,MSG_ASSET_APPLY_SUCCESS:MSG_ASSET_APPLY_SUCCESS$h,MSG_ASSET_APPLY_ERROR:MSG_ASSET_APPLY_ERROR$g,ACTION_OPEN_DETAILS:ACTION_OPEN_DETAILS$h};

var es419$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    ACTION_ADJUST_POS_SIZE: ACTION_ADJUST_POS_SIZE$h,
    ACTION_ASSET_APPLY: ACTION_ASSET_APPLY$h,
    ACTION_ASSET_APPLY_TRANSPARENT: ACTION_ASSET_APPLY_TRANSPARENT$g,
    ACTION_ASSET_BROWSE_LOCAL: ACTION_ASSET_BROWSE_LOCAL$g,
    ACTION_ASSET_CUSTOM_CLEAR: ACTION_ASSET_CUSTOM_CLEAR$h,
    ACTION_CHANGE_ARTWORK: ACTION_CHANGE_ARTWORK$i,
    ACTION_CHANGE_POS_LOGO_ANCHOR_POINT: ACTION_CHANGE_POS_LOGO_ANCHOR_POINT$b,
    ACTION_FILTER_RESET: ACTION_FILTER_RESET$i,
    ACTION_HIDE_POS_GUIDES: ACTION_HIDE_POS_GUIDES$g,
    ACTION_OPEN_DETAILS: ACTION_OPEN_DETAILS$h,
    ACTION_OPEN_FILTER: ACTION_OPEN_FILTER$i,
    ACTION_OPEN_OFFICIAL_ASSETS: ACTION_OPEN_OFFICIAL_ASSETS$h,
    ACTION_RESTART_STEAM_LATER: ACTION_RESTART_STEAM_LATER$h,
    ACTION_RESTART_STEAM_NOW: ACTION_RESTART_STEAM_NOW$h,
    ACTION_SGDB_BOOP: ACTION_SGDB_BOOP$i,
    ACTION_SGDB_DISCORD: ACTION_SGDB_DISCORD$i,
    ACTION_SGDB_DONATE: ACTION_SGDB_DONATE$i,
    ACTION_SGDB_GITHUB: ACTION_SGDB_GITHUB$h,
    ACTION_SGDB_TRANSLATE: ACTION_SGDB_TRANSLATE$i,
    ACTION_SHOW_LINK_QR: ACTION_SHOW_LINK_QR$i,
    ACTION_SHOW_OUTLINE: ACTION_SHOW_OUTLINE$g,
    ASSET_TYPE_CAPSULE: ASSET_TYPE_CAPSULE$i,
    ASSET_TYPE_HERO: ASSET_TYPE_HERO$i,
    ASSET_TYPE_ICON: ASSET_TYPE_ICON$i,
    ASSET_TYPE_LOGO: ASSET_TYPE_LOGO$i,
    ASSET_TYPE_WIDECAPSULE: ASSET_TYPE_WIDECAPSULE$i,
    LABEL_ANIMATED: LABEL_ANIMATED$h,
    LABEL_ASSET_CURRENT: LABEL_ASSET_CURRENT$h,
    LABEL_BEGGING_MODAL_DESC: LABEL_BEGGING_MODAL_DESC$e,
    LABEL_BEGGING_MODAL_TITLE: LABEL_BEGGING_MODAL_TITLE$f,
    LABEL_CAPSULE_GLOW: LABEL_CAPSULE_GLOW$f,
    LABEL_CAPSULE_GLOW_DESC: LABEL_CAPSULE_GLOW_DESC$e,
    LABEL_CAPSULE_GLOW_OFF: LABEL_CAPSULE_GLOW_OFF$f,
    LABEL_EPILEPSY: LABEL_EPILEPSY$h,
    LABEL_FILTER_ANIMATION_TYPE_TITLE: LABEL_FILTER_ANIMATION_TYPE_TITLE$i,
    LABEL_FILTER_DIMENSIONS: LABEL_FILTER_DIMENSIONS$i,
    LABEL_FILTER_FILE_TYPES: LABEL_FILTER_FILE_TYPES$i,
    LABEL_FILTER_GAME: LABEL_FILTER_GAME$i,
    LABEL_FILTER_MODAL_TITLE: LABEL_FILTER_MODAL_TITLE$i,
    LABEL_FILTER_STYLES: LABEL_FILTER_STYLES$i,
    LABEL_FILTER_TAGS_TITLE: LABEL_FILTER_TAGS_TITLE$i,
    LABEL_FILTER_TAG_EPILEPSY: LABEL_FILTER_TAG_EPILEPSY$h,
    LABEL_FILTER_TAG_HUMOR: LABEL_FILTER_TAG_HUMOR$h,
    LABEL_FILTER_TAG_NSFW: LABEL_FILTER_TAG_NSFW$i,
    LABEL_FILTER_TAG_UNTAGGED: LABEL_FILTER_TAG_UNTAGGED$h,
    LABEL_FILTER_TYPE_ANIMATED: LABEL_FILTER_TYPE_ANIMATED$h,
    LABEL_FILTER_TYPE_STATIC: LABEL_FILTER_TYPE_STATIC$h,
    LABEL_GAME_SEARCH_TITLE: LABEL_GAME_SEARCH_TITLE$i,
    LABEL_HUMOR: LABEL_HUMOR$h,
    LABEL_MORE_SGDB_TITLE: LABEL_MORE_SGDB_TITLE$i,
    LABEL_MOTD_ALL: LABEL_MOTD_ALL$c,
    LABEL_MOTD_THIS: LABEL_MOTD_THIS$c,
    LABEL_NOTES: LABEL_NOTES$i,
    LABEL_NSFW: LABEL_NSFW$i,
    LABEL_RESTART_STEAM_TITLE: LABEL_RESTART_STEAM_TITLE$h,
    LABEL_SETTINGS_ASSET_TABS: LABEL_SETTINGS_ASSET_TABS$g,
    LABEL_SETTINGS_DISABLE_MOTD: LABEL_SETTINGS_DISABLE_MOTD$d,
    LABEL_SETTINGS_DISABLE_MOTD_DESC: LABEL_SETTINGS_DISABLE_MOTD_DESC$c,
    LABEL_SQUARE_CAPSULES: LABEL_SQUARE_CAPSULES$f,
    LABEL_SQUARE_CAPSULES_DESC: LABEL_SQUARE_CAPSULES_DESC$e,
    LABEL_TAB_CAPSULE: LABEL_TAB_CAPSULE$i,
    LABEL_TAB_HERO: LABEL_TAB_HERO$i,
    LABEL_TAB_ICON: LABEL_TAB_ICON$i,
    LABEL_TAB_LOGO: LABEL_TAB_LOGO$i,
    LABEL_TAB_MANAGE: LABEL_TAB_MANAGE$i,
    LABEL_TAB_WIDECAPSULE: LABEL_TAB_WIDECAPSULE$i,
    LABEL_TRANSLATION_CREDIT_TITLE: LABEL_TRANSLATION_CREDIT_TITLE$i,
    LABEL_UNIFORM_RECENT: LABEL_UNIFORM_RECENT$b,
    LABEL_UNIFORM_RECENT_DESC: LABEL_UNIFORM_RECENT_DESC$b,
    LABEL_USAGE_TITLE: LABEL_USAGE_TITLE$h,
    MSG_ASSETS_FILTERED: MSG_ASSETS_FILTERED$h,
    MSG_ASSET_APPLY_ERROR: MSG_ASSET_APPLY_ERROR$g,
    MSG_ASSET_APPLY_SUCCESS: MSG_ASSET_APPLY_SUCCESS$h,
    MSG_ASSET_TAB_SETTINGS_DESC: MSG_ASSET_TAB_SETTINGS_DESC$g,
    MSG_FILTER_TAG_NSFW_ENABLED: MSG_FILTER_TAG_NSFW_ENABLED$h,
    MSG_GAME_SELECTED: MSG_GAME_SELECTED$h,
    MSG_GAME_SELECTED_AND_ASSETS_FILTERED: MSG_GAME_SELECTED_AND_ASSETS_FILTERED$h,
    MSG_RESTART_STEAM_DESC: MSG_RESTART_STEAM_DESC$g,
    MSG_USAGE_INSTRUCTIONS: MSG_USAGE_INSTRUCTIONS$h,
    TITLE_MOTD_HIDE: TITLE_MOTD_HIDE$c,
    default: es419
});

var ASSET_TYPE_CAPSULE$h="Couverture";var ASSET_TYPE_WIDECAPSULE$h="Couverture large";var ASSET_TYPE_HERO$h="Bannière";var ASSET_TYPE_LOGO$h="Marque";var ASSET_TYPE_ICON$h="Icône";var LABEL_TAB_CAPSULE$h="Couverture";var LABEL_TAB_WIDECAPSULE$h="Couverture large";var LABEL_TAB_HERO$h="Bannière";var LABEL_TAB_LOGO$h="Marque";var LABEL_TAB_ICON$h="Icône";var LABEL_TAB_MANAGE$h="Gérer";var MSG_USAGE_INSTRUCTIONS$g="Sélectionner un jeu {arrow} {optionsButton} {arrow} \"{ACTION_CHANGE_ARTWORK}\"";var ACTION_CHANGE_ARTWORK$h="Modifier les images...";var ACTION_SHOW_LINK_QR$h="Afficher le code QR du lien";var MSG_ASSET_TAB_SETTINGS_DESC$f="Réorganiser ou masquer les onglets inutilisés, et définir l'onglet par défaut qui s'ouvre en utilisant \"{ACTION_CHANGE_ARTWORK}\"";var LABEL_USAGE_TITLE$g="Perdu? Voici un guide rapide";var LABEL_SQUARE_CAPSULES$e="Couvertures carrées";var LABEL_SQUARE_CAPSULES_DESC$d="Utiliser des couvertures carrées au lieu de celles en portrait. Les filtres carrés seront automatiquement sélectionnés.";var LABEL_UNIFORM_RECENT$a="Couvertures uniformisées";var LABEL_UNIFORM_RECENT_DESC$a="Forcer le dernier jeu joué sur l'écran d'accueil à s'uniformiser avec les autres couvertures.";var LABEL_CAPSULE_GLOW$e="Lueur de couverture";var LABEL_CAPSULE_GLOW_DESC$d="Modifie l'intensité de la lueur dans la bibliothèque.";var LABEL_CAPSULE_GLOW_OFF$e="Sans";var LABEL_SETTINGS_ASSET_TABS$f="Options des onglets";var LABEL_SETTINGS_DISABLE_MOTD$c="Désactiver les annonces";var LABEL_SETTINGS_DISABLE_MOTD_DESC$b="Les annonces sont utilisées avec parcimonie pour afficher des informations importantes ou des événements communautaires.";var LABEL_TRANSLATION_CREDIT_TITLE$h="Traduction française";var LABEL_MORE_SGDB_TITLE$h="Plus de contenu SteamGridDB";var ACTION_SGDB_DISCORD$h="Rejoignez le Discord";var ACTION_SGDB_GITHUB$g="Projets Open Source";var ACTION_SGDB_DONATE$h="Soutenez-nous sur Patreon";var ACTION_SGDB_TRANSLATE$h="Aidez à traduire";var ACTION_SGDB_BOOP$h="Découvrez SGDBoop";var LABEL_RESTART_STEAM_TITLE$g="Redémarrer Steam?";var ACTION_RESTART_STEAM_LATER$g="Plus tard";var ACTION_RESTART_STEAM_NOW$g="Redémarrer maintenant";var MSG_RESTART_STEAM_DESC$f="Steam doit être redémarré pour appliquer les modifications.";var LABEL_GAME_SEARCH_TITLE$h="Rechercher un jeu...";var LABEL_FILTER_MODAL_TITLE$h="Filtres {assetType}";var LABEL_FILTER_GAME$h="Jeu";var LABEL_FILTER_DIMENSIONS$h="Dimensions";var LABEL_FILTER_STYLES$h="Styles";var LABEL_FILTER_FILE_TYPES$h="Types de fichiers";var LABEL_FILTER_ANIMATION_TYPE_TITLE$h="Types";var LABEL_FILTER_TYPE_ANIMATED$g="Animé";var LABEL_FILTER_TYPE_STATIC$g="Statique";var LABEL_FILTER_TAGS_TITLE$h="Tags";var LABEL_FILTER_TAG_NSFW$h="Contenu adulte";var MSG_FILTER_TAG_NSFW_ENABLED$g="Avez-vous demandé à vos parents?";var LABEL_FILTER_TAG_HUMOR$g="Humoristique";var LABEL_FILTER_TAG_EPILEPSY$g="Épilepsie";var LABEL_FILTER_TAG_UNTAGGED$g="Aucun tag";var ACTION_FILTER_RESET$h="Réinitialiser les filtres";var LABEL_BEGGING_MODAL_TITLE$e="Merci d'utiliser SteamGridDB !";var LABEL_BEGGING_MODAL_DESC$d="Pensez à faire un don pour aider à la maintenance et aux frais de serveur!";var ACTION_HIDE_POS_GUIDES$f="Masquer les guides";var ACTION_SHOW_OUTLINE$f="Afficher les guides";var ACTION_ADJUST_POS_SIZE$g="Ajuster la taille";var ACTION_CHANGE_POS_LOGO_ANCHOR_POINT$a="Modifier le point d'ancrage";var LABEL_ASSET_CURRENT$g="{assetType} actuelle";var ACTION_ASSET_CUSTOM_CLEAR$g="Effacer l'image sélectionnée";var ACTION_ASSET_BROWSE_LOCAL$f="Parcourir les fichiers locaux";var ACTION_ASSET_APPLY_TRANSPARENT$f="Aucune image";var LABEL_NOTES$h="Notes";var LABEL_ANIMATED$g="Animé";var LABEL_NSFW$h="Contenu Adulte";var LABEL_HUMOR$g="Humoristique";var LABEL_EPILEPSY$g="Épilepsie";var ACTION_OPEN_FILTER$h="Filtre";var ACTION_OPEN_OFFICIAL_ASSETS$g="{assetType} officielle";var ACTION_ASSET_APPLY$g="Appliquer {assetType}";var MSG_GAME_SELECTED$g="{gameName} sélectionné";var MSG_ASSETS_FILTERED$g="Certains éléments peuvent être cachés en raison du filtre";var MSG_GAME_SELECTED_AND_ASSETS_FILTERED$g="{gameName} sélectionné avec le filtre";var TITLE_MOTD_HIDE$b="Masquer l'annonce ?";var LABEL_MOTD_THIS$b="Cette annonce";var LABEL_MOTD_ALL$b="Toutes les annonces";var MSG_ASSET_APPLY_SUCCESS$g="{assetType} a été appliquée avec succès!";var MSG_ASSET_APPLY_ERROR$f="Il y a eu un problème avec cette image.";var ACTION_OPEN_DETAILS$g="Détails";var fr = {ASSET_TYPE_CAPSULE:ASSET_TYPE_CAPSULE$h,ASSET_TYPE_WIDECAPSULE:ASSET_TYPE_WIDECAPSULE$h,ASSET_TYPE_HERO:ASSET_TYPE_HERO$h,ASSET_TYPE_LOGO:ASSET_TYPE_LOGO$h,ASSET_TYPE_ICON:ASSET_TYPE_ICON$h,LABEL_TAB_CAPSULE:LABEL_TAB_CAPSULE$h,LABEL_TAB_WIDECAPSULE:LABEL_TAB_WIDECAPSULE$h,LABEL_TAB_HERO:LABEL_TAB_HERO$h,LABEL_TAB_LOGO:LABEL_TAB_LOGO$h,LABEL_TAB_ICON:LABEL_TAB_ICON$h,LABEL_TAB_MANAGE:LABEL_TAB_MANAGE$h,MSG_USAGE_INSTRUCTIONS:MSG_USAGE_INSTRUCTIONS$g,ACTION_CHANGE_ARTWORK:ACTION_CHANGE_ARTWORK$h,ACTION_SHOW_LINK_QR:ACTION_SHOW_LINK_QR$h,MSG_ASSET_TAB_SETTINGS_DESC:MSG_ASSET_TAB_SETTINGS_DESC$f,LABEL_USAGE_TITLE:LABEL_USAGE_TITLE$g,LABEL_SQUARE_CAPSULES:LABEL_SQUARE_CAPSULES$e,LABEL_SQUARE_CAPSULES_DESC:LABEL_SQUARE_CAPSULES_DESC$d,LABEL_UNIFORM_RECENT:LABEL_UNIFORM_RECENT$a,LABEL_UNIFORM_RECENT_DESC:LABEL_UNIFORM_RECENT_DESC$a,LABEL_CAPSULE_GLOW:LABEL_CAPSULE_GLOW$e,LABEL_CAPSULE_GLOW_DESC:LABEL_CAPSULE_GLOW_DESC$d,LABEL_CAPSULE_GLOW_OFF:LABEL_CAPSULE_GLOW_OFF$e,LABEL_SETTINGS_ASSET_TABS:LABEL_SETTINGS_ASSET_TABS$f,LABEL_SETTINGS_DISABLE_MOTD:LABEL_SETTINGS_DISABLE_MOTD$c,LABEL_SETTINGS_DISABLE_MOTD_DESC:LABEL_SETTINGS_DISABLE_MOTD_DESC$b,LABEL_TRANSLATION_CREDIT_TITLE:LABEL_TRANSLATION_CREDIT_TITLE$h,LABEL_MORE_SGDB_TITLE:LABEL_MORE_SGDB_TITLE$h,ACTION_SGDB_DISCORD:ACTION_SGDB_DISCORD$h,ACTION_SGDB_GITHUB:ACTION_SGDB_GITHUB$g,ACTION_SGDB_DONATE:ACTION_SGDB_DONATE$h,ACTION_SGDB_TRANSLATE:ACTION_SGDB_TRANSLATE$h,ACTION_SGDB_BOOP:ACTION_SGDB_BOOP$h,LABEL_RESTART_STEAM_TITLE:LABEL_RESTART_STEAM_TITLE$g,ACTION_RESTART_STEAM_LATER:ACTION_RESTART_STEAM_LATER$g,ACTION_RESTART_STEAM_NOW:ACTION_RESTART_STEAM_NOW$g,MSG_RESTART_STEAM_DESC:MSG_RESTART_STEAM_DESC$f,LABEL_GAME_SEARCH_TITLE:LABEL_GAME_SEARCH_TITLE$h,LABEL_FILTER_MODAL_TITLE:LABEL_FILTER_MODAL_TITLE$h,LABEL_FILTER_GAME:LABEL_FILTER_GAME$h,LABEL_FILTER_DIMENSIONS:LABEL_FILTER_DIMENSIONS$h,LABEL_FILTER_STYLES:LABEL_FILTER_STYLES$h,LABEL_FILTER_FILE_TYPES:LABEL_FILTER_FILE_TYPES$h,LABEL_FILTER_ANIMATION_TYPE_TITLE:LABEL_FILTER_ANIMATION_TYPE_TITLE$h,LABEL_FILTER_TYPE_ANIMATED:LABEL_FILTER_TYPE_ANIMATED$g,LABEL_FILTER_TYPE_STATIC:LABEL_FILTER_TYPE_STATIC$g,LABEL_FILTER_TAGS_TITLE:LABEL_FILTER_TAGS_TITLE$h,LABEL_FILTER_TAG_NSFW:LABEL_FILTER_TAG_NSFW$h,MSG_FILTER_TAG_NSFW_ENABLED:MSG_FILTER_TAG_NSFW_ENABLED$g,LABEL_FILTER_TAG_HUMOR:LABEL_FILTER_TAG_HUMOR$g,LABEL_FILTER_TAG_EPILEPSY:LABEL_FILTER_TAG_EPILEPSY$g,LABEL_FILTER_TAG_UNTAGGED:LABEL_FILTER_TAG_UNTAGGED$g,ACTION_FILTER_RESET:ACTION_FILTER_RESET$h,LABEL_BEGGING_MODAL_TITLE:LABEL_BEGGING_MODAL_TITLE$e,LABEL_BEGGING_MODAL_DESC:LABEL_BEGGING_MODAL_DESC$d,ACTION_HIDE_POS_GUIDES:ACTION_HIDE_POS_GUIDES$f,ACTION_SHOW_OUTLINE:ACTION_SHOW_OUTLINE$f,ACTION_ADJUST_POS_SIZE:ACTION_ADJUST_POS_SIZE$g,ACTION_CHANGE_POS_LOGO_ANCHOR_POINT:ACTION_CHANGE_POS_LOGO_ANCHOR_POINT$a,LABEL_ASSET_CURRENT:LABEL_ASSET_CURRENT$g,ACTION_ASSET_CUSTOM_CLEAR:ACTION_ASSET_CUSTOM_CLEAR$g,ACTION_ASSET_BROWSE_LOCAL:ACTION_ASSET_BROWSE_LOCAL$f,ACTION_ASSET_APPLY_TRANSPARENT:ACTION_ASSET_APPLY_TRANSPARENT$f,LABEL_NOTES:LABEL_NOTES$h,LABEL_ANIMATED:LABEL_ANIMATED$g,LABEL_NSFW:LABEL_NSFW$h,LABEL_HUMOR:LABEL_HUMOR$g,LABEL_EPILEPSY:LABEL_EPILEPSY$g,ACTION_OPEN_FILTER:ACTION_OPEN_FILTER$h,ACTION_OPEN_OFFICIAL_ASSETS:ACTION_OPEN_OFFICIAL_ASSETS$g,ACTION_ASSET_APPLY:ACTION_ASSET_APPLY$g,MSG_GAME_SELECTED:MSG_GAME_SELECTED$g,MSG_ASSETS_FILTERED:MSG_ASSETS_FILTERED$g,MSG_GAME_SELECTED_AND_ASSETS_FILTERED:MSG_GAME_SELECTED_AND_ASSETS_FILTERED$g,TITLE_MOTD_HIDE:TITLE_MOTD_HIDE$b,LABEL_MOTD_THIS:LABEL_MOTD_THIS$b,LABEL_MOTD_ALL:LABEL_MOTD_ALL$b,MSG_ASSET_APPLY_SUCCESS:MSG_ASSET_APPLY_SUCCESS$g,MSG_ASSET_APPLY_ERROR:MSG_ASSET_APPLY_ERROR$f,ACTION_OPEN_DETAILS:ACTION_OPEN_DETAILS$g};

var fr$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    ACTION_ADJUST_POS_SIZE: ACTION_ADJUST_POS_SIZE$g,
    ACTION_ASSET_APPLY: ACTION_ASSET_APPLY$g,
    ACTION_ASSET_APPLY_TRANSPARENT: ACTION_ASSET_APPLY_TRANSPARENT$f,
    ACTION_ASSET_BROWSE_LOCAL: ACTION_ASSET_BROWSE_LOCAL$f,
    ACTION_ASSET_CUSTOM_CLEAR: ACTION_ASSET_CUSTOM_CLEAR$g,
    ACTION_CHANGE_ARTWORK: ACTION_CHANGE_ARTWORK$h,
    ACTION_CHANGE_POS_LOGO_ANCHOR_POINT: ACTION_CHANGE_POS_LOGO_ANCHOR_POINT$a,
    ACTION_FILTER_RESET: ACTION_FILTER_RESET$h,
    ACTION_HIDE_POS_GUIDES: ACTION_HIDE_POS_GUIDES$f,
    ACTION_OPEN_DETAILS: ACTION_OPEN_DETAILS$g,
    ACTION_OPEN_FILTER: ACTION_OPEN_FILTER$h,
    ACTION_OPEN_OFFICIAL_ASSETS: ACTION_OPEN_OFFICIAL_ASSETS$g,
    ACTION_RESTART_STEAM_LATER: ACTION_RESTART_STEAM_LATER$g,
    ACTION_RESTART_STEAM_NOW: ACTION_RESTART_STEAM_NOW$g,
    ACTION_SGDB_BOOP: ACTION_SGDB_BOOP$h,
    ACTION_SGDB_DISCORD: ACTION_SGDB_DISCORD$h,
    ACTION_SGDB_DONATE: ACTION_SGDB_DONATE$h,
    ACTION_SGDB_GITHUB: ACTION_SGDB_GITHUB$g,
    ACTION_SGDB_TRANSLATE: ACTION_SGDB_TRANSLATE$h,
    ACTION_SHOW_LINK_QR: ACTION_SHOW_LINK_QR$h,
    ACTION_SHOW_OUTLINE: ACTION_SHOW_OUTLINE$f,
    ASSET_TYPE_CAPSULE: ASSET_TYPE_CAPSULE$h,
    ASSET_TYPE_HERO: ASSET_TYPE_HERO$h,
    ASSET_TYPE_ICON: ASSET_TYPE_ICON$h,
    ASSET_TYPE_LOGO: ASSET_TYPE_LOGO$h,
    ASSET_TYPE_WIDECAPSULE: ASSET_TYPE_WIDECAPSULE$h,
    LABEL_ANIMATED: LABEL_ANIMATED$g,
    LABEL_ASSET_CURRENT: LABEL_ASSET_CURRENT$g,
    LABEL_BEGGING_MODAL_DESC: LABEL_BEGGING_MODAL_DESC$d,
    LABEL_BEGGING_MODAL_TITLE: LABEL_BEGGING_MODAL_TITLE$e,
    LABEL_CAPSULE_GLOW: LABEL_CAPSULE_GLOW$e,
    LABEL_CAPSULE_GLOW_DESC: LABEL_CAPSULE_GLOW_DESC$d,
    LABEL_CAPSULE_GLOW_OFF: LABEL_CAPSULE_GLOW_OFF$e,
    LABEL_EPILEPSY: LABEL_EPILEPSY$g,
    LABEL_FILTER_ANIMATION_TYPE_TITLE: LABEL_FILTER_ANIMATION_TYPE_TITLE$h,
    LABEL_FILTER_DIMENSIONS: LABEL_FILTER_DIMENSIONS$h,
    LABEL_FILTER_FILE_TYPES: LABEL_FILTER_FILE_TYPES$h,
    LABEL_FILTER_GAME: LABEL_FILTER_GAME$h,
    LABEL_FILTER_MODAL_TITLE: LABEL_FILTER_MODAL_TITLE$h,
    LABEL_FILTER_STYLES: LABEL_FILTER_STYLES$h,
    LABEL_FILTER_TAGS_TITLE: LABEL_FILTER_TAGS_TITLE$h,
    LABEL_FILTER_TAG_EPILEPSY: LABEL_FILTER_TAG_EPILEPSY$g,
    LABEL_FILTER_TAG_HUMOR: LABEL_FILTER_TAG_HUMOR$g,
    LABEL_FILTER_TAG_NSFW: LABEL_FILTER_TAG_NSFW$h,
    LABEL_FILTER_TAG_UNTAGGED: LABEL_FILTER_TAG_UNTAGGED$g,
    LABEL_FILTER_TYPE_ANIMATED: LABEL_FILTER_TYPE_ANIMATED$g,
    LABEL_FILTER_TYPE_STATIC: LABEL_FILTER_TYPE_STATIC$g,
    LABEL_GAME_SEARCH_TITLE: LABEL_GAME_SEARCH_TITLE$h,
    LABEL_HUMOR: LABEL_HUMOR$g,
    LABEL_MORE_SGDB_TITLE: LABEL_MORE_SGDB_TITLE$h,
    LABEL_MOTD_ALL: LABEL_MOTD_ALL$b,
    LABEL_MOTD_THIS: LABEL_MOTD_THIS$b,
    LABEL_NOTES: LABEL_NOTES$h,
    LABEL_NSFW: LABEL_NSFW$h,
    LABEL_RESTART_STEAM_TITLE: LABEL_RESTART_STEAM_TITLE$g,
    LABEL_SETTINGS_ASSET_TABS: LABEL_SETTINGS_ASSET_TABS$f,
    LABEL_SETTINGS_DISABLE_MOTD: LABEL_SETTINGS_DISABLE_MOTD$c,
    LABEL_SETTINGS_DISABLE_MOTD_DESC: LABEL_SETTINGS_DISABLE_MOTD_DESC$b,
    LABEL_SQUARE_CAPSULES: LABEL_SQUARE_CAPSULES$e,
    LABEL_SQUARE_CAPSULES_DESC: LABEL_SQUARE_CAPSULES_DESC$d,
    LABEL_TAB_CAPSULE: LABEL_TAB_CAPSULE$h,
    LABEL_TAB_HERO: LABEL_TAB_HERO$h,
    LABEL_TAB_ICON: LABEL_TAB_ICON$h,
    LABEL_TAB_LOGO: LABEL_TAB_LOGO$h,
    LABEL_TAB_MANAGE: LABEL_TAB_MANAGE$h,
    LABEL_TAB_WIDECAPSULE: LABEL_TAB_WIDECAPSULE$h,
    LABEL_TRANSLATION_CREDIT_TITLE: LABEL_TRANSLATION_CREDIT_TITLE$h,
    LABEL_UNIFORM_RECENT: LABEL_UNIFORM_RECENT$a,
    LABEL_UNIFORM_RECENT_DESC: LABEL_UNIFORM_RECENT_DESC$a,
    LABEL_USAGE_TITLE: LABEL_USAGE_TITLE$g,
    MSG_ASSETS_FILTERED: MSG_ASSETS_FILTERED$g,
    MSG_ASSET_APPLY_ERROR: MSG_ASSET_APPLY_ERROR$f,
    MSG_ASSET_APPLY_SUCCESS: MSG_ASSET_APPLY_SUCCESS$g,
    MSG_ASSET_TAB_SETTINGS_DESC: MSG_ASSET_TAB_SETTINGS_DESC$f,
    MSG_FILTER_TAG_NSFW_ENABLED: MSG_FILTER_TAG_NSFW_ENABLED$g,
    MSG_GAME_SELECTED: MSG_GAME_SELECTED$g,
    MSG_GAME_SELECTED_AND_ASSETS_FILTERED: MSG_GAME_SELECTED_AND_ASSETS_FILTERED$g,
    MSG_RESTART_STEAM_DESC: MSG_RESTART_STEAM_DESC$f,
    MSG_USAGE_INSTRUCTIONS: MSG_USAGE_INSTRUCTIONS$g,
    TITLE_MOTD_HIDE: TITLE_MOTD_HIDE$b,
    default: fr
});

var ASSET_TYPE_CAPSULE$g="Tunnistekuva";var ASSET_TYPE_WIDECAPSULE$g="Leveä Tunnistekuva";var ASSET_TYPE_HERO$g="Sankarikuva";var ASSET_TYPE_LOGO$g="Logo";var ASSET_TYPE_ICON$g="Kuvake";var LABEL_TAB_CAPSULE$g="Tunnistekuva";var LABEL_TAB_WIDECAPSULE$g="Leveä Tunnistekuva";var LABEL_TAB_HERO$g="Sankarikuva";var LABEL_TAB_LOGO$g="Logo";var LABEL_TAB_ICON$g="Kuvake";var LABEL_TAB_MANAGE$g="Hallitse";var MSG_USAGE_INSTRUCTIONS$f="Valitse peli {arrow} {optionsButton} {arrow} \"{ACTION_CHANGE_ARTWORK}\"";var ACTION_CHANGE_ARTWORK$g="Vaihda kuva...";var ACTION_SHOW_LINK_QR$g="Näytä QR-koodina";var MSG_ASSET_TAB_SETTINGS_DESC$e="Järjestä tai piilota käyttämättömiä välilehtiä ja aseta oletusvälilehti, joka avautuu, kun valitset \"{ACTION_CHANGE_ARTWORK}\"";var LABEL_USAGE_TITLE$f="Hämmentääkö? Tässä pikaopas";var LABEL_SETTINGS_ASSET_TABS$e="Sisältövälilehtien asetukset";var LABEL_TRANSLATION_CREDIT_TITLE$g="Suomenkielinen käännös";var LABEL_MORE_SGDB_TITLE$g="Lisää SteamGridDB:stä";var ACTION_SGDB_DISCORD$g="Liity Discordiin";var ACTION_SGDB_GITHUB$f="Avoimen lähdekoodin projektit";var ACTION_SGDB_DONATE$g="Tue meitä Patreonissa";var ACTION_SGDB_TRANSLATE$g="Auta kääntämisessä";var ACTION_SGDB_BOOP$g="Tutustu SGDBoop:iin";var LABEL_RESTART_STEAM_TITLE$f="Käynnistä Steam uudelleen?";var ACTION_RESTART_STEAM_LATER$f="Myöhemmin";var ACTION_RESTART_STEAM_NOW$f="Käynnistä uudelleen nyt";var MSG_RESTART_STEAM_DESC$e="Steam on käynnistettävä uudelleen, jotta muutokset tulevat voimaan.";var LABEL_GAME_SEARCH_TITLE$g="Hae peliä...";var LABEL_FILTER_MODAL_TITLE$g="{assetType} Suodatin";var LABEL_FILTER_GAME$g="Peli";var LABEL_FILTER_DIMENSIONS$g="Mitat";var LABEL_FILTER_STYLES$g="Tyylit";var LABEL_FILTER_FILE_TYPES$g="Tiedostomuodot";var LABEL_FILTER_ANIMATION_TYPE_TITLE$g="Tyypit";var LABEL_FILTER_TYPE_ANIMATED$f="Animoitu";var LABEL_FILTER_TYPE_STATIC$f="Liikkumaton";var LABEL_FILTER_TAGS_TITLE$g="Tunnisteet";var LABEL_FILTER_TAG_NSFW$g="Aikuissisältö";var MSG_FILTER_TAG_NSFW_ENABLED$f="Saatat haluta hieman yksityisyyttä.";var LABEL_FILTER_TAG_HUMOR$f="Huumori";var LABEL_FILTER_TAG_EPILEPSY$f="Epilepsia";var LABEL_FILTER_TAG_UNTAGGED$f="Tunnisteeton";var ACTION_FILTER_RESET$g="Nollaa suodattimet";var ACTION_HIDE_POS_GUIDES$e="Piilota oppaat";var ACTION_SHOW_OUTLINE$e="Näytä oppaat";var ACTION_ADJUST_POS_SIZE$f="Säädä kokoa";var LABEL_NOTES$g="Lisämerkinnät";var LABEL_ANIMATED$f="Animoitu";var LABEL_NSFW$g="Aikuissisältö";var LABEL_HUMOR$f="Huumori";var LABEL_EPILEPSY$f="Epilepsia";var ACTION_OPEN_FILTER$g="Suodatin";var ACTION_OPEN_OFFICIAL_ASSETS$f="Virallinen {assetType}";var ACTION_ASSET_APPLY$f="Ota käyttöön {assetType}";var MSG_GAME_SELECTED$f="Valittu {gameName}";var MSG_ASSETS_FILTERED$f="Suodattimet ovat saattaneet piilottaa osan sisällöstä";var MSG_GAME_SELECTED_AND_ASSETS_FILTERED$f="Valittu {gameName} suodattimella";var MSG_ASSET_APPLY_SUCCESS$f="{assetType} on otettu käyttöön onnistuneesti!";var fi = {ASSET_TYPE_CAPSULE:ASSET_TYPE_CAPSULE$g,ASSET_TYPE_WIDECAPSULE:ASSET_TYPE_WIDECAPSULE$g,ASSET_TYPE_HERO:ASSET_TYPE_HERO$g,ASSET_TYPE_LOGO:ASSET_TYPE_LOGO$g,ASSET_TYPE_ICON:ASSET_TYPE_ICON$g,LABEL_TAB_CAPSULE:LABEL_TAB_CAPSULE$g,LABEL_TAB_WIDECAPSULE:LABEL_TAB_WIDECAPSULE$g,LABEL_TAB_HERO:LABEL_TAB_HERO$g,LABEL_TAB_LOGO:LABEL_TAB_LOGO$g,LABEL_TAB_ICON:LABEL_TAB_ICON$g,LABEL_TAB_MANAGE:LABEL_TAB_MANAGE$g,MSG_USAGE_INSTRUCTIONS:MSG_USAGE_INSTRUCTIONS$f,ACTION_CHANGE_ARTWORK:ACTION_CHANGE_ARTWORK$g,ACTION_SHOW_LINK_QR:ACTION_SHOW_LINK_QR$g,MSG_ASSET_TAB_SETTINGS_DESC:MSG_ASSET_TAB_SETTINGS_DESC$e,LABEL_USAGE_TITLE:LABEL_USAGE_TITLE$f,LABEL_SETTINGS_ASSET_TABS:LABEL_SETTINGS_ASSET_TABS$e,LABEL_TRANSLATION_CREDIT_TITLE:LABEL_TRANSLATION_CREDIT_TITLE$g,LABEL_MORE_SGDB_TITLE:LABEL_MORE_SGDB_TITLE$g,ACTION_SGDB_DISCORD:ACTION_SGDB_DISCORD$g,ACTION_SGDB_GITHUB:ACTION_SGDB_GITHUB$f,ACTION_SGDB_DONATE:ACTION_SGDB_DONATE$g,ACTION_SGDB_TRANSLATE:ACTION_SGDB_TRANSLATE$g,ACTION_SGDB_BOOP:ACTION_SGDB_BOOP$g,LABEL_RESTART_STEAM_TITLE:LABEL_RESTART_STEAM_TITLE$f,ACTION_RESTART_STEAM_LATER:ACTION_RESTART_STEAM_LATER$f,ACTION_RESTART_STEAM_NOW:ACTION_RESTART_STEAM_NOW$f,MSG_RESTART_STEAM_DESC:MSG_RESTART_STEAM_DESC$e,LABEL_GAME_SEARCH_TITLE:LABEL_GAME_SEARCH_TITLE$g,LABEL_FILTER_MODAL_TITLE:LABEL_FILTER_MODAL_TITLE$g,LABEL_FILTER_GAME:LABEL_FILTER_GAME$g,LABEL_FILTER_DIMENSIONS:LABEL_FILTER_DIMENSIONS$g,LABEL_FILTER_STYLES:LABEL_FILTER_STYLES$g,LABEL_FILTER_FILE_TYPES:LABEL_FILTER_FILE_TYPES$g,LABEL_FILTER_ANIMATION_TYPE_TITLE:LABEL_FILTER_ANIMATION_TYPE_TITLE$g,LABEL_FILTER_TYPE_ANIMATED:LABEL_FILTER_TYPE_ANIMATED$f,LABEL_FILTER_TYPE_STATIC:LABEL_FILTER_TYPE_STATIC$f,LABEL_FILTER_TAGS_TITLE:LABEL_FILTER_TAGS_TITLE$g,LABEL_FILTER_TAG_NSFW:LABEL_FILTER_TAG_NSFW$g,MSG_FILTER_TAG_NSFW_ENABLED:MSG_FILTER_TAG_NSFW_ENABLED$f,LABEL_FILTER_TAG_HUMOR:LABEL_FILTER_TAG_HUMOR$f,LABEL_FILTER_TAG_EPILEPSY:LABEL_FILTER_TAG_EPILEPSY$f,LABEL_FILTER_TAG_UNTAGGED:LABEL_FILTER_TAG_UNTAGGED$f,ACTION_FILTER_RESET:ACTION_FILTER_RESET$g,ACTION_HIDE_POS_GUIDES:ACTION_HIDE_POS_GUIDES$e,ACTION_SHOW_OUTLINE:ACTION_SHOW_OUTLINE$e,ACTION_ADJUST_POS_SIZE:ACTION_ADJUST_POS_SIZE$f,LABEL_NOTES:LABEL_NOTES$g,LABEL_ANIMATED:LABEL_ANIMATED$f,LABEL_NSFW:LABEL_NSFW$g,LABEL_HUMOR:LABEL_HUMOR$f,LABEL_EPILEPSY:LABEL_EPILEPSY$f,ACTION_OPEN_FILTER:ACTION_OPEN_FILTER$g,ACTION_OPEN_OFFICIAL_ASSETS:ACTION_OPEN_OFFICIAL_ASSETS$f,ACTION_ASSET_APPLY:ACTION_ASSET_APPLY$f,MSG_GAME_SELECTED:MSG_GAME_SELECTED$f,MSG_ASSETS_FILTERED:MSG_ASSETS_FILTERED$f,MSG_GAME_SELECTED_AND_ASSETS_FILTERED:MSG_GAME_SELECTED_AND_ASSETS_FILTERED$f,MSG_ASSET_APPLY_SUCCESS:MSG_ASSET_APPLY_SUCCESS$f};

var fi$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    ACTION_ADJUST_POS_SIZE: ACTION_ADJUST_POS_SIZE$f,
    ACTION_ASSET_APPLY: ACTION_ASSET_APPLY$f,
    ACTION_CHANGE_ARTWORK: ACTION_CHANGE_ARTWORK$g,
    ACTION_FILTER_RESET: ACTION_FILTER_RESET$g,
    ACTION_HIDE_POS_GUIDES: ACTION_HIDE_POS_GUIDES$e,
    ACTION_OPEN_FILTER: ACTION_OPEN_FILTER$g,
    ACTION_OPEN_OFFICIAL_ASSETS: ACTION_OPEN_OFFICIAL_ASSETS$f,
    ACTION_RESTART_STEAM_LATER: ACTION_RESTART_STEAM_LATER$f,
    ACTION_RESTART_STEAM_NOW: ACTION_RESTART_STEAM_NOW$f,
    ACTION_SGDB_BOOP: ACTION_SGDB_BOOP$g,
    ACTION_SGDB_DISCORD: ACTION_SGDB_DISCORD$g,
    ACTION_SGDB_DONATE: ACTION_SGDB_DONATE$g,
    ACTION_SGDB_GITHUB: ACTION_SGDB_GITHUB$f,
    ACTION_SGDB_TRANSLATE: ACTION_SGDB_TRANSLATE$g,
    ACTION_SHOW_LINK_QR: ACTION_SHOW_LINK_QR$g,
    ACTION_SHOW_OUTLINE: ACTION_SHOW_OUTLINE$e,
    ASSET_TYPE_CAPSULE: ASSET_TYPE_CAPSULE$g,
    ASSET_TYPE_HERO: ASSET_TYPE_HERO$g,
    ASSET_TYPE_ICON: ASSET_TYPE_ICON$g,
    ASSET_TYPE_LOGO: ASSET_TYPE_LOGO$g,
    ASSET_TYPE_WIDECAPSULE: ASSET_TYPE_WIDECAPSULE$g,
    LABEL_ANIMATED: LABEL_ANIMATED$f,
    LABEL_EPILEPSY: LABEL_EPILEPSY$f,
    LABEL_FILTER_ANIMATION_TYPE_TITLE: LABEL_FILTER_ANIMATION_TYPE_TITLE$g,
    LABEL_FILTER_DIMENSIONS: LABEL_FILTER_DIMENSIONS$g,
    LABEL_FILTER_FILE_TYPES: LABEL_FILTER_FILE_TYPES$g,
    LABEL_FILTER_GAME: LABEL_FILTER_GAME$g,
    LABEL_FILTER_MODAL_TITLE: LABEL_FILTER_MODAL_TITLE$g,
    LABEL_FILTER_STYLES: LABEL_FILTER_STYLES$g,
    LABEL_FILTER_TAGS_TITLE: LABEL_FILTER_TAGS_TITLE$g,
    LABEL_FILTER_TAG_EPILEPSY: LABEL_FILTER_TAG_EPILEPSY$f,
    LABEL_FILTER_TAG_HUMOR: LABEL_FILTER_TAG_HUMOR$f,
    LABEL_FILTER_TAG_NSFW: LABEL_FILTER_TAG_NSFW$g,
    LABEL_FILTER_TAG_UNTAGGED: LABEL_FILTER_TAG_UNTAGGED$f,
    LABEL_FILTER_TYPE_ANIMATED: LABEL_FILTER_TYPE_ANIMATED$f,
    LABEL_FILTER_TYPE_STATIC: LABEL_FILTER_TYPE_STATIC$f,
    LABEL_GAME_SEARCH_TITLE: LABEL_GAME_SEARCH_TITLE$g,
    LABEL_HUMOR: LABEL_HUMOR$f,
    LABEL_MORE_SGDB_TITLE: LABEL_MORE_SGDB_TITLE$g,
    LABEL_NOTES: LABEL_NOTES$g,
    LABEL_NSFW: LABEL_NSFW$g,
    LABEL_RESTART_STEAM_TITLE: LABEL_RESTART_STEAM_TITLE$f,
    LABEL_SETTINGS_ASSET_TABS: LABEL_SETTINGS_ASSET_TABS$e,
    LABEL_TAB_CAPSULE: LABEL_TAB_CAPSULE$g,
    LABEL_TAB_HERO: LABEL_TAB_HERO$g,
    LABEL_TAB_ICON: LABEL_TAB_ICON$g,
    LABEL_TAB_LOGO: LABEL_TAB_LOGO$g,
    LABEL_TAB_MANAGE: LABEL_TAB_MANAGE$g,
    LABEL_TAB_WIDECAPSULE: LABEL_TAB_WIDECAPSULE$g,
    LABEL_TRANSLATION_CREDIT_TITLE: LABEL_TRANSLATION_CREDIT_TITLE$g,
    LABEL_USAGE_TITLE: LABEL_USAGE_TITLE$f,
    MSG_ASSETS_FILTERED: MSG_ASSETS_FILTERED$f,
    MSG_ASSET_APPLY_SUCCESS: MSG_ASSET_APPLY_SUCCESS$f,
    MSG_ASSET_TAB_SETTINGS_DESC: MSG_ASSET_TAB_SETTINGS_DESC$e,
    MSG_FILTER_TAG_NSFW_ENABLED: MSG_FILTER_TAG_NSFW_ENABLED$f,
    MSG_GAME_SELECTED: MSG_GAME_SELECTED$f,
    MSG_GAME_SELECTED_AND_ASSETS_FILTERED: MSG_GAME_SELECTED_AND_ASSETS_FILTERED$f,
    MSG_RESTART_STEAM_DESC: MSG_RESTART_STEAM_DESC$e,
    MSG_USAGE_INSTRUCTIONS: MSG_USAGE_INSTRUCTIONS$f,
    default: fi
});

var ASSET_TYPE_CAPSULE$f="Fronte";var ASSET_TYPE_WIDECAPSULE$f="Fronte Orizzontale";var ASSET_TYPE_HERO$f="Banner";var ASSET_TYPE_LOGO$f="Logo";var ASSET_TYPE_ICON$f="Icona";var LABEL_TAB_CAPSULE$f="Fronte";var LABEL_TAB_WIDECAPSULE$f="Fronte grande";var LABEL_TAB_HERO$f="Banner";var LABEL_TAB_LOGO$f="Logo";var LABEL_TAB_ICON$f="Icona";var LABEL_TAB_MANAGE$f="Gestisci";var MSG_USAGE_INSTRUCTIONS$e="Seleziona un gioco {arrow} {optionsButton} {arrow} \"{ACTION_CHANGE_ARTWORK}\"";var ACTION_CHANGE_ARTWORK$f="Cambia artwork...";var ACTION_SHOW_LINK_QR$f="Mostra codice QR";var MSG_ASSET_TAB_SETTINGS_DESC$d="Riordina o nascondi le schede inutilizzate e imposta la scheda di default all'apertura quando usi \"{ACTION_CHANGE_ARTWORK}\"";var LABEL_USAGE_TITLE$e="Ti sei perso? Ecco una breve guida";var LABEL_SQUARE_CAPSULES$d="Fronte squadrati";var LABEL_SQUARE_CAPSULES_DESC$c="Usa copertine quadrate per il fronte al posto delle verticali. Filtri quadrati verranno selezionati automaticamente.";var LABEL_UNIFORM_RECENT$9="Uniforma a capsule recenti";var LABEL_UNIFORM_RECENT_DESC$9="Uniforma la capsula dell'ultimo titolo giocato nella home screen al resto delle capsule";var LABEL_CAPSULE_GLOW$d="Riflessi capsula";var LABEL_CAPSULE_GLOW_DESC$c="Cambia l'intensità dei riflessi nella libreria.";var LABEL_CAPSULE_GLOW_OFF$d="Nullo";var LABEL_SETTINGS_ASSET_TABS$d="Impostazioni delle schede degli asset";var LABEL_SETTINGS_DISABLE_MOTD$b="Disabilita annunci";var LABEL_SETTINGS_DISABLE_MOTD_DESC$a="Gli annunci vengono saltuariamente usati per mostrare informazioni importanti o eventi della community ";var LABEL_TRANSLATION_CREDIT_TITLE$f="Traduzione italiana";var LABEL_MORE_SGDB_TITLE$f="Canali SteamGridDB";var ACTION_SGDB_DISCORD$f="Unisciti al Discord";var ACTION_SGDB_GITHUB$e="Progetti Open Source";var ACTION_SGDB_DONATE$f="Supportaci su Patreon";var ACTION_SGDB_TRANSLATE$f="Aiutaci a tradurre";var ACTION_SGDB_BOOP$f="Scopri SGDBoop";var LABEL_RESTART_STEAM_TITLE$e="Riavviare Steam?";var ACTION_RESTART_STEAM_LATER$e="Più tardi";var ACTION_RESTART_STEAM_NOW$e="Riavvia ora";var MSG_RESTART_STEAM_DESC$d="Steam ha bisogno di essere riavviato per applicare le modifiche.";var LABEL_GAME_SEARCH_TITLE$f="Cerca un titolo...";var LABEL_FILTER_MODAL_TITLE$f="Filtri {assetType}";var LABEL_FILTER_GAME$f="Titolo";var LABEL_FILTER_DIMENSIONS$f="Dimensioni";var LABEL_FILTER_STYLES$f="Stili";var LABEL_FILTER_FILE_TYPES$f="Tipi di file";var LABEL_FILTER_ANIMATION_TYPE_TITLE$f="Stili";var LABEL_FILTER_TYPE_ANIMATED$e="Animati";var LABEL_FILTER_TYPE_STATIC$e="Statici";var LABEL_FILTER_TAGS_TITLE$f="Tags";var LABEL_FILTER_TAG_NSFW$f="+18";var MSG_FILTER_TAG_NSFW_ENABLED$e="Forse dovresti controllarti alle spalle.";var LABEL_FILTER_TAG_HUMOR$e="Comico";var LABEL_FILTER_TAG_EPILEPSY$e="Epilessia";var LABEL_FILTER_TAG_UNTAGGED$e="Senza tag";var ACTION_FILTER_RESET$f="Resetta filtri";var LABEL_BEGGING_MODAL_TITLE$d="Grazie per usare SteamGridDB!";var LABEL_BEGGING_MODAL_DESC$c="Per favore, considera donare per aiutare con la manutenzione e il costo dei server!";var ACTION_HIDE_POS_GUIDES$d="Nascondi le guide";var ACTION_SHOW_OUTLINE$d="Mostra le guide";var ACTION_ADJUST_POS_SIZE$e="Cambia la dimensione";var ACTION_CHANGE_POS_LOGO_ANCHOR_POINT$9="Cambia punto di ancoraggio";var LABEL_ASSET_CURRENT$f="{assetType} corrente";var ACTION_ASSET_CUSTOM_CLEAR$f="Rimuovi personalizzazione";var ACTION_ASSET_BROWSE_LOCAL$e="Sfoglia i file locali";var ACTION_ASSET_APPLY_TRANSPARENT$e="Lascia vuoto";var LABEL_NOTES$f="Note";var LABEL_ANIMATED$e="Animato";var LABEL_NSFW$f="+18";var LABEL_HUMOR$e="Comico";var LABEL_EPILEPSY$e="Epilessia";var ACTION_OPEN_FILTER$f="Filtri";var ACTION_OPEN_OFFICIAL_ASSETS$e="{assetType} Ufficiale";var ACTION_ASSET_APPLY$e="Applica {assetType}";var MSG_GAME_SELECTED$e="Selezionato {gameName}";var MSG_ASSETS_FILTERED$e="Alcuni risultati potrebbero essere stati nascosti dai filtri";var MSG_GAME_SELECTED_AND_ASSETS_FILTERED$e="Filtrando titoli per {gameName}";var TITLE_MOTD_HIDE$a="Nascondere annuncio?";var LABEL_MOTD_THIS$a="Questo Annuncio";var LABEL_MOTD_ALL$a="Tutti gli annunci";var MSG_ASSET_APPLY_SUCCESS$e="{assetType} è stato applicato con successo!";var MSG_ASSET_APPLY_ERROR$e="Non sono riuscito ad applicare questo elemento.";var ACTION_OPEN_DETAILS$f="Dettagli";var it = {ASSET_TYPE_CAPSULE:ASSET_TYPE_CAPSULE$f,ASSET_TYPE_WIDECAPSULE:ASSET_TYPE_WIDECAPSULE$f,ASSET_TYPE_HERO:ASSET_TYPE_HERO$f,ASSET_TYPE_LOGO:ASSET_TYPE_LOGO$f,ASSET_TYPE_ICON:ASSET_TYPE_ICON$f,LABEL_TAB_CAPSULE:LABEL_TAB_CAPSULE$f,LABEL_TAB_WIDECAPSULE:LABEL_TAB_WIDECAPSULE$f,LABEL_TAB_HERO:LABEL_TAB_HERO$f,LABEL_TAB_LOGO:LABEL_TAB_LOGO$f,LABEL_TAB_ICON:LABEL_TAB_ICON$f,LABEL_TAB_MANAGE:LABEL_TAB_MANAGE$f,MSG_USAGE_INSTRUCTIONS:MSG_USAGE_INSTRUCTIONS$e,ACTION_CHANGE_ARTWORK:ACTION_CHANGE_ARTWORK$f,ACTION_SHOW_LINK_QR:ACTION_SHOW_LINK_QR$f,MSG_ASSET_TAB_SETTINGS_DESC:MSG_ASSET_TAB_SETTINGS_DESC$d,LABEL_USAGE_TITLE:LABEL_USAGE_TITLE$e,LABEL_SQUARE_CAPSULES:LABEL_SQUARE_CAPSULES$d,LABEL_SQUARE_CAPSULES_DESC:LABEL_SQUARE_CAPSULES_DESC$c,LABEL_UNIFORM_RECENT:LABEL_UNIFORM_RECENT$9,LABEL_UNIFORM_RECENT_DESC:LABEL_UNIFORM_RECENT_DESC$9,LABEL_CAPSULE_GLOW:LABEL_CAPSULE_GLOW$d,LABEL_CAPSULE_GLOW_DESC:LABEL_CAPSULE_GLOW_DESC$c,LABEL_CAPSULE_GLOW_OFF:LABEL_CAPSULE_GLOW_OFF$d,LABEL_SETTINGS_ASSET_TABS:LABEL_SETTINGS_ASSET_TABS$d,LABEL_SETTINGS_DISABLE_MOTD:LABEL_SETTINGS_DISABLE_MOTD$b,LABEL_SETTINGS_DISABLE_MOTD_DESC:LABEL_SETTINGS_DISABLE_MOTD_DESC$a,LABEL_TRANSLATION_CREDIT_TITLE:LABEL_TRANSLATION_CREDIT_TITLE$f,LABEL_MORE_SGDB_TITLE:LABEL_MORE_SGDB_TITLE$f,ACTION_SGDB_DISCORD:ACTION_SGDB_DISCORD$f,ACTION_SGDB_GITHUB:ACTION_SGDB_GITHUB$e,ACTION_SGDB_DONATE:ACTION_SGDB_DONATE$f,ACTION_SGDB_TRANSLATE:ACTION_SGDB_TRANSLATE$f,ACTION_SGDB_BOOP:ACTION_SGDB_BOOP$f,LABEL_RESTART_STEAM_TITLE:LABEL_RESTART_STEAM_TITLE$e,ACTION_RESTART_STEAM_LATER:ACTION_RESTART_STEAM_LATER$e,ACTION_RESTART_STEAM_NOW:ACTION_RESTART_STEAM_NOW$e,MSG_RESTART_STEAM_DESC:MSG_RESTART_STEAM_DESC$d,LABEL_GAME_SEARCH_TITLE:LABEL_GAME_SEARCH_TITLE$f,LABEL_FILTER_MODAL_TITLE:LABEL_FILTER_MODAL_TITLE$f,LABEL_FILTER_GAME:LABEL_FILTER_GAME$f,LABEL_FILTER_DIMENSIONS:LABEL_FILTER_DIMENSIONS$f,LABEL_FILTER_STYLES:LABEL_FILTER_STYLES$f,LABEL_FILTER_FILE_TYPES:LABEL_FILTER_FILE_TYPES$f,LABEL_FILTER_ANIMATION_TYPE_TITLE:LABEL_FILTER_ANIMATION_TYPE_TITLE$f,LABEL_FILTER_TYPE_ANIMATED:LABEL_FILTER_TYPE_ANIMATED$e,LABEL_FILTER_TYPE_STATIC:LABEL_FILTER_TYPE_STATIC$e,LABEL_FILTER_TAGS_TITLE:LABEL_FILTER_TAGS_TITLE$f,LABEL_FILTER_TAG_NSFW:LABEL_FILTER_TAG_NSFW$f,MSG_FILTER_TAG_NSFW_ENABLED:MSG_FILTER_TAG_NSFW_ENABLED$e,LABEL_FILTER_TAG_HUMOR:LABEL_FILTER_TAG_HUMOR$e,LABEL_FILTER_TAG_EPILEPSY:LABEL_FILTER_TAG_EPILEPSY$e,LABEL_FILTER_TAG_UNTAGGED:LABEL_FILTER_TAG_UNTAGGED$e,ACTION_FILTER_RESET:ACTION_FILTER_RESET$f,LABEL_BEGGING_MODAL_TITLE:LABEL_BEGGING_MODAL_TITLE$d,LABEL_BEGGING_MODAL_DESC:LABEL_BEGGING_MODAL_DESC$c,ACTION_HIDE_POS_GUIDES:ACTION_HIDE_POS_GUIDES$d,ACTION_SHOW_OUTLINE:ACTION_SHOW_OUTLINE$d,ACTION_ADJUST_POS_SIZE:ACTION_ADJUST_POS_SIZE$e,ACTION_CHANGE_POS_LOGO_ANCHOR_POINT:ACTION_CHANGE_POS_LOGO_ANCHOR_POINT$9,LABEL_ASSET_CURRENT:LABEL_ASSET_CURRENT$f,ACTION_ASSET_CUSTOM_CLEAR:ACTION_ASSET_CUSTOM_CLEAR$f,ACTION_ASSET_BROWSE_LOCAL:ACTION_ASSET_BROWSE_LOCAL$e,ACTION_ASSET_APPLY_TRANSPARENT:ACTION_ASSET_APPLY_TRANSPARENT$e,LABEL_NOTES:LABEL_NOTES$f,LABEL_ANIMATED:LABEL_ANIMATED$e,LABEL_NSFW:LABEL_NSFW$f,LABEL_HUMOR:LABEL_HUMOR$e,LABEL_EPILEPSY:LABEL_EPILEPSY$e,ACTION_OPEN_FILTER:ACTION_OPEN_FILTER$f,ACTION_OPEN_OFFICIAL_ASSETS:ACTION_OPEN_OFFICIAL_ASSETS$e,ACTION_ASSET_APPLY:ACTION_ASSET_APPLY$e,MSG_GAME_SELECTED:MSG_GAME_SELECTED$e,MSG_ASSETS_FILTERED:MSG_ASSETS_FILTERED$e,MSG_GAME_SELECTED_AND_ASSETS_FILTERED:MSG_GAME_SELECTED_AND_ASSETS_FILTERED$e,TITLE_MOTD_HIDE:TITLE_MOTD_HIDE$a,LABEL_MOTD_THIS:LABEL_MOTD_THIS$a,LABEL_MOTD_ALL:LABEL_MOTD_ALL$a,MSG_ASSET_APPLY_SUCCESS:MSG_ASSET_APPLY_SUCCESS$e,MSG_ASSET_APPLY_ERROR:MSG_ASSET_APPLY_ERROR$e,ACTION_OPEN_DETAILS:ACTION_OPEN_DETAILS$f};

var it$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    ACTION_ADJUST_POS_SIZE: ACTION_ADJUST_POS_SIZE$e,
    ACTION_ASSET_APPLY: ACTION_ASSET_APPLY$e,
    ACTION_ASSET_APPLY_TRANSPARENT: ACTION_ASSET_APPLY_TRANSPARENT$e,
    ACTION_ASSET_BROWSE_LOCAL: ACTION_ASSET_BROWSE_LOCAL$e,
    ACTION_ASSET_CUSTOM_CLEAR: ACTION_ASSET_CUSTOM_CLEAR$f,
    ACTION_CHANGE_ARTWORK: ACTION_CHANGE_ARTWORK$f,
    ACTION_CHANGE_POS_LOGO_ANCHOR_POINT: ACTION_CHANGE_POS_LOGO_ANCHOR_POINT$9,
    ACTION_FILTER_RESET: ACTION_FILTER_RESET$f,
    ACTION_HIDE_POS_GUIDES: ACTION_HIDE_POS_GUIDES$d,
    ACTION_OPEN_DETAILS: ACTION_OPEN_DETAILS$f,
    ACTION_OPEN_FILTER: ACTION_OPEN_FILTER$f,
    ACTION_OPEN_OFFICIAL_ASSETS: ACTION_OPEN_OFFICIAL_ASSETS$e,
    ACTION_RESTART_STEAM_LATER: ACTION_RESTART_STEAM_LATER$e,
    ACTION_RESTART_STEAM_NOW: ACTION_RESTART_STEAM_NOW$e,
    ACTION_SGDB_BOOP: ACTION_SGDB_BOOP$f,
    ACTION_SGDB_DISCORD: ACTION_SGDB_DISCORD$f,
    ACTION_SGDB_DONATE: ACTION_SGDB_DONATE$f,
    ACTION_SGDB_GITHUB: ACTION_SGDB_GITHUB$e,
    ACTION_SGDB_TRANSLATE: ACTION_SGDB_TRANSLATE$f,
    ACTION_SHOW_LINK_QR: ACTION_SHOW_LINK_QR$f,
    ACTION_SHOW_OUTLINE: ACTION_SHOW_OUTLINE$d,
    ASSET_TYPE_CAPSULE: ASSET_TYPE_CAPSULE$f,
    ASSET_TYPE_HERO: ASSET_TYPE_HERO$f,
    ASSET_TYPE_ICON: ASSET_TYPE_ICON$f,
    ASSET_TYPE_LOGO: ASSET_TYPE_LOGO$f,
    ASSET_TYPE_WIDECAPSULE: ASSET_TYPE_WIDECAPSULE$f,
    LABEL_ANIMATED: LABEL_ANIMATED$e,
    LABEL_ASSET_CURRENT: LABEL_ASSET_CURRENT$f,
    LABEL_BEGGING_MODAL_DESC: LABEL_BEGGING_MODAL_DESC$c,
    LABEL_BEGGING_MODAL_TITLE: LABEL_BEGGING_MODAL_TITLE$d,
    LABEL_CAPSULE_GLOW: LABEL_CAPSULE_GLOW$d,
    LABEL_CAPSULE_GLOW_DESC: LABEL_CAPSULE_GLOW_DESC$c,
    LABEL_CAPSULE_GLOW_OFF: LABEL_CAPSULE_GLOW_OFF$d,
    LABEL_EPILEPSY: LABEL_EPILEPSY$e,
    LABEL_FILTER_ANIMATION_TYPE_TITLE: LABEL_FILTER_ANIMATION_TYPE_TITLE$f,
    LABEL_FILTER_DIMENSIONS: LABEL_FILTER_DIMENSIONS$f,
    LABEL_FILTER_FILE_TYPES: LABEL_FILTER_FILE_TYPES$f,
    LABEL_FILTER_GAME: LABEL_FILTER_GAME$f,
    LABEL_FILTER_MODAL_TITLE: LABEL_FILTER_MODAL_TITLE$f,
    LABEL_FILTER_STYLES: LABEL_FILTER_STYLES$f,
    LABEL_FILTER_TAGS_TITLE: LABEL_FILTER_TAGS_TITLE$f,
    LABEL_FILTER_TAG_EPILEPSY: LABEL_FILTER_TAG_EPILEPSY$e,
    LABEL_FILTER_TAG_HUMOR: LABEL_FILTER_TAG_HUMOR$e,
    LABEL_FILTER_TAG_NSFW: LABEL_FILTER_TAG_NSFW$f,
    LABEL_FILTER_TAG_UNTAGGED: LABEL_FILTER_TAG_UNTAGGED$e,
    LABEL_FILTER_TYPE_ANIMATED: LABEL_FILTER_TYPE_ANIMATED$e,
    LABEL_FILTER_TYPE_STATIC: LABEL_FILTER_TYPE_STATIC$e,
    LABEL_GAME_SEARCH_TITLE: LABEL_GAME_SEARCH_TITLE$f,
    LABEL_HUMOR: LABEL_HUMOR$e,
    LABEL_MORE_SGDB_TITLE: LABEL_MORE_SGDB_TITLE$f,
    LABEL_MOTD_ALL: LABEL_MOTD_ALL$a,
    LABEL_MOTD_THIS: LABEL_MOTD_THIS$a,
    LABEL_NOTES: LABEL_NOTES$f,
    LABEL_NSFW: LABEL_NSFW$f,
    LABEL_RESTART_STEAM_TITLE: LABEL_RESTART_STEAM_TITLE$e,
    LABEL_SETTINGS_ASSET_TABS: LABEL_SETTINGS_ASSET_TABS$d,
    LABEL_SETTINGS_DISABLE_MOTD: LABEL_SETTINGS_DISABLE_MOTD$b,
    LABEL_SETTINGS_DISABLE_MOTD_DESC: LABEL_SETTINGS_DISABLE_MOTD_DESC$a,
    LABEL_SQUARE_CAPSULES: LABEL_SQUARE_CAPSULES$d,
    LABEL_SQUARE_CAPSULES_DESC: LABEL_SQUARE_CAPSULES_DESC$c,
    LABEL_TAB_CAPSULE: LABEL_TAB_CAPSULE$f,
    LABEL_TAB_HERO: LABEL_TAB_HERO$f,
    LABEL_TAB_ICON: LABEL_TAB_ICON$f,
    LABEL_TAB_LOGO: LABEL_TAB_LOGO$f,
    LABEL_TAB_MANAGE: LABEL_TAB_MANAGE$f,
    LABEL_TAB_WIDECAPSULE: LABEL_TAB_WIDECAPSULE$f,
    LABEL_TRANSLATION_CREDIT_TITLE: LABEL_TRANSLATION_CREDIT_TITLE$f,
    LABEL_UNIFORM_RECENT: LABEL_UNIFORM_RECENT$9,
    LABEL_UNIFORM_RECENT_DESC: LABEL_UNIFORM_RECENT_DESC$9,
    LABEL_USAGE_TITLE: LABEL_USAGE_TITLE$e,
    MSG_ASSETS_FILTERED: MSG_ASSETS_FILTERED$e,
    MSG_ASSET_APPLY_ERROR: MSG_ASSET_APPLY_ERROR$e,
    MSG_ASSET_APPLY_SUCCESS: MSG_ASSET_APPLY_SUCCESS$e,
    MSG_ASSET_TAB_SETTINGS_DESC: MSG_ASSET_TAB_SETTINGS_DESC$d,
    MSG_FILTER_TAG_NSFW_ENABLED: MSG_FILTER_TAG_NSFW_ENABLED$e,
    MSG_GAME_SELECTED: MSG_GAME_SELECTED$e,
    MSG_GAME_SELECTED_AND_ASSETS_FILTERED: MSG_GAME_SELECTED_AND_ASSETS_FILTERED$e,
    MSG_RESTART_STEAM_DESC: MSG_RESTART_STEAM_DESC$d,
    MSG_USAGE_INSTRUCTIONS: MSG_USAGE_INSTRUCTIONS$e,
    TITLE_MOTD_HIDE: TITLE_MOTD_HIDE$a,
    default: it
});

var ASSET_TYPE_CAPSULE$e="カプセル";var ASSET_TYPE_WIDECAPSULE$e="ワイドカプセル";var ASSET_TYPE_HERO$e="ヒーロー";var ASSET_TYPE_LOGO$e="ロゴ";var ASSET_TYPE_ICON$e="アイコン";var LABEL_TAB_CAPSULE$e="カプセル";var LABEL_TAB_WIDECAPSULE$e="ワイドカプセル";var LABEL_TAB_HERO$e="ヒーロー";var LABEL_TAB_LOGO$e="ロゴ";var LABEL_TAB_ICON$e="アイコン";var LABEL_TAB_MANAGE$e="管理";var MSG_USAGE_INSTRUCTIONS$d="ゲームを選択 {arrow} {optionsButton} {arrow}「{ACTION_CHANGE_ARTWORK}」";var ACTION_CHANGE_ARTWORK$e="アートワークを変える…";var ACTION_SHOW_LINK_QR$e="QRコード表示";var MSG_ASSET_TAB_SETTINGS_DESC$c="未使用のタブの順序を変更または非表示にし、「{ACTION_CHANGE_ARTWORK}」を使用するときに開くデフォルトのタブを設定します";var LABEL_USAGE_TITLE$d="迷ったの？ご利用方法はこちら";var LABEL_SQUARE_CAPSULES$c="正方形カプセル";var LABEL_SQUARE_CAPSULES_DESC$b="縦方向のカプセルの代わりに正方形カプセルを使用する。正方形フィルターは自動的に選択されます。";var LABEL_CAPSULE_GLOW$c="カプセルグロー";var LABEL_CAPSULE_GLOW_DESC$b="ライブラリ内のカプセルの輝き強度を調整します";var LABEL_CAPSULE_GLOW_OFF$c="なし";var LABEL_SETTINGS_ASSET_TABS$c="画像タブ設定";var LABEL_SETTINGS_DISABLE_MOTD$a="お知らせを無効にする";var LABEL_SETTINGS_DISABLE_MOTD_DESC$9="お知らせは重要な情報やコミュニティイベントを表示するために控えめに使用されます。";var LABEL_TRANSLATION_CREDIT_TITLE$e="日本語訳";var LABEL_MORE_SGDB_TITLE$e="その他のSteamGridDBのもの";var ACTION_SGDB_DISCORD$e="Discordに参加";var ACTION_SGDB_GITHUB$d="オープンソースプロジェクト";var ACTION_SGDB_DONATE$e="Patreonで支援";var ACTION_SGDB_TRANSLATE$e="翻訳を手伝う";var ACTION_SGDB_BOOP$e="SGDBoopを試してみる";var LABEL_RESTART_STEAM_TITLE$d="Steamを再起動しますか？";var ACTION_RESTART_STEAM_LATER$d="後で再起動";var ACTION_RESTART_STEAM_NOW$d="今すぐ再起動";var MSG_RESTART_STEAM_DESC$c="変更を反映するにはSteamを再起動する必要があります。";var LABEL_GAME_SEARCH_TITLE$e="ゲームを検索…";var LABEL_FILTER_MODAL_TITLE$e="{assetType}フィルター";var LABEL_FILTER_GAME$e="ゲーム";var LABEL_FILTER_DIMENSIONS$e="サイズ";var LABEL_FILTER_STYLES$e="スタイル";var LABEL_FILTER_FILE_TYPES$e="ファイルタイプ";var LABEL_FILTER_ANIMATION_TYPE_TITLE$e="タイプ";var LABEL_FILTER_TYPE_ANIMATED$d="アニメーション";var LABEL_FILTER_TYPE_STATIC$d="静止画";var LABEL_FILTER_TAGS_TITLE$e="タグ";var LABEL_FILTER_TAG_NSFW$e="成人向け";var MSG_FILTER_TAG_NSFW_ENABLED$d="誰もいないか確認しようかな？";var LABEL_FILTER_TAG_HUMOR$d="ユーモア";var LABEL_FILTER_TAG_EPILEPSY$d="てんかん";var LABEL_FILTER_TAG_UNTAGGED$d="タグなし";var ACTION_FILTER_RESET$e="フィルターをリセット";var LABEL_BEGGING_MODAL_TITLE$c="SteamGridDBをご利用いただき、ありがとうございます！";var LABEL_BEGGING_MODAL_DESC$b="メンテナンスやサーバーの費用を支援するために寄付を検討してください!";var ACTION_HIDE_POS_GUIDES$c="補助線を非表示";var ACTION_SHOW_OUTLINE$c="補助線を表示";var ACTION_ADJUST_POS_SIZE$d="サイズを調整";var ACTION_CHANGE_POS_LOGO_ANCHOR_POINT$8="相対位置点を変更";var LABEL_ASSET_CURRENT$e="現在の{assetType}";var ACTION_ASSET_CUSTOM_CLEAR$e="カスタム画像を消去";var ACTION_ASSET_BROWSE_LOCAL$d="ローカルファイルを参照";var ACTION_ASSET_APPLY_TRANSPARENT$d="不可視画像を適用";var LABEL_NOTES$e="メモ";var LABEL_ANIMATED$d="アニメーション";var LABEL_NSFW$e="成人向け";var LABEL_HUMOR$d="ユーモア";var LABEL_EPILEPSY$d="てんかん";var ACTION_OPEN_FILTER$e="フィルター";var ACTION_OPEN_OFFICIAL_ASSETS$d="公式{assetType}";var ACTION_ASSET_APPLY$d="{assetType}を適用";var MSG_GAME_SELECTED$d="{gameName}を選択中";var MSG_ASSETS_FILTERED$d="フィルターにより一部の画像が非表示になる可能性があります";var MSG_GAME_SELECTED_AND_ASSETS_FILTERED$d="フィルター付きで{gameName}を選択中";var TITLE_MOTD_HIDE$9="どんなお知らせを非表示にしますか？";var LABEL_MOTD_THIS$9="このお知らせ";var LABEL_MOTD_ALL$9="全てのお知らせ";var MSG_ASSET_APPLY_SUCCESS$d="{assetType}が正常に適用されました！";var MSG_ASSET_APPLY_ERROR$d="この画像を適用する際に問題が発生しました";var ACTION_OPEN_DETAILS$e="詳細";var ja = {ASSET_TYPE_CAPSULE:ASSET_TYPE_CAPSULE$e,ASSET_TYPE_WIDECAPSULE:ASSET_TYPE_WIDECAPSULE$e,ASSET_TYPE_HERO:ASSET_TYPE_HERO$e,ASSET_TYPE_LOGO:ASSET_TYPE_LOGO$e,ASSET_TYPE_ICON:ASSET_TYPE_ICON$e,LABEL_TAB_CAPSULE:LABEL_TAB_CAPSULE$e,LABEL_TAB_WIDECAPSULE:LABEL_TAB_WIDECAPSULE$e,LABEL_TAB_HERO:LABEL_TAB_HERO$e,LABEL_TAB_LOGO:LABEL_TAB_LOGO$e,LABEL_TAB_ICON:LABEL_TAB_ICON$e,LABEL_TAB_MANAGE:LABEL_TAB_MANAGE$e,MSG_USAGE_INSTRUCTIONS:MSG_USAGE_INSTRUCTIONS$d,ACTION_CHANGE_ARTWORK:ACTION_CHANGE_ARTWORK$e,ACTION_SHOW_LINK_QR:ACTION_SHOW_LINK_QR$e,MSG_ASSET_TAB_SETTINGS_DESC:MSG_ASSET_TAB_SETTINGS_DESC$c,LABEL_USAGE_TITLE:LABEL_USAGE_TITLE$d,LABEL_SQUARE_CAPSULES:LABEL_SQUARE_CAPSULES$c,LABEL_SQUARE_CAPSULES_DESC:LABEL_SQUARE_CAPSULES_DESC$b,LABEL_CAPSULE_GLOW:LABEL_CAPSULE_GLOW$c,LABEL_CAPSULE_GLOW_DESC:LABEL_CAPSULE_GLOW_DESC$b,LABEL_CAPSULE_GLOW_OFF:LABEL_CAPSULE_GLOW_OFF$c,LABEL_SETTINGS_ASSET_TABS:LABEL_SETTINGS_ASSET_TABS$c,LABEL_SETTINGS_DISABLE_MOTD:LABEL_SETTINGS_DISABLE_MOTD$a,LABEL_SETTINGS_DISABLE_MOTD_DESC:LABEL_SETTINGS_DISABLE_MOTD_DESC$9,LABEL_TRANSLATION_CREDIT_TITLE:LABEL_TRANSLATION_CREDIT_TITLE$e,LABEL_MORE_SGDB_TITLE:LABEL_MORE_SGDB_TITLE$e,ACTION_SGDB_DISCORD:ACTION_SGDB_DISCORD$e,ACTION_SGDB_GITHUB:ACTION_SGDB_GITHUB$d,ACTION_SGDB_DONATE:ACTION_SGDB_DONATE$e,ACTION_SGDB_TRANSLATE:ACTION_SGDB_TRANSLATE$e,ACTION_SGDB_BOOP:ACTION_SGDB_BOOP$e,LABEL_RESTART_STEAM_TITLE:LABEL_RESTART_STEAM_TITLE$d,ACTION_RESTART_STEAM_LATER:ACTION_RESTART_STEAM_LATER$d,ACTION_RESTART_STEAM_NOW:ACTION_RESTART_STEAM_NOW$d,MSG_RESTART_STEAM_DESC:MSG_RESTART_STEAM_DESC$c,LABEL_GAME_SEARCH_TITLE:LABEL_GAME_SEARCH_TITLE$e,LABEL_FILTER_MODAL_TITLE:LABEL_FILTER_MODAL_TITLE$e,LABEL_FILTER_GAME:LABEL_FILTER_GAME$e,LABEL_FILTER_DIMENSIONS:LABEL_FILTER_DIMENSIONS$e,LABEL_FILTER_STYLES:LABEL_FILTER_STYLES$e,LABEL_FILTER_FILE_TYPES:LABEL_FILTER_FILE_TYPES$e,LABEL_FILTER_ANIMATION_TYPE_TITLE:LABEL_FILTER_ANIMATION_TYPE_TITLE$e,LABEL_FILTER_TYPE_ANIMATED:LABEL_FILTER_TYPE_ANIMATED$d,LABEL_FILTER_TYPE_STATIC:LABEL_FILTER_TYPE_STATIC$d,LABEL_FILTER_TAGS_TITLE:LABEL_FILTER_TAGS_TITLE$e,LABEL_FILTER_TAG_NSFW:LABEL_FILTER_TAG_NSFW$e,MSG_FILTER_TAG_NSFW_ENABLED:MSG_FILTER_TAG_NSFW_ENABLED$d,LABEL_FILTER_TAG_HUMOR:LABEL_FILTER_TAG_HUMOR$d,LABEL_FILTER_TAG_EPILEPSY:LABEL_FILTER_TAG_EPILEPSY$d,LABEL_FILTER_TAG_UNTAGGED:LABEL_FILTER_TAG_UNTAGGED$d,ACTION_FILTER_RESET:ACTION_FILTER_RESET$e,LABEL_BEGGING_MODAL_TITLE:LABEL_BEGGING_MODAL_TITLE$c,LABEL_BEGGING_MODAL_DESC:LABEL_BEGGING_MODAL_DESC$b,ACTION_HIDE_POS_GUIDES:ACTION_HIDE_POS_GUIDES$c,ACTION_SHOW_OUTLINE:ACTION_SHOW_OUTLINE$c,ACTION_ADJUST_POS_SIZE:ACTION_ADJUST_POS_SIZE$d,ACTION_CHANGE_POS_LOGO_ANCHOR_POINT:ACTION_CHANGE_POS_LOGO_ANCHOR_POINT$8,LABEL_ASSET_CURRENT:LABEL_ASSET_CURRENT$e,ACTION_ASSET_CUSTOM_CLEAR:ACTION_ASSET_CUSTOM_CLEAR$e,ACTION_ASSET_BROWSE_LOCAL:ACTION_ASSET_BROWSE_LOCAL$d,ACTION_ASSET_APPLY_TRANSPARENT:ACTION_ASSET_APPLY_TRANSPARENT$d,LABEL_NOTES:LABEL_NOTES$e,LABEL_ANIMATED:LABEL_ANIMATED$d,LABEL_NSFW:LABEL_NSFW$e,LABEL_HUMOR:LABEL_HUMOR$d,LABEL_EPILEPSY:LABEL_EPILEPSY$d,ACTION_OPEN_FILTER:ACTION_OPEN_FILTER$e,ACTION_OPEN_OFFICIAL_ASSETS:ACTION_OPEN_OFFICIAL_ASSETS$d,ACTION_ASSET_APPLY:ACTION_ASSET_APPLY$d,MSG_GAME_SELECTED:MSG_GAME_SELECTED$d,MSG_ASSETS_FILTERED:MSG_ASSETS_FILTERED$d,MSG_GAME_SELECTED_AND_ASSETS_FILTERED:MSG_GAME_SELECTED_AND_ASSETS_FILTERED$d,TITLE_MOTD_HIDE:TITLE_MOTD_HIDE$9,LABEL_MOTD_THIS:LABEL_MOTD_THIS$9,LABEL_MOTD_ALL:LABEL_MOTD_ALL$9,MSG_ASSET_APPLY_SUCCESS:MSG_ASSET_APPLY_SUCCESS$d,MSG_ASSET_APPLY_ERROR:MSG_ASSET_APPLY_ERROR$d,ACTION_OPEN_DETAILS:ACTION_OPEN_DETAILS$e};

var ja$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    ACTION_ADJUST_POS_SIZE: ACTION_ADJUST_POS_SIZE$d,
    ACTION_ASSET_APPLY: ACTION_ASSET_APPLY$d,
    ACTION_ASSET_APPLY_TRANSPARENT: ACTION_ASSET_APPLY_TRANSPARENT$d,
    ACTION_ASSET_BROWSE_LOCAL: ACTION_ASSET_BROWSE_LOCAL$d,
    ACTION_ASSET_CUSTOM_CLEAR: ACTION_ASSET_CUSTOM_CLEAR$e,
    ACTION_CHANGE_ARTWORK: ACTION_CHANGE_ARTWORK$e,
    ACTION_CHANGE_POS_LOGO_ANCHOR_POINT: ACTION_CHANGE_POS_LOGO_ANCHOR_POINT$8,
    ACTION_FILTER_RESET: ACTION_FILTER_RESET$e,
    ACTION_HIDE_POS_GUIDES: ACTION_HIDE_POS_GUIDES$c,
    ACTION_OPEN_DETAILS: ACTION_OPEN_DETAILS$e,
    ACTION_OPEN_FILTER: ACTION_OPEN_FILTER$e,
    ACTION_OPEN_OFFICIAL_ASSETS: ACTION_OPEN_OFFICIAL_ASSETS$d,
    ACTION_RESTART_STEAM_LATER: ACTION_RESTART_STEAM_LATER$d,
    ACTION_RESTART_STEAM_NOW: ACTION_RESTART_STEAM_NOW$d,
    ACTION_SGDB_BOOP: ACTION_SGDB_BOOP$e,
    ACTION_SGDB_DISCORD: ACTION_SGDB_DISCORD$e,
    ACTION_SGDB_DONATE: ACTION_SGDB_DONATE$e,
    ACTION_SGDB_GITHUB: ACTION_SGDB_GITHUB$d,
    ACTION_SGDB_TRANSLATE: ACTION_SGDB_TRANSLATE$e,
    ACTION_SHOW_LINK_QR: ACTION_SHOW_LINK_QR$e,
    ACTION_SHOW_OUTLINE: ACTION_SHOW_OUTLINE$c,
    ASSET_TYPE_CAPSULE: ASSET_TYPE_CAPSULE$e,
    ASSET_TYPE_HERO: ASSET_TYPE_HERO$e,
    ASSET_TYPE_ICON: ASSET_TYPE_ICON$e,
    ASSET_TYPE_LOGO: ASSET_TYPE_LOGO$e,
    ASSET_TYPE_WIDECAPSULE: ASSET_TYPE_WIDECAPSULE$e,
    LABEL_ANIMATED: LABEL_ANIMATED$d,
    LABEL_ASSET_CURRENT: LABEL_ASSET_CURRENT$e,
    LABEL_BEGGING_MODAL_DESC: LABEL_BEGGING_MODAL_DESC$b,
    LABEL_BEGGING_MODAL_TITLE: LABEL_BEGGING_MODAL_TITLE$c,
    LABEL_CAPSULE_GLOW: LABEL_CAPSULE_GLOW$c,
    LABEL_CAPSULE_GLOW_DESC: LABEL_CAPSULE_GLOW_DESC$b,
    LABEL_CAPSULE_GLOW_OFF: LABEL_CAPSULE_GLOW_OFF$c,
    LABEL_EPILEPSY: LABEL_EPILEPSY$d,
    LABEL_FILTER_ANIMATION_TYPE_TITLE: LABEL_FILTER_ANIMATION_TYPE_TITLE$e,
    LABEL_FILTER_DIMENSIONS: LABEL_FILTER_DIMENSIONS$e,
    LABEL_FILTER_FILE_TYPES: LABEL_FILTER_FILE_TYPES$e,
    LABEL_FILTER_GAME: LABEL_FILTER_GAME$e,
    LABEL_FILTER_MODAL_TITLE: LABEL_FILTER_MODAL_TITLE$e,
    LABEL_FILTER_STYLES: LABEL_FILTER_STYLES$e,
    LABEL_FILTER_TAGS_TITLE: LABEL_FILTER_TAGS_TITLE$e,
    LABEL_FILTER_TAG_EPILEPSY: LABEL_FILTER_TAG_EPILEPSY$d,
    LABEL_FILTER_TAG_HUMOR: LABEL_FILTER_TAG_HUMOR$d,
    LABEL_FILTER_TAG_NSFW: LABEL_FILTER_TAG_NSFW$e,
    LABEL_FILTER_TAG_UNTAGGED: LABEL_FILTER_TAG_UNTAGGED$d,
    LABEL_FILTER_TYPE_ANIMATED: LABEL_FILTER_TYPE_ANIMATED$d,
    LABEL_FILTER_TYPE_STATIC: LABEL_FILTER_TYPE_STATIC$d,
    LABEL_GAME_SEARCH_TITLE: LABEL_GAME_SEARCH_TITLE$e,
    LABEL_HUMOR: LABEL_HUMOR$d,
    LABEL_MORE_SGDB_TITLE: LABEL_MORE_SGDB_TITLE$e,
    LABEL_MOTD_ALL: LABEL_MOTD_ALL$9,
    LABEL_MOTD_THIS: LABEL_MOTD_THIS$9,
    LABEL_NOTES: LABEL_NOTES$e,
    LABEL_NSFW: LABEL_NSFW$e,
    LABEL_RESTART_STEAM_TITLE: LABEL_RESTART_STEAM_TITLE$d,
    LABEL_SETTINGS_ASSET_TABS: LABEL_SETTINGS_ASSET_TABS$c,
    LABEL_SETTINGS_DISABLE_MOTD: LABEL_SETTINGS_DISABLE_MOTD$a,
    LABEL_SETTINGS_DISABLE_MOTD_DESC: LABEL_SETTINGS_DISABLE_MOTD_DESC$9,
    LABEL_SQUARE_CAPSULES: LABEL_SQUARE_CAPSULES$c,
    LABEL_SQUARE_CAPSULES_DESC: LABEL_SQUARE_CAPSULES_DESC$b,
    LABEL_TAB_CAPSULE: LABEL_TAB_CAPSULE$e,
    LABEL_TAB_HERO: LABEL_TAB_HERO$e,
    LABEL_TAB_ICON: LABEL_TAB_ICON$e,
    LABEL_TAB_LOGO: LABEL_TAB_LOGO$e,
    LABEL_TAB_MANAGE: LABEL_TAB_MANAGE$e,
    LABEL_TAB_WIDECAPSULE: LABEL_TAB_WIDECAPSULE$e,
    LABEL_TRANSLATION_CREDIT_TITLE: LABEL_TRANSLATION_CREDIT_TITLE$e,
    LABEL_USAGE_TITLE: LABEL_USAGE_TITLE$d,
    MSG_ASSETS_FILTERED: MSG_ASSETS_FILTERED$d,
    MSG_ASSET_APPLY_ERROR: MSG_ASSET_APPLY_ERROR$d,
    MSG_ASSET_APPLY_SUCCESS: MSG_ASSET_APPLY_SUCCESS$d,
    MSG_ASSET_TAB_SETTINGS_DESC: MSG_ASSET_TAB_SETTINGS_DESC$c,
    MSG_FILTER_TAG_NSFW_ENABLED: MSG_FILTER_TAG_NSFW_ENABLED$d,
    MSG_GAME_SELECTED: MSG_GAME_SELECTED$d,
    MSG_GAME_SELECTED_AND_ASSETS_FILTERED: MSG_GAME_SELECTED_AND_ASSETS_FILTERED$d,
    MSG_RESTART_STEAM_DESC: MSG_RESTART_STEAM_DESC$c,
    MSG_USAGE_INSTRUCTIONS: MSG_USAGE_INSTRUCTIONS$d,
    TITLE_MOTD_HIDE: TITLE_MOTD_HIDE$9,
    default: ja
});

var ASSET_TYPE_CAPSULE$d="캡슐";var ASSET_TYPE_WIDECAPSULE$d="넓은 캡슐";var ASSET_TYPE_HERO$d="히어로";var ASSET_TYPE_LOGO$d="로고";var ASSET_TYPE_ICON$d="아이콘";var LABEL_TAB_CAPSULE$d="캡슐";var LABEL_TAB_WIDECAPSULE$d="넓은 캡슐";var LABEL_TAB_HERO$d="히어로";var LABEL_TAB_LOGO$d="로고";var LABEL_TAB_ICON$d="아이콘";var LABEL_TAB_MANAGE$d="관리";var MSG_USAGE_INSTRUCTIONS$c="게임 고르기 {arrow} {optionsButton} {arrow} \"{ACTION_CHANGE_ARTWORK}\"";var ACTION_CHANGE_ARTWORK$d="이미지 변경...";var ACTION_SHOW_LINK_QR$d="링크 QR코드 보이기";var MSG_ASSET_TAB_SETTINGS_DESC$b="사용하지 않는 탭을 재정렬하거나 숨기고, \"{ACTION_CHANGE_ARTWORK}\"을 사용할 때 기본으로 열리는 탭을 변경합니다.";var LABEL_USAGE_TITLE$c="사용법을 모르시겠나요? 여기를 읽어보세요.";var LABEL_SQUARE_CAPSULES$b="정사각형 캡슐";var LABEL_SQUARE_CAPSULES_DESC$a="세로 대신 정사각형 캡슐을 사용합니다. 정사각형 필터가 자동으로 선택됩니다.";var LABEL_UNIFORM_RECENT$8="최근 캡슐과 맞추기";var LABEL_UNIFORM_RECENT_DESC$8="홈 화면에서 가장 최근에 플레이한 게임의 캡슐이 최근 캡슐들과 일치하게 합니다.";var LABEL_CAPSULE_GLOW$b="캡슐 강조 밝기";var LABEL_CAPSULE_GLOW_DESC$a="라이브러리의 캡슐 강조표시의 밝기를 조절합니다";var LABEL_CAPSULE_GLOW_OFF$b="없음";var LABEL_SETTINGS_ASSET_TABS$b="애셋 탭 설정";var LABEL_SETTINGS_DISABLE_MOTD$9="알림 비활성화";var LABEL_SETTINGS_DISABLE_MOTD_DESC$8="알림이 중요한 정보나 커뮤니티 이벤트를 표시할  때만 사용됩니다.";var LABEL_TRANSLATION_CREDIT_TITLE$d="한국어 번역가";var LABEL_MORE_SGDB_TITLE$d="SteamGridDB 추가 링크";var ACTION_SGDB_DISCORD$d="Discord 참여";var ACTION_SGDB_GITHUB$c="오픈 소스 프로젝트들";var ACTION_SGDB_DONATE$d="Patreon으로 후원하기";var ACTION_SGDB_TRANSLATE$d="번역 도와주기";var ACTION_SGDB_BOOP$d="SGDBoop 알아보기";var LABEL_RESTART_STEAM_TITLE$c="Steam을 다시 시작할까요?";var ACTION_RESTART_STEAM_LATER$c="나중에";var ACTION_RESTART_STEAM_NOW$c="지금 다시 시작";var MSG_RESTART_STEAM_DESC$b="변경사항을 적용하기 위해서는 Steam을 다시 시작해야 합니다.";var LABEL_GAME_SEARCH_TITLE$d="게임 이름으로 검색...";var LABEL_FILTER_MODAL_TITLE$d="{assetType} 필터";var LABEL_FILTER_GAME$d="게임";var LABEL_FILTER_DIMENSIONS$d="이미지 크기";var LABEL_FILTER_STYLES$d="스타일";var LABEL_FILTER_FILE_TYPES$d="파일 유형";var LABEL_FILTER_ANIMATION_TYPE_TITLE$d="유형";var LABEL_FILTER_TYPE_ANIMATED$c="움직이는 이미지";var LABEL_FILTER_TYPE_STATIC$c="정적 이미지";var LABEL_FILTER_TAGS_TITLE$d="태그";var LABEL_FILTER_TAG_NSFW$d="성인 컨텐츠";var MSG_FILTER_TAG_NSFW_ENABLED$c="후방 조심하세요!";var LABEL_FILTER_TAG_HUMOR$c="유머";var LABEL_FILTER_TAG_EPILEPSY$c="광과민성";var LABEL_FILTER_TAG_UNTAGGED$c="태그 없음";var ACTION_FILTER_RESET$d="필터 초기화";var LABEL_BEGGING_MODAL_TITLE$b="SteamGridDB를 사용해주셔서 감사합니다!";var LABEL_BEGGING_MODAL_DESC$a="유지비 및 서버 비용을 지원하기 위해 기부하는것을 고려해 주세요!";var ACTION_HIDE_POS_GUIDES$b="가이드 숨기기";var ACTION_SHOW_OUTLINE$b="가이드 표시";var ACTION_ADJUST_POS_SIZE$c="크기 조정";var LABEL_ASSET_CURRENT$d="현재 {assetType}";var ACTION_ASSET_CUSTOM_CLEAR$d="사용자 지정 이미지 지우기";var ACTION_ASSET_BROWSE_LOCAL$c="시스템 내 파일 찾아보기";var ACTION_ASSET_APPLY_TRANSPARENT$c="투명 이미지 사용";var LABEL_NOTES$d="노트";var LABEL_ANIMATED$c="움직이는 이미지";var LABEL_NSFW$d="성인 컨텐츠";var LABEL_HUMOR$c="유머";var LABEL_EPILEPSY$c="광과민성";var ACTION_OPEN_FILTER$d="필터";var ACTION_OPEN_OFFICIAL_ASSETS$c="공식 {assetType}";var ACTION_ASSET_APPLY$c="{assetType} 적용하기";var MSG_GAME_SELECTED$c="{gameName} 을(를) 선택함";var MSG_ASSETS_FILTERED$c="필터로 인해 일부 자료가 보이지 않을 수 있습니다.";var MSG_GAME_SELECTED_AND_ASSETS_FILTERED$c="{gameName} 을(를) 필터가 적용된 상태로 선택함";var MSG_ASSET_APPLY_SUCCESS$c="{assetType} 이 성공적으로 적용되었습니다!";var MSG_ASSET_APPLY_ERROR$c="이 이미지를 적용하는 중 문제가 발생했습니다.";var ACTION_OPEN_DETAILS$d="자세히 보기";var ko = {ASSET_TYPE_CAPSULE:ASSET_TYPE_CAPSULE$d,ASSET_TYPE_WIDECAPSULE:ASSET_TYPE_WIDECAPSULE$d,ASSET_TYPE_HERO:ASSET_TYPE_HERO$d,ASSET_TYPE_LOGO:ASSET_TYPE_LOGO$d,ASSET_TYPE_ICON:ASSET_TYPE_ICON$d,LABEL_TAB_CAPSULE:LABEL_TAB_CAPSULE$d,LABEL_TAB_WIDECAPSULE:LABEL_TAB_WIDECAPSULE$d,LABEL_TAB_HERO:LABEL_TAB_HERO$d,LABEL_TAB_LOGO:LABEL_TAB_LOGO$d,LABEL_TAB_ICON:LABEL_TAB_ICON$d,LABEL_TAB_MANAGE:LABEL_TAB_MANAGE$d,MSG_USAGE_INSTRUCTIONS:MSG_USAGE_INSTRUCTIONS$c,ACTION_CHANGE_ARTWORK:ACTION_CHANGE_ARTWORK$d,ACTION_SHOW_LINK_QR:ACTION_SHOW_LINK_QR$d,MSG_ASSET_TAB_SETTINGS_DESC:MSG_ASSET_TAB_SETTINGS_DESC$b,LABEL_USAGE_TITLE:LABEL_USAGE_TITLE$c,LABEL_SQUARE_CAPSULES:LABEL_SQUARE_CAPSULES$b,LABEL_SQUARE_CAPSULES_DESC:LABEL_SQUARE_CAPSULES_DESC$a,LABEL_UNIFORM_RECENT:LABEL_UNIFORM_RECENT$8,LABEL_UNIFORM_RECENT_DESC:LABEL_UNIFORM_RECENT_DESC$8,LABEL_CAPSULE_GLOW:LABEL_CAPSULE_GLOW$b,LABEL_CAPSULE_GLOW_DESC:LABEL_CAPSULE_GLOW_DESC$a,LABEL_CAPSULE_GLOW_OFF:LABEL_CAPSULE_GLOW_OFF$b,LABEL_SETTINGS_ASSET_TABS:LABEL_SETTINGS_ASSET_TABS$b,LABEL_SETTINGS_DISABLE_MOTD:LABEL_SETTINGS_DISABLE_MOTD$9,LABEL_SETTINGS_DISABLE_MOTD_DESC:LABEL_SETTINGS_DISABLE_MOTD_DESC$8,LABEL_TRANSLATION_CREDIT_TITLE:LABEL_TRANSLATION_CREDIT_TITLE$d,LABEL_MORE_SGDB_TITLE:LABEL_MORE_SGDB_TITLE$d,ACTION_SGDB_DISCORD:ACTION_SGDB_DISCORD$d,ACTION_SGDB_GITHUB:ACTION_SGDB_GITHUB$c,ACTION_SGDB_DONATE:ACTION_SGDB_DONATE$d,ACTION_SGDB_TRANSLATE:ACTION_SGDB_TRANSLATE$d,ACTION_SGDB_BOOP:ACTION_SGDB_BOOP$d,LABEL_RESTART_STEAM_TITLE:LABEL_RESTART_STEAM_TITLE$c,ACTION_RESTART_STEAM_LATER:ACTION_RESTART_STEAM_LATER$c,ACTION_RESTART_STEAM_NOW:ACTION_RESTART_STEAM_NOW$c,MSG_RESTART_STEAM_DESC:MSG_RESTART_STEAM_DESC$b,LABEL_GAME_SEARCH_TITLE:LABEL_GAME_SEARCH_TITLE$d,LABEL_FILTER_MODAL_TITLE:LABEL_FILTER_MODAL_TITLE$d,LABEL_FILTER_GAME:LABEL_FILTER_GAME$d,LABEL_FILTER_DIMENSIONS:LABEL_FILTER_DIMENSIONS$d,LABEL_FILTER_STYLES:LABEL_FILTER_STYLES$d,LABEL_FILTER_FILE_TYPES:LABEL_FILTER_FILE_TYPES$d,LABEL_FILTER_ANIMATION_TYPE_TITLE:LABEL_FILTER_ANIMATION_TYPE_TITLE$d,LABEL_FILTER_TYPE_ANIMATED:LABEL_FILTER_TYPE_ANIMATED$c,LABEL_FILTER_TYPE_STATIC:LABEL_FILTER_TYPE_STATIC$c,LABEL_FILTER_TAGS_TITLE:LABEL_FILTER_TAGS_TITLE$d,LABEL_FILTER_TAG_NSFW:LABEL_FILTER_TAG_NSFW$d,MSG_FILTER_TAG_NSFW_ENABLED:MSG_FILTER_TAG_NSFW_ENABLED$c,LABEL_FILTER_TAG_HUMOR:LABEL_FILTER_TAG_HUMOR$c,LABEL_FILTER_TAG_EPILEPSY:LABEL_FILTER_TAG_EPILEPSY$c,LABEL_FILTER_TAG_UNTAGGED:LABEL_FILTER_TAG_UNTAGGED$c,ACTION_FILTER_RESET:ACTION_FILTER_RESET$d,LABEL_BEGGING_MODAL_TITLE:LABEL_BEGGING_MODAL_TITLE$b,LABEL_BEGGING_MODAL_DESC:LABEL_BEGGING_MODAL_DESC$a,ACTION_HIDE_POS_GUIDES:ACTION_HIDE_POS_GUIDES$b,ACTION_SHOW_OUTLINE:ACTION_SHOW_OUTLINE$b,ACTION_ADJUST_POS_SIZE:ACTION_ADJUST_POS_SIZE$c,LABEL_ASSET_CURRENT:LABEL_ASSET_CURRENT$d,ACTION_ASSET_CUSTOM_CLEAR:ACTION_ASSET_CUSTOM_CLEAR$d,ACTION_ASSET_BROWSE_LOCAL:ACTION_ASSET_BROWSE_LOCAL$c,ACTION_ASSET_APPLY_TRANSPARENT:ACTION_ASSET_APPLY_TRANSPARENT$c,LABEL_NOTES:LABEL_NOTES$d,LABEL_ANIMATED:LABEL_ANIMATED$c,LABEL_NSFW:LABEL_NSFW$d,LABEL_HUMOR:LABEL_HUMOR$c,LABEL_EPILEPSY:LABEL_EPILEPSY$c,ACTION_OPEN_FILTER:ACTION_OPEN_FILTER$d,ACTION_OPEN_OFFICIAL_ASSETS:ACTION_OPEN_OFFICIAL_ASSETS$c,ACTION_ASSET_APPLY:ACTION_ASSET_APPLY$c,MSG_GAME_SELECTED:MSG_GAME_SELECTED$c,MSG_ASSETS_FILTERED:MSG_ASSETS_FILTERED$c,MSG_GAME_SELECTED_AND_ASSETS_FILTERED:MSG_GAME_SELECTED_AND_ASSETS_FILTERED$c,MSG_ASSET_APPLY_SUCCESS:MSG_ASSET_APPLY_SUCCESS$c,MSG_ASSET_APPLY_ERROR:MSG_ASSET_APPLY_ERROR$c,ACTION_OPEN_DETAILS:ACTION_OPEN_DETAILS$d};

var ko$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    ACTION_ADJUST_POS_SIZE: ACTION_ADJUST_POS_SIZE$c,
    ACTION_ASSET_APPLY: ACTION_ASSET_APPLY$c,
    ACTION_ASSET_APPLY_TRANSPARENT: ACTION_ASSET_APPLY_TRANSPARENT$c,
    ACTION_ASSET_BROWSE_LOCAL: ACTION_ASSET_BROWSE_LOCAL$c,
    ACTION_ASSET_CUSTOM_CLEAR: ACTION_ASSET_CUSTOM_CLEAR$d,
    ACTION_CHANGE_ARTWORK: ACTION_CHANGE_ARTWORK$d,
    ACTION_FILTER_RESET: ACTION_FILTER_RESET$d,
    ACTION_HIDE_POS_GUIDES: ACTION_HIDE_POS_GUIDES$b,
    ACTION_OPEN_DETAILS: ACTION_OPEN_DETAILS$d,
    ACTION_OPEN_FILTER: ACTION_OPEN_FILTER$d,
    ACTION_OPEN_OFFICIAL_ASSETS: ACTION_OPEN_OFFICIAL_ASSETS$c,
    ACTION_RESTART_STEAM_LATER: ACTION_RESTART_STEAM_LATER$c,
    ACTION_RESTART_STEAM_NOW: ACTION_RESTART_STEAM_NOW$c,
    ACTION_SGDB_BOOP: ACTION_SGDB_BOOP$d,
    ACTION_SGDB_DISCORD: ACTION_SGDB_DISCORD$d,
    ACTION_SGDB_DONATE: ACTION_SGDB_DONATE$d,
    ACTION_SGDB_GITHUB: ACTION_SGDB_GITHUB$c,
    ACTION_SGDB_TRANSLATE: ACTION_SGDB_TRANSLATE$d,
    ACTION_SHOW_LINK_QR: ACTION_SHOW_LINK_QR$d,
    ACTION_SHOW_OUTLINE: ACTION_SHOW_OUTLINE$b,
    ASSET_TYPE_CAPSULE: ASSET_TYPE_CAPSULE$d,
    ASSET_TYPE_HERO: ASSET_TYPE_HERO$d,
    ASSET_TYPE_ICON: ASSET_TYPE_ICON$d,
    ASSET_TYPE_LOGO: ASSET_TYPE_LOGO$d,
    ASSET_TYPE_WIDECAPSULE: ASSET_TYPE_WIDECAPSULE$d,
    LABEL_ANIMATED: LABEL_ANIMATED$c,
    LABEL_ASSET_CURRENT: LABEL_ASSET_CURRENT$d,
    LABEL_BEGGING_MODAL_DESC: LABEL_BEGGING_MODAL_DESC$a,
    LABEL_BEGGING_MODAL_TITLE: LABEL_BEGGING_MODAL_TITLE$b,
    LABEL_CAPSULE_GLOW: LABEL_CAPSULE_GLOW$b,
    LABEL_CAPSULE_GLOW_DESC: LABEL_CAPSULE_GLOW_DESC$a,
    LABEL_CAPSULE_GLOW_OFF: LABEL_CAPSULE_GLOW_OFF$b,
    LABEL_EPILEPSY: LABEL_EPILEPSY$c,
    LABEL_FILTER_ANIMATION_TYPE_TITLE: LABEL_FILTER_ANIMATION_TYPE_TITLE$d,
    LABEL_FILTER_DIMENSIONS: LABEL_FILTER_DIMENSIONS$d,
    LABEL_FILTER_FILE_TYPES: LABEL_FILTER_FILE_TYPES$d,
    LABEL_FILTER_GAME: LABEL_FILTER_GAME$d,
    LABEL_FILTER_MODAL_TITLE: LABEL_FILTER_MODAL_TITLE$d,
    LABEL_FILTER_STYLES: LABEL_FILTER_STYLES$d,
    LABEL_FILTER_TAGS_TITLE: LABEL_FILTER_TAGS_TITLE$d,
    LABEL_FILTER_TAG_EPILEPSY: LABEL_FILTER_TAG_EPILEPSY$c,
    LABEL_FILTER_TAG_HUMOR: LABEL_FILTER_TAG_HUMOR$c,
    LABEL_FILTER_TAG_NSFW: LABEL_FILTER_TAG_NSFW$d,
    LABEL_FILTER_TAG_UNTAGGED: LABEL_FILTER_TAG_UNTAGGED$c,
    LABEL_FILTER_TYPE_ANIMATED: LABEL_FILTER_TYPE_ANIMATED$c,
    LABEL_FILTER_TYPE_STATIC: LABEL_FILTER_TYPE_STATIC$c,
    LABEL_GAME_SEARCH_TITLE: LABEL_GAME_SEARCH_TITLE$d,
    LABEL_HUMOR: LABEL_HUMOR$c,
    LABEL_MORE_SGDB_TITLE: LABEL_MORE_SGDB_TITLE$d,
    LABEL_NOTES: LABEL_NOTES$d,
    LABEL_NSFW: LABEL_NSFW$d,
    LABEL_RESTART_STEAM_TITLE: LABEL_RESTART_STEAM_TITLE$c,
    LABEL_SETTINGS_ASSET_TABS: LABEL_SETTINGS_ASSET_TABS$b,
    LABEL_SETTINGS_DISABLE_MOTD: LABEL_SETTINGS_DISABLE_MOTD$9,
    LABEL_SETTINGS_DISABLE_MOTD_DESC: LABEL_SETTINGS_DISABLE_MOTD_DESC$8,
    LABEL_SQUARE_CAPSULES: LABEL_SQUARE_CAPSULES$b,
    LABEL_SQUARE_CAPSULES_DESC: LABEL_SQUARE_CAPSULES_DESC$a,
    LABEL_TAB_CAPSULE: LABEL_TAB_CAPSULE$d,
    LABEL_TAB_HERO: LABEL_TAB_HERO$d,
    LABEL_TAB_ICON: LABEL_TAB_ICON$d,
    LABEL_TAB_LOGO: LABEL_TAB_LOGO$d,
    LABEL_TAB_MANAGE: LABEL_TAB_MANAGE$d,
    LABEL_TAB_WIDECAPSULE: LABEL_TAB_WIDECAPSULE$d,
    LABEL_TRANSLATION_CREDIT_TITLE: LABEL_TRANSLATION_CREDIT_TITLE$d,
    LABEL_UNIFORM_RECENT: LABEL_UNIFORM_RECENT$8,
    LABEL_UNIFORM_RECENT_DESC: LABEL_UNIFORM_RECENT_DESC$8,
    LABEL_USAGE_TITLE: LABEL_USAGE_TITLE$c,
    MSG_ASSETS_FILTERED: MSG_ASSETS_FILTERED$c,
    MSG_ASSET_APPLY_ERROR: MSG_ASSET_APPLY_ERROR$c,
    MSG_ASSET_APPLY_SUCCESS: MSG_ASSET_APPLY_SUCCESS$c,
    MSG_ASSET_TAB_SETTINGS_DESC: MSG_ASSET_TAB_SETTINGS_DESC$b,
    MSG_FILTER_TAG_NSFW_ENABLED: MSG_FILTER_TAG_NSFW_ENABLED$c,
    MSG_GAME_SELECTED: MSG_GAME_SELECTED$c,
    MSG_GAME_SELECTED_AND_ASSETS_FILTERED: MSG_GAME_SELECTED_AND_ASSETS_FILTERED$c,
    MSG_RESTART_STEAM_DESC: MSG_RESTART_STEAM_DESC$b,
    MSG_USAGE_INSTRUCTIONS: MSG_USAGE_INSTRUCTIONS$c,
    default: ko
});

var ASSET_TYPE_CAPSULE$c="Capsule";var ASSET_TYPE_WIDECAPSULE$c="Wijde capsule";var ASSET_TYPE_HERO$c="Hoofdbanner";var ASSET_TYPE_LOGO$c="Logo";var ASSET_TYPE_ICON$c="Icoon";var LABEL_TAB_CAPSULE$c="Capsule";var LABEL_TAB_WIDECAPSULE$c="Wijde capsule";var LABEL_TAB_HERO$c="Hoofdbanner";var LABEL_TAB_LOGO$c="Logo";var LABEL_TAB_ICON$c="Icoon";var LABEL_TAB_MANAGE$c="Beheren";var MSG_USAGE_INSTRUCTIONS$b="Selecteer een spel {arrow} {optionsButton} {arrow} \"{ACTION_CHANGE_ARTWORK}\"";var ACTION_CHANGE_ARTWORK$c="Wijzig Afbeelding...";var ACTION_SHOW_LINK_QR$c="Laat QR-code zien";var MSG_ASSET_TAB_SETTINGS_DESC$a="Rangschik of verberg ongebruikte tabs, en kies de standaard tab die opent bij gebruik";var LABEL_USAGE_TITLE$b="Verloren? Hier is een snelle handleiding";var LABEL_SQUARE_CAPSULES$a="Vierkante Capsules";var LABEL_SQUARE_CAPSULES_DESC$9="Gebruik vierkante capsules in plaats van de standaard horizontale en verticale capsules.\nFilters voor vierkante capsules zullen automatisch geactiveerd worden.";var LABEL_UNIFORM_RECENT$7="Laat recente capsules overeen komen.";var LABEL_UNIFORM_RECENT_DESC$7="Maak het meest recent gespeelde spel qua capsule over een komen met de rest.";var LABEL_CAPSULE_GLOW$a="Capsule Gloei";var LABEL_CAPSULE_GLOW_DESC$9="Verander capsule gloei in uw bibliotheek.";var LABEL_CAPSULE_GLOW_OFF$a="Geen";var LABEL_SETTINGS_ASSET_TABS$a="Asset Tab Instellingen";var LABEL_SETTINGS_DISABLE_MOTD$8="Sluit aankondigingen af.";var LABEL_SETTINGS_DISABLE_MOTD_DESC$7="Aankondigingen worden zelden gebruikt om belangrijke informatie of community-evenementen aan te duiden.";var LABEL_TRANSLATION_CREDIT_TITLE$c="Nederlandse Vertaling";var LABEL_MORE_SGDB_TITLE$c="Meer van SteamGridDB";var ACTION_SGDB_DISCORD$c="Word lid van de Discord";var ACTION_SGDB_GITHUB$b="Open source projecten";var ACTION_SGDB_DONATE$c="Steun ons on Patreon";var ACTION_SGDB_TRANSLATE$c="Help met vertalen";var ACTION_SGDB_BOOP$c="Probeer SGDBoop";var LABEL_RESTART_STEAM_TITLE$b="Steam herstarten?";var ACTION_RESTART_STEAM_LATER$b="Niet nu";var ACTION_RESTART_STEAM_NOW$b="Nu herstarten";var MSG_RESTART_STEAM_DESC$a="Steam moet opnieuw worden opgestart voordat wijzigingen zichtbaar zijn.";var LABEL_GAME_SEARCH_TITLE$c="Zoek voor een Spelletje...";var LABEL_FILTER_MODAL_TITLE$c="{assetType} filter";var LABEL_FILTER_GAME$c="Spel";var LABEL_FILTER_DIMENSIONS$c="Afmetingen";var LABEL_FILTER_STYLES$c="Stijlen";var LABEL_FILTER_FILE_TYPES$c="Bestandstypen";var LABEL_FILTER_ANIMATION_TYPE_TITLE$c="Typen";var LABEL_FILTER_TYPE_ANIMATED$b="Geanimeerd";var LABEL_FILTER_TYPE_STATIC$b="Statisch";var LABEL_FILTER_TAGS_TITLE$c="Labels";var LABEL_FILTER_TAG_NSFW$c="18+ Content";var MSG_FILTER_TAG_NSFW_ENABLED$b="Weet je zeker dat je hier oud genoeg voor bent? Steamgriddb is niet afhankelijk van verlies van onschuld en algemeen zicht.";var LABEL_FILTER_TAG_HUMOR$b="Grappig";var LABEL_FILTER_TAG_EPILEPSY$b="Flitsend";var LABEL_FILTER_TAG_UNTAGGED$b="Zonder label";var ACTION_FILTER_RESET$c="Filters opnieuw instellen";var LABEL_BEGGING_MODAL_TITLE$a="Dank je voor het gebruiken van SteamGridDB!";var LABEL_BEGGING_MODAL_DESC$9="Overweeg alstublieft om te doneren om te helpen met onderhoud en serverkosten!";var ACTION_HIDE_POS_GUIDES$a="Verberg handleidingen";var ACTION_SHOW_OUTLINE$a="Kantlijnen tonen";var ACTION_ADJUST_POS_SIZE$b="Grootte aanpassen";var ACTION_CHANGE_POS_LOGO_ANCHOR_POINT$7="Verander Ankerlocatie";var LABEL_ASSET_CURRENT$c="Huidige {assetType}";var ACTION_ASSET_CUSTOM_CLEAR$c="Wis aangepaste afbeelding";var ACTION_ASSET_BROWSE_LOCAL$b="Lokale bestanden doorzoeken";var ACTION_ASSET_APPLY_TRANSPARENT$b="Gebruik verborgen materiaal";var LABEL_NOTES$c="Notities";var LABEL_ANIMATED$b="Geanimeerd";var LABEL_NSFW$c="18+ Content";var LABEL_HUMOR$b="Grappig";var LABEL_EPILEPSY$b="Flitsend";var ACTION_OPEN_FILTER$c="Filter";var ACTION_OPEN_OFFICIAL_ASSETS$b="Officiële {assetType}";var ACTION_ASSET_APPLY$b="{assetType} toepassen";var MSG_GAME_SELECTED$b="{gameName} geselecteerd";var MSG_ASSETS_FILTERED$b="Sommige afbeeldingen zijn misschien verborgen door een filter";var MSG_GAME_SELECTED_AND_ASSETS_FILTERED$b="{gameName} met filter geselecteerd";var TITLE_MOTD_HIDE$8="Verberg aankondigingen?";var LABEL_MOTD_THIS$8="Deze Aankondiging";var LABEL_MOTD_ALL$8="Alle Aankondigingen";var MSG_ASSET_APPLY_SUCCESS$b="{assetType} is met succes toegepast!";var MSG_ASSET_APPLY_ERROR$b="Er is een probleem met het toevoegen van de afbeelding.";var ACTION_OPEN_DETAILS$c="Omschrijving";var nl = {ASSET_TYPE_CAPSULE:ASSET_TYPE_CAPSULE$c,ASSET_TYPE_WIDECAPSULE:ASSET_TYPE_WIDECAPSULE$c,ASSET_TYPE_HERO:ASSET_TYPE_HERO$c,ASSET_TYPE_LOGO:ASSET_TYPE_LOGO$c,ASSET_TYPE_ICON:ASSET_TYPE_ICON$c,LABEL_TAB_CAPSULE:LABEL_TAB_CAPSULE$c,LABEL_TAB_WIDECAPSULE:LABEL_TAB_WIDECAPSULE$c,LABEL_TAB_HERO:LABEL_TAB_HERO$c,LABEL_TAB_LOGO:LABEL_TAB_LOGO$c,LABEL_TAB_ICON:LABEL_TAB_ICON$c,LABEL_TAB_MANAGE:LABEL_TAB_MANAGE$c,MSG_USAGE_INSTRUCTIONS:MSG_USAGE_INSTRUCTIONS$b,ACTION_CHANGE_ARTWORK:ACTION_CHANGE_ARTWORK$c,ACTION_SHOW_LINK_QR:ACTION_SHOW_LINK_QR$c,MSG_ASSET_TAB_SETTINGS_DESC:MSG_ASSET_TAB_SETTINGS_DESC$a,LABEL_USAGE_TITLE:LABEL_USAGE_TITLE$b,LABEL_SQUARE_CAPSULES:LABEL_SQUARE_CAPSULES$a,LABEL_SQUARE_CAPSULES_DESC:LABEL_SQUARE_CAPSULES_DESC$9,LABEL_UNIFORM_RECENT:LABEL_UNIFORM_RECENT$7,LABEL_UNIFORM_RECENT_DESC:LABEL_UNIFORM_RECENT_DESC$7,LABEL_CAPSULE_GLOW:LABEL_CAPSULE_GLOW$a,LABEL_CAPSULE_GLOW_DESC:LABEL_CAPSULE_GLOW_DESC$9,LABEL_CAPSULE_GLOW_OFF:LABEL_CAPSULE_GLOW_OFF$a,LABEL_SETTINGS_ASSET_TABS:LABEL_SETTINGS_ASSET_TABS$a,LABEL_SETTINGS_DISABLE_MOTD:LABEL_SETTINGS_DISABLE_MOTD$8,LABEL_SETTINGS_DISABLE_MOTD_DESC:LABEL_SETTINGS_DISABLE_MOTD_DESC$7,LABEL_TRANSLATION_CREDIT_TITLE:LABEL_TRANSLATION_CREDIT_TITLE$c,LABEL_MORE_SGDB_TITLE:LABEL_MORE_SGDB_TITLE$c,ACTION_SGDB_DISCORD:ACTION_SGDB_DISCORD$c,ACTION_SGDB_GITHUB:ACTION_SGDB_GITHUB$b,ACTION_SGDB_DONATE:ACTION_SGDB_DONATE$c,ACTION_SGDB_TRANSLATE:ACTION_SGDB_TRANSLATE$c,ACTION_SGDB_BOOP:ACTION_SGDB_BOOP$c,LABEL_RESTART_STEAM_TITLE:LABEL_RESTART_STEAM_TITLE$b,ACTION_RESTART_STEAM_LATER:ACTION_RESTART_STEAM_LATER$b,ACTION_RESTART_STEAM_NOW:ACTION_RESTART_STEAM_NOW$b,MSG_RESTART_STEAM_DESC:MSG_RESTART_STEAM_DESC$a,LABEL_GAME_SEARCH_TITLE:LABEL_GAME_SEARCH_TITLE$c,LABEL_FILTER_MODAL_TITLE:LABEL_FILTER_MODAL_TITLE$c,LABEL_FILTER_GAME:LABEL_FILTER_GAME$c,LABEL_FILTER_DIMENSIONS:LABEL_FILTER_DIMENSIONS$c,LABEL_FILTER_STYLES:LABEL_FILTER_STYLES$c,LABEL_FILTER_FILE_TYPES:LABEL_FILTER_FILE_TYPES$c,LABEL_FILTER_ANIMATION_TYPE_TITLE:LABEL_FILTER_ANIMATION_TYPE_TITLE$c,LABEL_FILTER_TYPE_ANIMATED:LABEL_FILTER_TYPE_ANIMATED$b,LABEL_FILTER_TYPE_STATIC:LABEL_FILTER_TYPE_STATIC$b,LABEL_FILTER_TAGS_TITLE:LABEL_FILTER_TAGS_TITLE$c,LABEL_FILTER_TAG_NSFW:LABEL_FILTER_TAG_NSFW$c,MSG_FILTER_TAG_NSFW_ENABLED:MSG_FILTER_TAG_NSFW_ENABLED$b,LABEL_FILTER_TAG_HUMOR:LABEL_FILTER_TAG_HUMOR$b,LABEL_FILTER_TAG_EPILEPSY:LABEL_FILTER_TAG_EPILEPSY$b,LABEL_FILTER_TAG_UNTAGGED:LABEL_FILTER_TAG_UNTAGGED$b,ACTION_FILTER_RESET:ACTION_FILTER_RESET$c,LABEL_BEGGING_MODAL_TITLE:LABEL_BEGGING_MODAL_TITLE$a,LABEL_BEGGING_MODAL_DESC:LABEL_BEGGING_MODAL_DESC$9,ACTION_HIDE_POS_GUIDES:ACTION_HIDE_POS_GUIDES$a,ACTION_SHOW_OUTLINE:ACTION_SHOW_OUTLINE$a,ACTION_ADJUST_POS_SIZE:ACTION_ADJUST_POS_SIZE$b,ACTION_CHANGE_POS_LOGO_ANCHOR_POINT:ACTION_CHANGE_POS_LOGO_ANCHOR_POINT$7,LABEL_ASSET_CURRENT:LABEL_ASSET_CURRENT$c,ACTION_ASSET_CUSTOM_CLEAR:ACTION_ASSET_CUSTOM_CLEAR$c,ACTION_ASSET_BROWSE_LOCAL:ACTION_ASSET_BROWSE_LOCAL$b,ACTION_ASSET_APPLY_TRANSPARENT:ACTION_ASSET_APPLY_TRANSPARENT$b,LABEL_NOTES:LABEL_NOTES$c,LABEL_ANIMATED:LABEL_ANIMATED$b,LABEL_NSFW:LABEL_NSFW$c,LABEL_HUMOR:LABEL_HUMOR$b,LABEL_EPILEPSY:LABEL_EPILEPSY$b,ACTION_OPEN_FILTER:ACTION_OPEN_FILTER$c,ACTION_OPEN_OFFICIAL_ASSETS:ACTION_OPEN_OFFICIAL_ASSETS$b,ACTION_ASSET_APPLY:ACTION_ASSET_APPLY$b,MSG_GAME_SELECTED:MSG_GAME_SELECTED$b,MSG_ASSETS_FILTERED:MSG_ASSETS_FILTERED$b,MSG_GAME_SELECTED_AND_ASSETS_FILTERED:MSG_GAME_SELECTED_AND_ASSETS_FILTERED$b,TITLE_MOTD_HIDE:TITLE_MOTD_HIDE$8,LABEL_MOTD_THIS:LABEL_MOTD_THIS$8,LABEL_MOTD_ALL:LABEL_MOTD_ALL$8,MSG_ASSET_APPLY_SUCCESS:MSG_ASSET_APPLY_SUCCESS$b,MSG_ASSET_APPLY_ERROR:MSG_ASSET_APPLY_ERROR$b,ACTION_OPEN_DETAILS:ACTION_OPEN_DETAILS$c};

var nl$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    ACTION_ADJUST_POS_SIZE: ACTION_ADJUST_POS_SIZE$b,
    ACTION_ASSET_APPLY: ACTION_ASSET_APPLY$b,
    ACTION_ASSET_APPLY_TRANSPARENT: ACTION_ASSET_APPLY_TRANSPARENT$b,
    ACTION_ASSET_BROWSE_LOCAL: ACTION_ASSET_BROWSE_LOCAL$b,
    ACTION_ASSET_CUSTOM_CLEAR: ACTION_ASSET_CUSTOM_CLEAR$c,
    ACTION_CHANGE_ARTWORK: ACTION_CHANGE_ARTWORK$c,
    ACTION_CHANGE_POS_LOGO_ANCHOR_POINT: ACTION_CHANGE_POS_LOGO_ANCHOR_POINT$7,
    ACTION_FILTER_RESET: ACTION_FILTER_RESET$c,
    ACTION_HIDE_POS_GUIDES: ACTION_HIDE_POS_GUIDES$a,
    ACTION_OPEN_DETAILS: ACTION_OPEN_DETAILS$c,
    ACTION_OPEN_FILTER: ACTION_OPEN_FILTER$c,
    ACTION_OPEN_OFFICIAL_ASSETS: ACTION_OPEN_OFFICIAL_ASSETS$b,
    ACTION_RESTART_STEAM_LATER: ACTION_RESTART_STEAM_LATER$b,
    ACTION_RESTART_STEAM_NOW: ACTION_RESTART_STEAM_NOW$b,
    ACTION_SGDB_BOOP: ACTION_SGDB_BOOP$c,
    ACTION_SGDB_DISCORD: ACTION_SGDB_DISCORD$c,
    ACTION_SGDB_DONATE: ACTION_SGDB_DONATE$c,
    ACTION_SGDB_GITHUB: ACTION_SGDB_GITHUB$b,
    ACTION_SGDB_TRANSLATE: ACTION_SGDB_TRANSLATE$c,
    ACTION_SHOW_LINK_QR: ACTION_SHOW_LINK_QR$c,
    ACTION_SHOW_OUTLINE: ACTION_SHOW_OUTLINE$a,
    ASSET_TYPE_CAPSULE: ASSET_TYPE_CAPSULE$c,
    ASSET_TYPE_HERO: ASSET_TYPE_HERO$c,
    ASSET_TYPE_ICON: ASSET_TYPE_ICON$c,
    ASSET_TYPE_LOGO: ASSET_TYPE_LOGO$c,
    ASSET_TYPE_WIDECAPSULE: ASSET_TYPE_WIDECAPSULE$c,
    LABEL_ANIMATED: LABEL_ANIMATED$b,
    LABEL_ASSET_CURRENT: LABEL_ASSET_CURRENT$c,
    LABEL_BEGGING_MODAL_DESC: LABEL_BEGGING_MODAL_DESC$9,
    LABEL_BEGGING_MODAL_TITLE: LABEL_BEGGING_MODAL_TITLE$a,
    LABEL_CAPSULE_GLOW: LABEL_CAPSULE_GLOW$a,
    LABEL_CAPSULE_GLOW_DESC: LABEL_CAPSULE_GLOW_DESC$9,
    LABEL_CAPSULE_GLOW_OFF: LABEL_CAPSULE_GLOW_OFF$a,
    LABEL_EPILEPSY: LABEL_EPILEPSY$b,
    LABEL_FILTER_ANIMATION_TYPE_TITLE: LABEL_FILTER_ANIMATION_TYPE_TITLE$c,
    LABEL_FILTER_DIMENSIONS: LABEL_FILTER_DIMENSIONS$c,
    LABEL_FILTER_FILE_TYPES: LABEL_FILTER_FILE_TYPES$c,
    LABEL_FILTER_GAME: LABEL_FILTER_GAME$c,
    LABEL_FILTER_MODAL_TITLE: LABEL_FILTER_MODAL_TITLE$c,
    LABEL_FILTER_STYLES: LABEL_FILTER_STYLES$c,
    LABEL_FILTER_TAGS_TITLE: LABEL_FILTER_TAGS_TITLE$c,
    LABEL_FILTER_TAG_EPILEPSY: LABEL_FILTER_TAG_EPILEPSY$b,
    LABEL_FILTER_TAG_HUMOR: LABEL_FILTER_TAG_HUMOR$b,
    LABEL_FILTER_TAG_NSFW: LABEL_FILTER_TAG_NSFW$c,
    LABEL_FILTER_TAG_UNTAGGED: LABEL_FILTER_TAG_UNTAGGED$b,
    LABEL_FILTER_TYPE_ANIMATED: LABEL_FILTER_TYPE_ANIMATED$b,
    LABEL_FILTER_TYPE_STATIC: LABEL_FILTER_TYPE_STATIC$b,
    LABEL_GAME_SEARCH_TITLE: LABEL_GAME_SEARCH_TITLE$c,
    LABEL_HUMOR: LABEL_HUMOR$b,
    LABEL_MORE_SGDB_TITLE: LABEL_MORE_SGDB_TITLE$c,
    LABEL_MOTD_ALL: LABEL_MOTD_ALL$8,
    LABEL_MOTD_THIS: LABEL_MOTD_THIS$8,
    LABEL_NOTES: LABEL_NOTES$c,
    LABEL_NSFW: LABEL_NSFW$c,
    LABEL_RESTART_STEAM_TITLE: LABEL_RESTART_STEAM_TITLE$b,
    LABEL_SETTINGS_ASSET_TABS: LABEL_SETTINGS_ASSET_TABS$a,
    LABEL_SETTINGS_DISABLE_MOTD: LABEL_SETTINGS_DISABLE_MOTD$8,
    LABEL_SETTINGS_DISABLE_MOTD_DESC: LABEL_SETTINGS_DISABLE_MOTD_DESC$7,
    LABEL_SQUARE_CAPSULES: LABEL_SQUARE_CAPSULES$a,
    LABEL_SQUARE_CAPSULES_DESC: LABEL_SQUARE_CAPSULES_DESC$9,
    LABEL_TAB_CAPSULE: LABEL_TAB_CAPSULE$c,
    LABEL_TAB_HERO: LABEL_TAB_HERO$c,
    LABEL_TAB_ICON: LABEL_TAB_ICON$c,
    LABEL_TAB_LOGO: LABEL_TAB_LOGO$c,
    LABEL_TAB_MANAGE: LABEL_TAB_MANAGE$c,
    LABEL_TAB_WIDECAPSULE: LABEL_TAB_WIDECAPSULE$c,
    LABEL_TRANSLATION_CREDIT_TITLE: LABEL_TRANSLATION_CREDIT_TITLE$c,
    LABEL_UNIFORM_RECENT: LABEL_UNIFORM_RECENT$7,
    LABEL_UNIFORM_RECENT_DESC: LABEL_UNIFORM_RECENT_DESC$7,
    LABEL_USAGE_TITLE: LABEL_USAGE_TITLE$b,
    MSG_ASSETS_FILTERED: MSG_ASSETS_FILTERED$b,
    MSG_ASSET_APPLY_ERROR: MSG_ASSET_APPLY_ERROR$b,
    MSG_ASSET_APPLY_SUCCESS: MSG_ASSET_APPLY_SUCCESS$b,
    MSG_ASSET_TAB_SETTINGS_DESC: MSG_ASSET_TAB_SETTINGS_DESC$a,
    MSG_FILTER_TAG_NSFW_ENABLED: MSG_FILTER_TAG_NSFW_ENABLED$b,
    MSG_GAME_SELECTED: MSG_GAME_SELECTED$b,
    MSG_GAME_SELECTED_AND_ASSETS_FILTERED: MSG_GAME_SELECTED_AND_ASSETS_FILTERED$b,
    MSG_RESTART_STEAM_DESC: MSG_RESTART_STEAM_DESC$a,
    MSG_USAGE_INSTRUCTIONS: MSG_USAGE_INSTRUCTIONS$b,
    TITLE_MOTD_HIDE: TITLE_MOTD_HIDE$8,
    default: nl
});

var ASSET_TYPE_CAPSULE$b="Okładka";var ASSET_TYPE_WIDECAPSULE$b="Szeroka okładka";var ASSET_TYPE_HERO$b="Baner";var ASSET_TYPE_LOGO$b="Logo";var ASSET_TYPE_ICON$b="Ikona";var LABEL_TAB_CAPSULE$b="Okładka";var LABEL_TAB_WIDECAPSULE$b="Szeroka okładka";var LABEL_TAB_HERO$b="Baner";var LABEL_TAB_LOGO$b="Logo";var LABEL_TAB_ICON$b="Ikonka";var LABEL_TAB_MANAGE$b="Zarządzaj";var MSG_USAGE_INSTRUCTIONS$a="Wybierz grę {arrow} {optionsButton} {arrow} \"{ACTION_CHANGE_ARTWORK}\"";var ACTION_CHANGE_ARTWORK$b="Zmień okładkę...";var ACTION_SHOW_LINK_QR$b="Pokaż kod QR";var MSG_ASSET_TAB_SETTINGS_DESC$9="Zmień kolejność, ukryj nieużywane karty lub ustaw domyślną kartę, która otwiera się po kliknięciu \"{ACTION_CHANGE_ARTWORK}\"";var LABEL_USAGE_TITLE$a="Krótki przewodnik";var LABEL_SQUARE_CAPSULES$9="Kwadratowe okładki";var LABEL_SQUARE_CAPSULES_DESC$8="Wyświetlaj kwadratowe okładki zamiast domyślnych.";var LABEL_UNIFORM_RECENT$6="Jednolity format okładek";var LABEL_UNIFORM_RECENT_DESC$6="Spraw, aby okładka ostatnio uruchamianej gry wyglądała tak samo jak reszta okładek.";var LABEL_CAPSULE_GLOW$9="Efekt błysku na okładce";var LABEL_CAPSULE_GLOW_DESC$8="Dostosuj intensywność animacji błysku na okładkach w bibliotece.";var LABEL_CAPSULE_GLOW_OFF$9="Wyłącz";var LABEL_SETTINGS_ASSET_TABS$9="Ustawienia zakładek";var LABEL_SETTINGS_DISABLE_MOTD$7="Wyłącz komunikaty";var LABEL_SETTINGS_DISABLE_MOTD_DESC$6="Komunikaty pojawiają się rzadko i dotyczą istotnych informacji lub wydarzeń społeczności.";var LABEL_TRANSLATION_CREDIT_TITLE$b="Polskie tłumaczenie";var LABEL_MORE_SGDB_TITLE$b="Więcej od StreamGridDB";var ACTION_SGDB_DISCORD$b="Dołącz do Discorda";var ACTION_SGDB_GITHUB$a="Nasze projekty Open Source";var ACTION_SGDB_DONATE$b="Wesprzyj nas na Patreon";var ACTION_SGDB_TRANSLATE$b="Pomóż w tłumaczeniu";var ACTION_SGDB_BOOP$b="Sprawdź SGDBoop";var LABEL_RESTART_STEAM_TITLE$a="Uruchomić ponownie Steam?";var ACTION_RESTART_STEAM_LATER$a="Później";var ACTION_RESTART_STEAM_NOW$a="Uruchom ponownie teraz";var MSG_RESTART_STEAM_DESC$9="Program musi zostać uruchomiony ponownie, aby wprowadzić zmiany.";var LABEL_GAME_SEARCH_TITLE$b="Wyszukaj grę...";var LABEL_FILTER_MODAL_TITLE$b="Filtry - {assetType}";var LABEL_FILTER_GAME$b="Gra";var LABEL_FILTER_DIMENSIONS$b="Rozdzielczość";var LABEL_FILTER_STYLES$b="Styl";var LABEL_FILTER_FILE_TYPES$b="Rodzaj pliku";var LABEL_FILTER_ANIMATION_TYPE_TITLE$b="Wariant";var LABEL_FILTER_TYPE_ANIMATED$a="Animowany";var LABEL_FILTER_TYPE_STATIC$a="Statyczny";var LABEL_FILTER_TAGS_TITLE$b="Tagi";var LABEL_FILTER_TAG_NSFW$b="Treść dla dorosłych";var MSG_FILTER_TAG_NSFW_ENABLED$a="Rzuć okiem przez ramię, tak na wszelki wypadek :)";var LABEL_FILTER_TAG_HUMOR$a="Humor";var LABEL_FILTER_TAG_EPILEPSY$a="Epilepsja";var LABEL_FILTER_TAG_UNTAGGED$a="Bez Tagów";var ACTION_FILTER_RESET$b="Resetuj Filtry";var LABEL_BEGGING_MODAL_TITLE$9="Dzięki za używanie SteamGridDB!";var LABEL_BEGGING_MODAL_DESC$8="Twoje wsparcie się liczy! Nawet mała darowizna pomoże nam w utrzymaniu serwera i ogarnięciu spraw technicznych.";var ACTION_HIDE_POS_GUIDES$9="Ukryj podpowiedzi";var ACTION_SHOW_OUTLINE$9="Pokaż podpowiedzi";var ACTION_ADJUST_POS_SIZE$a="Dostosuj rozmiar";var ACTION_CHANGE_POS_LOGO_ANCHOR_POINT$6="Zmień punkt zaczepienia";var LABEL_ASSET_CURRENT$b="Aktualna {assetType}";var ACTION_ASSET_CUSTOM_CLEAR$b="Przywróć oryginalną okładkę";var ACTION_ASSET_BROWSE_LOCAL$a="Przeglądaj pliki lokalne";var ACTION_ASSET_APPLY_TRANSPARENT$a="Usuń okładkę";var LABEL_NOTES$b="Uwagi";var LABEL_ANIMATED$a="Animowana";var LABEL_NSFW$b="Treść dla dorosłych";var LABEL_HUMOR$a="Humor";var LABEL_EPILEPSY$a="Epilepsja";var ACTION_OPEN_FILTER$b="Filtruj";var ACTION_OPEN_OFFICIAL_ASSETS$a="Oryginalna okładka";var ACTION_ASSET_APPLY$a="Zastosuj okładkę";var MSG_GAME_SELECTED$a="Wybrano {gameName}";var MSG_ASSETS_FILTERED$a="Wygląda na to, że obecne filtrowanie może ukrywać niektóre grafiki.";var MSG_GAME_SELECTED_AND_ASSETS_FILTERED$a="Wybrano {gameName} z filtrowaniem";var TITLE_MOTD_HIDE$7="Czy chcesz ukryć ten komunikat?";var LABEL_MOTD_THIS$7="Tylko ten komunikat";var LABEL_MOTD_ALL$7="Wszystkie komunikaty";var MSG_ASSET_APPLY_SUCCESS$a="Okładka została zmieniona!";var MSG_ASSET_APPLY_ERROR$a="Wystąpił błąd przy próbie użycia tej okładki";var ACTION_OPEN_DETAILS$b="Szczegóły";var pl = {ASSET_TYPE_CAPSULE:ASSET_TYPE_CAPSULE$b,ASSET_TYPE_WIDECAPSULE:ASSET_TYPE_WIDECAPSULE$b,ASSET_TYPE_HERO:ASSET_TYPE_HERO$b,ASSET_TYPE_LOGO:ASSET_TYPE_LOGO$b,ASSET_TYPE_ICON:ASSET_TYPE_ICON$b,LABEL_TAB_CAPSULE:LABEL_TAB_CAPSULE$b,LABEL_TAB_WIDECAPSULE:LABEL_TAB_WIDECAPSULE$b,LABEL_TAB_HERO:LABEL_TAB_HERO$b,LABEL_TAB_LOGO:LABEL_TAB_LOGO$b,LABEL_TAB_ICON:LABEL_TAB_ICON$b,LABEL_TAB_MANAGE:LABEL_TAB_MANAGE$b,MSG_USAGE_INSTRUCTIONS:MSG_USAGE_INSTRUCTIONS$a,ACTION_CHANGE_ARTWORK:ACTION_CHANGE_ARTWORK$b,ACTION_SHOW_LINK_QR:ACTION_SHOW_LINK_QR$b,MSG_ASSET_TAB_SETTINGS_DESC:MSG_ASSET_TAB_SETTINGS_DESC$9,LABEL_USAGE_TITLE:LABEL_USAGE_TITLE$a,LABEL_SQUARE_CAPSULES:LABEL_SQUARE_CAPSULES$9,LABEL_SQUARE_CAPSULES_DESC:LABEL_SQUARE_CAPSULES_DESC$8,LABEL_UNIFORM_RECENT:LABEL_UNIFORM_RECENT$6,LABEL_UNIFORM_RECENT_DESC:LABEL_UNIFORM_RECENT_DESC$6,LABEL_CAPSULE_GLOW:LABEL_CAPSULE_GLOW$9,LABEL_CAPSULE_GLOW_DESC:LABEL_CAPSULE_GLOW_DESC$8,LABEL_CAPSULE_GLOW_OFF:LABEL_CAPSULE_GLOW_OFF$9,LABEL_SETTINGS_ASSET_TABS:LABEL_SETTINGS_ASSET_TABS$9,LABEL_SETTINGS_DISABLE_MOTD:LABEL_SETTINGS_DISABLE_MOTD$7,LABEL_SETTINGS_DISABLE_MOTD_DESC:LABEL_SETTINGS_DISABLE_MOTD_DESC$6,LABEL_TRANSLATION_CREDIT_TITLE:LABEL_TRANSLATION_CREDIT_TITLE$b,LABEL_MORE_SGDB_TITLE:LABEL_MORE_SGDB_TITLE$b,ACTION_SGDB_DISCORD:ACTION_SGDB_DISCORD$b,ACTION_SGDB_GITHUB:ACTION_SGDB_GITHUB$a,ACTION_SGDB_DONATE:ACTION_SGDB_DONATE$b,ACTION_SGDB_TRANSLATE:ACTION_SGDB_TRANSLATE$b,ACTION_SGDB_BOOP:ACTION_SGDB_BOOP$b,LABEL_RESTART_STEAM_TITLE:LABEL_RESTART_STEAM_TITLE$a,ACTION_RESTART_STEAM_LATER:ACTION_RESTART_STEAM_LATER$a,ACTION_RESTART_STEAM_NOW:ACTION_RESTART_STEAM_NOW$a,MSG_RESTART_STEAM_DESC:MSG_RESTART_STEAM_DESC$9,LABEL_GAME_SEARCH_TITLE:LABEL_GAME_SEARCH_TITLE$b,LABEL_FILTER_MODAL_TITLE:LABEL_FILTER_MODAL_TITLE$b,LABEL_FILTER_GAME:LABEL_FILTER_GAME$b,LABEL_FILTER_DIMENSIONS:LABEL_FILTER_DIMENSIONS$b,LABEL_FILTER_STYLES:LABEL_FILTER_STYLES$b,LABEL_FILTER_FILE_TYPES:LABEL_FILTER_FILE_TYPES$b,LABEL_FILTER_ANIMATION_TYPE_TITLE:LABEL_FILTER_ANIMATION_TYPE_TITLE$b,LABEL_FILTER_TYPE_ANIMATED:LABEL_FILTER_TYPE_ANIMATED$a,LABEL_FILTER_TYPE_STATIC:LABEL_FILTER_TYPE_STATIC$a,LABEL_FILTER_TAGS_TITLE:LABEL_FILTER_TAGS_TITLE$b,LABEL_FILTER_TAG_NSFW:LABEL_FILTER_TAG_NSFW$b,MSG_FILTER_TAG_NSFW_ENABLED:MSG_FILTER_TAG_NSFW_ENABLED$a,LABEL_FILTER_TAG_HUMOR:LABEL_FILTER_TAG_HUMOR$a,LABEL_FILTER_TAG_EPILEPSY:LABEL_FILTER_TAG_EPILEPSY$a,LABEL_FILTER_TAG_UNTAGGED:LABEL_FILTER_TAG_UNTAGGED$a,ACTION_FILTER_RESET:ACTION_FILTER_RESET$b,LABEL_BEGGING_MODAL_TITLE:LABEL_BEGGING_MODAL_TITLE$9,LABEL_BEGGING_MODAL_DESC:LABEL_BEGGING_MODAL_DESC$8,ACTION_HIDE_POS_GUIDES:ACTION_HIDE_POS_GUIDES$9,ACTION_SHOW_OUTLINE:ACTION_SHOW_OUTLINE$9,ACTION_ADJUST_POS_SIZE:ACTION_ADJUST_POS_SIZE$a,ACTION_CHANGE_POS_LOGO_ANCHOR_POINT:ACTION_CHANGE_POS_LOGO_ANCHOR_POINT$6,LABEL_ASSET_CURRENT:LABEL_ASSET_CURRENT$b,ACTION_ASSET_CUSTOM_CLEAR:ACTION_ASSET_CUSTOM_CLEAR$b,ACTION_ASSET_BROWSE_LOCAL:ACTION_ASSET_BROWSE_LOCAL$a,ACTION_ASSET_APPLY_TRANSPARENT:ACTION_ASSET_APPLY_TRANSPARENT$a,LABEL_NOTES:LABEL_NOTES$b,LABEL_ANIMATED:LABEL_ANIMATED$a,LABEL_NSFW:LABEL_NSFW$b,LABEL_HUMOR:LABEL_HUMOR$a,LABEL_EPILEPSY:LABEL_EPILEPSY$a,ACTION_OPEN_FILTER:ACTION_OPEN_FILTER$b,ACTION_OPEN_OFFICIAL_ASSETS:ACTION_OPEN_OFFICIAL_ASSETS$a,ACTION_ASSET_APPLY:ACTION_ASSET_APPLY$a,MSG_GAME_SELECTED:MSG_GAME_SELECTED$a,MSG_ASSETS_FILTERED:MSG_ASSETS_FILTERED$a,MSG_GAME_SELECTED_AND_ASSETS_FILTERED:MSG_GAME_SELECTED_AND_ASSETS_FILTERED$a,TITLE_MOTD_HIDE:TITLE_MOTD_HIDE$7,LABEL_MOTD_THIS:LABEL_MOTD_THIS$7,LABEL_MOTD_ALL:LABEL_MOTD_ALL$7,MSG_ASSET_APPLY_SUCCESS:MSG_ASSET_APPLY_SUCCESS$a,MSG_ASSET_APPLY_ERROR:MSG_ASSET_APPLY_ERROR$a,ACTION_OPEN_DETAILS:ACTION_OPEN_DETAILS$b};

var pl$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    ACTION_ADJUST_POS_SIZE: ACTION_ADJUST_POS_SIZE$a,
    ACTION_ASSET_APPLY: ACTION_ASSET_APPLY$a,
    ACTION_ASSET_APPLY_TRANSPARENT: ACTION_ASSET_APPLY_TRANSPARENT$a,
    ACTION_ASSET_BROWSE_LOCAL: ACTION_ASSET_BROWSE_LOCAL$a,
    ACTION_ASSET_CUSTOM_CLEAR: ACTION_ASSET_CUSTOM_CLEAR$b,
    ACTION_CHANGE_ARTWORK: ACTION_CHANGE_ARTWORK$b,
    ACTION_CHANGE_POS_LOGO_ANCHOR_POINT: ACTION_CHANGE_POS_LOGO_ANCHOR_POINT$6,
    ACTION_FILTER_RESET: ACTION_FILTER_RESET$b,
    ACTION_HIDE_POS_GUIDES: ACTION_HIDE_POS_GUIDES$9,
    ACTION_OPEN_DETAILS: ACTION_OPEN_DETAILS$b,
    ACTION_OPEN_FILTER: ACTION_OPEN_FILTER$b,
    ACTION_OPEN_OFFICIAL_ASSETS: ACTION_OPEN_OFFICIAL_ASSETS$a,
    ACTION_RESTART_STEAM_LATER: ACTION_RESTART_STEAM_LATER$a,
    ACTION_RESTART_STEAM_NOW: ACTION_RESTART_STEAM_NOW$a,
    ACTION_SGDB_BOOP: ACTION_SGDB_BOOP$b,
    ACTION_SGDB_DISCORD: ACTION_SGDB_DISCORD$b,
    ACTION_SGDB_DONATE: ACTION_SGDB_DONATE$b,
    ACTION_SGDB_GITHUB: ACTION_SGDB_GITHUB$a,
    ACTION_SGDB_TRANSLATE: ACTION_SGDB_TRANSLATE$b,
    ACTION_SHOW_LINK_QR: ACTION_SHOW_LINK_QR$b,
    ACTION_SHOW_OUTLINE: ACTION_SHOW_OUTLINE$9,
    ASSET_TYPE_CAPSULE: ASSET_TYPE_CAPSULE$b,
    ASSET_TYPE_HERO: ASSET_TYPE_HERO$b,
    ASSET_TYPE_ICON: ASSET_TYPE_ICON$b,
    ASSET_TYPE_LOGO: ASSET_TYPE_LOGO$b,
    ASSET_TYPE_WIDECAPSULE: ASSET_TYPE_WIDECAPSULE$b,
    LABEL_ANIMATED: LABEL_ANIMATED$a,
    LABEL_ASSET_CURRENT: LABEL_ASSET_CURRENT$b,
    LABEL_BEGGING_MODAL_DESC: LABEL_BEGGING_MODAL_DESC$8,
    LABEL_BEGGING_MODAL_TITLE: LABEL_BEGGING_MODAL_TITLE$9,
    LABEL_CAPSULE_GLOW: LABEL_CAPSULE_GLOW$9,
    LABEL_CAPSULE_GLOW_DESC: LABEL_CAPSULE_GLOW_DESC$8,
    LABEL_CAPSULE_GLOW_OFF: LABEL_CAPSULE_GLOW_OFF$9,
    LABEL_EPILEPSY: LABEL_EPILEPSY$a,
    LABEL_FILTER_ANIMATION_TYPE_TITLE: LABEL_FILTER_ANIMATION_TYPE_TITLE$b,
    LABEL_FILTER_DIMENSIONS: LABEL_FILTER_DIMENSIONS$b,
    LABEL_FILTER_FILE_TYPES: LABEL_FILTER_FILE_TYPES$b,
    LABEL_FILTER_GAME: LABEL_FILTER_GAME$b,
    LABEL_FILTER_MODAL_TITLE: LABEL_FILTER_MODAL_TITLE$b,
    LABEL_FILTER_STYLES: LABEL_FILTER_STYLES$b,
    LABEL_FILTER_TAGS_TITLE: LABEL_FILTER_TAGS_TITLE$b,
    LABEL_FILTER_TAG_EPILEPSY: LABEL_FILTER_TAG_EPILEPSY$a,
    LABEL_FILTER_TAG_HUMOR: LABEL_FILTER_TAG_HUMOR$a,
    LABEL_FILTER_TAG_NSFW: LABEL_FILTER_TAG_NSFW$b,
    LABEL_FILTER_TAG_UNTAGGED: LABEL_FILTER_TAG_UNTAGGED$a,
    LABEL_FILTER_TYPE_ANIMATED: LABEL_FILTER_TYPE_ANIMATED$a,
    LABEL_FILTER_TYPE_STATIC: LABEL_FILTER_TYPE_STATIC$a,
    LABEL_GAME_SEARCH_TITLE: LABEL_GAME_SEARCH_TITLE$b,
    LABEL_HUMOR: LABEL_HUMOR$a,
    LABEL_MORE_SGDB_TITLE: LABEL_MORE_SGDB_TITLE$b,
    LABEL_MOTD_ALL: LABEL_MOTD_ALL$7,
    LABEL_MOTD_THIS: LABEL_MOTD_THIS$7,
    LABEL_NOTES: LABEL_NOTES$b,
    LABEL_NSFW: LABEL_NSFW$b,
    LABEL_RESTART_STEAM_TITLE: LABEL_RESTART_STEAM_TITLE$a,
    LABEL_SETTINGS_ASSET_TABS: LABEL_SETTINGS_ASSET_TABS$9,
    LABEL_SETTINGS_DISABLE_MOTD: LABEL_SETTINGS_DISABLE_MOTD$7,
    LABEL_SETTINGS_DISABLE_MOTD_DESC: LABEL_SETTINGS_DISABLE_MOTD_DESC$6,
    LABEL_SQUARE_CAPSULES: LABEL_SQUARE_CAPSULES$9,
    LABEL_SQUARE_CAPSULES_DESC: LABEL_SQUARE_CAPSULES_DESC$8,
    LABEL_TAB_CAPSULE: LABEL_TAB_CAPSULE$b,
    LABEL_TAB_HERO: LABEL_TAB_HERO$b,
    LABEL_TAB_ICON: LABEL_TAB_ICON$b,
    LABEL_TAB_LOGO: LABEL_TAB_LOGO$b,
    LABEL_TAB_MANAGE: LABEL_TAB_MANAGE$b,
    LABEL_TAB_WIDECAPSULE: LABEL_TAB_WIDECAPSULE$b,
    LABEL_TRANSLATION_CREDIT_TITLE: LABEL_TRANSLATION_CREDIT_TITLE$b,
    LABEL_UNIFORM_RECENT: LABEL_UNIFORM_RECENT$6,
    LABEL_UNIFORM_RECENT_DESC: LABEL_UNIFORM_RECENT_DESC$6,
    LABEL_USAGE_TITLE: LABEL_USAGE_TITLE$a,
    MSG_ASSETS_FILTERED: MSG_ASSETS_FILTERED$a,
    MSG_ASSET_APPLY_ERROR: MSG_ASSET_APPLY_ERROR$a,
    MSG_ASSET_APPLY_SUCCESS: MSG_ASSET_APPLY_SUCCESS$a,
    MSG_ASSET_TAB_SETTINGS_DESC: MSG_ASSET_TAB_SETTINGS_DESC$9,
    MSG_FILTER_TAG_NSFW_ENABLED: MSG_FILTER_TAG_NSFW_ENABLED$a,
    MSG_GAME_SELECTED: MSG_GAME_SELECTED$a,
    MSG_GAME_SELECTED_AND_ASSETS_FILTERED: MSG_GAME_SELECTED_AND_ASSETS_FILTERED$a,
    MSG_RESTART_STEAM_DESC: MSG_RESTART_STEAM_DESC$9,
    MSG_USAGE_INSTRUCTIONS: MSG_USAGE_INSTRUCTIONS$a,
    TITLE_MOTD_HIDE: TITLE_MOTD_HIDE$7,
    default: pl
});

var ASSET_TYPE_CAPSULE$a="cápsula";var ASSET_TYPE_WIDECAPSULE$a="faixa";var ASSET_TYPE_HERO$a="cabeçalho";var ASSET_TYPE_LOGO$a="logótipo";var ASSET_TYPE_ICON$a="ícone";var LABEL_TAB_CAPSULE$a="Cápsula";var LABEL_TAB_WIDECAPSULE$a="Faixa";var LABEL_TAB_HERO$a="Cabeçalho";var LABEL_TAB_LOGO$a="Logótipo";var LABEL_TAB_ICON$a="Ícone";var LABEL_TAB_MANAGE$a="Gerir";var MSG_USAGE_INSTRUCTIONS$9="Escolhe um jogo {arrow} {optionsButton} {arrow} \"{ACTION_CHANGE_ARTWORK}\"";var ACTION_CHANGE_ARTWORK$a="Alterar imagens...";var ACTION_SHOW_LINK_QR$a="Mostrar QR do link";var MSG_ASSET_TAB_SETTINGS_DESC$8="Ordena ou esconde separadores inutilizados, e define o separador que abre ao selecionar \"{ACTION_CHANGE_ARTWORK}\"";var LABEL_USAGE_TITLE$9="Perdido? Aqui está um guia rápido";var LABEL_SQUARE_CAPSULES$8="Cápsulas quadradas";var LABEL_SQUARE_CAPSULES_DESC$7="Usa cápsulas quadradas em vez de verticais. Filtros de imagens quadradas irão ser selecionados automaticamente.";var LABEL_UNIFORM_RECENT$5="Igualar a cápsula recente";var LABEL_UNIFORM_RECENT_DESC$5="Faz com que o jogo mais recentemente jogado no ecrã inicial tenha uma aparência igual ao resto das cápsulas.";var LABEL_CAPSULE_GLOW$8="Brilho da cápsula";var LABEL_CAPSULE_GLOW_DESC$7="Ajusta a intensidade do brilho na biblioteca.";var LABEL_CAPSULE_GLOW_OFF$8="Nenhum";var LABEL_SETTINGS_ASSET_TABS$8="Definições dos separadores de imagens";var LABEL_SETTINGS_DISABLE_MOTD$6="Desativar anúncios";var LABEL_SETTINGS_DISABLE_MOTD_DESC$5="Anúncios são usados esporadicamente para exibir informação importante ou eventos comunitários.";var LABEL_TRANSLATION_CREDIT_TITLE$a="Tradução portuguesa";var LABEL_MORE_SGDB_TITLE$a="Mais da SteamGridDB";var ACTION_SGDB_DISCORD$a="Entra no Discord";var ACTION_SGDB_GITHUB$9="Projetos de código aberto";var ACTION_SGDB_DONATE$a="Apoie-nos no Patreon";var ACTION_SGDB_TRANSLATE$a="Ajuda a traduzir";var ACTION_SGDB_BOOP$a="Espreita o SGDBoop";var LABEL_RESTART_STEAM_TITLE$9="Reiniciar o Steam?";var ACTION_RESTART_STEAM_LATER$9="Mais tarde";var ACTION_RESTART_STEAM_NOW$9="Reiniciar agora";var MSG_RESTART_STEAM_DESC$8="O Steam precisa de ser reiniciado para as alterações serem aplicadas.";var LABEL_GAME_SEARCH_TITLE$a="Procura por um jogo...";var LABEL_FILTER_MODAL_TITLE$a="Filtro de {assetType}s";var LABEL_FILTER_GAME$a="Jogo";var LABEL_FILTER_DIMENSIONS$a="Dimensões";var LABEL_FILTER_STYLES$a="Estilos";var LABEL_FILTER_FILE_TYPES$a="Tipos de ficheiro";var LABEL_FILTER_ANIMATION_TYPE_TITLE$a="Tipos";var LABEL_FILTER_TYPE_ANIMATED$9="Animado";var LABEL_FILTER_TYPE_STATIC$9="Estático";var LABEL_FILTER_TAGS_TITLE$a="Etiquetas";var LABEL_FILTER_TAG_NSFW$a="Conteúdo adulto";var MSG_FILTER_TAG_NSFW_ENABLED$9="É melhor ver se não há ninguém por perto.";var LABEL_FILTER_TAG_HUMOR$9="Humor";var LABEL_FILTER_TAG_EPILEPSY$9="Epilepsia";var LABEL_FILTER_TAG_UNTAGGED$9="Sem etiqueta";var ACTION_FILTER_RESET$a="Limpar filtros";var LABEL_BEGGING_MODAL_TITLE$8="Obrigado por usar o SteamGridDB!";var LABEL_BEGGING_MODAL_DESC$7="Considere fazer um donativo para ajudar na manutenção e nos custos do servidor!";var ACTION_HIDE_POS_GUIDES$8="Esconder guias";var ACTION_SHOW_OUTLINE$8="Mostrar guias";var ACTION_ADJUST_POS_SIZE$9="Ajustar tamanho";var ACTION_CHANGE_POS_LOGO_ANCHOR_POINT$5="Alterar ponto de ancoragem";var LABEL_ASSET_CURRENT$a="{assetType} atual";var ACTION_ASSET_CUSTOM_CLEAR$a="Eliminar imagem personalizada";var ACTION_ASSET_BROWSE_LOCAL$9="Procurar em ficheiros locais";var ACTION_ASSET_APPLY_TRANSPARENT$9="Usar imagem invisível";var LABEL_NOTES$a="Notas";var LABEL_ANIMATED$9="Animado";var LABEL_NSFW$a="Conteúdo adulto";var LABEL_HUMOR$9="Humor";var LABEL_EPILEPSY$9="Epilepsia";var ACTION_OPEN_FILTER$a="Filtrar";var ACTION_OPEN_OFFICIAL_ASSETS$9="Arte oficial";var ACTION_ASSET_APPLY$9="Aplicar {assetType}";var MSG_GAME_SELECTED$9="Selecionou {gameName}";var MSG_ASSETS_FILTERED$9="Algumas imagens podem estar escondidas devido a filtros";var MSG_GAME_SELECTED_AND_ASSETS_FILTERED$9="Selecionou {gameName} com filtros";var TITLE_MOTD_HIDE$6="Esconder o anúncio?";var LABEL_MOTD_THIS$6="Este anúncio";var LABEL_MOTD_ALL$6="Todos os anúncios";var MSG_ASSET_APPLY_SUCCESS$9="{assetType} foi aplicado/a com sucesso!";var MSG_ASSET_APPLY_ERROR$9="Houve um problema ao aplicar esta imagem.";var ACTION_OPEN_DETAILS$a="Detalhes";var pt = {ASSET_TYPE_CAPSULE:ASSET_TYPE_CAPSULE$a,ASSET_TYPE_WIDECAPSULE:ASSET_TYPE_WIDECAPSULE$a,ASSET_TYPE_HERO:ASSET_TYPE_HERO$a,ASSET_TYPE_LOGO:ASSET_TYPE_LOGO$a,ASSET_TYPE_ICON:ASSET_TYPE_ICON$a,LABEL_TAB_CAPSULE:LABEL_TAB_CAPSULE$a,LABEL_TAB_WIDECAPSULE:LABEL_TAB_WIDECAPSULE$a,LABEL_TAB_HERO:LABEL_TAB_HERO$a,LABEL_TAB_LOGO:LABEL_TAB_LOGO$a,LABEL_TAB_ICON:LABEL_TAB_ICON$a,LABEL_TAB_MANAGE:LABEL_TAB_MANAGE$a,MSG_USAGE_INSTRUCTIONS:MSG_USAGE_INSTRUCTIONS$9,ACTION_CHANGE_ARTWORK:ACTION_CHANGE_ARTWORK$a,ACTION_SHOW_LINK_QR:ACTION_SHOW_LINK_QR$a,MSG_ASSET_TAB_SETTINGS_DESC:MSG_ASSET_TAB_SETTINGS_DESC$8,LABEL_USAGE_TITLE:LABEL_USAGE_TITLE$9,LABEL_SQUARE_CAPSULES:LABEL_SQUARE_CAPSULES$8,LABEL_SQUARE_CAPSULES_DESC:LABEL_SQUARE_CAPSULES_DESC$7,LABEL_UNIFORM_RECENT:LABEL_UNIFORM_RECENT$5,LABEL_UNIFORM_RECENT_DESC:LABEL_UNIFORM_RECENT_DESC$5,LABEL_CAPSULE_GLOW:LABEL_CAPSULE_GLOW$8,LABEL_CAPSULE_GLOW_DESC:LABEL_CAPSULE_GLOW_DESC$7,LABEL_CAPSULE_GLOW_OFF:LABEL_CAPSULE_GLOW_OFF$8,LABEL_SETTINGS_ASSET_TABS:LABEL_SETTINGS_ASSET_TABS$8,LABEL_SETTINGS_DISABLE_MOTD:LABEL_SETTINGS_DISABLE_MOTD$6,LABEL_SETTINGS_DISABLE_MOTD_DESC:LABEL_SETTINGS_DISABLE_MOTD_DESC$5,LABEL_TRANSLATION_CREDIT_TITLE:LABEL_TRANSLATION_CREDIT_TITLE$a,LABEL_MORE_SGDB_TITLE:LABEL_MORE_SGDB_TITLE$a,ACTION_SGDB_DISCORD:ACTION_SGDB_DISCORD$a,ACTION_SGDB_GITHUB:ACTION_SGDB_GITHUB$9,ACTION_SGDB_DONATE:ACTION_SGDB_DONATE$a,ACTION_SGDB_TRANSLATE:ACTION_SGDB_TRANSLATE$a,ACTION_SGDB_BOOP:ACTION_SGDB_BOOP$a,LABEL_RESTART_STEAM_TITLE:LABEL_RESTART_STEAM_TITLE$9,ACTION_RESTART_STEAM_LATER:ACTION_RESTART_STEAM_LATER$9,ACTION_RESTART_STEAM_NOW:ACTION_RESTART_STEAM_NOW$9,MSG_RESTART_STEAM_DESC:MSG_RESTART_STEAM_DESC$8,LABEL_GAME_SEARCH_TITLE:LABEL_GAME_SEARCH_TITLE$a,LABEL_FILTER_MODAL_TITLE:LABEL_FILTER_MODAL_TITLE$a,LABEL_FILTER_GAME:LABEL_FILTER_GAME$a,LABEL_FILTER_DIMENSIONS:LABEL_FILTER_DIMENSIONS$a,LABEL_FILTER_STYLES:LABEL_FILTER_STYLES$a,LABEL_FILTER_FILE_TYPES:LABEL_FILTER_FILE_TYPES$a,LABEL_FILTER_ANIMATION_TYPE_TITLE:LABEL_FILTER_ANIMATION_TYPE_TITLE$a,LABEL_FILTER_TYPE_ANIMATED:LABEL_FILTER_TYPE_ANIMATED$9,LABEL_FILTER_TYPE_STATIC:LABEL_FILTER_TYPE_STATIC$9,LABEL_FILTER_TAGS_TITLE:LABEL_FILTER_TAGS_TITLE$a,LABEL_FILTER_TAG_NSFW:LABEL_FILTER_TAG_NSFW$a,MSG_FILTER_TAG_NSFW_ENABLED:MSG_FILTER_TAG_NSFW_ENABLED$9,LABEL_FILTER_TAG_HUMOR:LABEL_FILTER_TAG_HUMOR$9,LABEL_FILTER_TAG_EPILEPSY:LABEL_FILTER_TAG_EPILEPSY$9,LABEL_FILTER_TAG_UNTAGGED:LABEL_FILTER_TAG_UNTAGGED$9,ACTION_FILTER_RESET:ACTION_FILTER_RESET$a,LABEL_BEGGING_MODAL_TITLE:LABEL_BEGGING_MODAL_TITLE$8,LABEL_BEGGING_MODAL_DESC:LABEL_BEGGING_MODAL_DESC$7,ACTION_HIDE_POS_GUIDES:ACTION_HIDE_POS_GUIDES$8,ACTION_SHOW_OUTLINE:ACTION_SHOW_OUTLINE$8,ACTION_ADJUST_POS_SIZE:ACTION_ADJUST_POS_SIZE$9,ACTION_CHANGE_POS_LOGO_ANCHOR_POINT:ACTION_CHANGE_POS_LOGO_ANCHOR_POINT$5,LABEL_ASSET_CURRENT:LABEL_ASSET_CURRENT$a,ACTION_ASSET_CUSTOM_CLEAR:ACTION_ASSET_CUSTOM_CLEAR$a,ACTION_ASSET_BROWSE_LOCAL:ACTION_ASSET_BROWSE_LOCAL$9,ACTION_ASSET_APPLY_TRANSPARENT:ACTION_ASSET_APPLY_TRANSPARENT$9,LABEL_NOTES:LABEL_NOTES$a,LABEL_ANIMATED:LABEL_ANIMATED$9,LABEL_NSFW:LABEL_NSFW$a,LABEL_HUMOR:LABEL_HUMOR$9,LABEL_EPILEPSY:LABEL_EPILEPSY$9,ACTION_OPEN_FILTER:ACTION_OPEN_FILTER$a,ACTION_OPEN_OFFICIAL_ASSETS:ACTION_OPEN_OFFICIAL_ASSETS$9,ACTION_ASSET_APPLY:ACTION_ASSET_APPLY$9,MSG_GAME_SELECTED:MSG_GAME_SELECTED$9,MSG_ASSETS_FILTERED:MSG_ASSETS_FILTERED$9,MSG_GAME_SELECTED_AND_ASSETS_FILTERED:MSG_GAME_SELECTED_AND_ASSETS_FILTERED$9,TITLE_MOTD_HIDE:TITLE_MOTD_HIDE$6,LABEL_MOTD_THIS:LABEL_MOTD_THIS$6,LABEL_MOTD_ALL:LABEL_MOTD_ALL$6,MSG_ASSET_APPLY_SUCCESS:MSG_ASSET_APPLY_SUCCESS$9,MSG_ASSET_APPLY_ERROR:MSG_ASSET_APPLY_ERROR$9,ACTION_OPEN_DETAILS:ACTION_OPEN_DETAILS$a};

var pt$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    ACTION_ADJUST_POS_SIZE: ACTION_ADJUST_POS_SIZE$9,
    ACTION_ASSET_APPLY: ACTION_ASSET_APPLY$9,
    ACTION_ASSET_APPLY_TRANSPARENT: ACTION_ASSET_APPLY_TRANSPARENT$9,
    ACTION_ASSET_BROWSE_LOCAL: ACTION_ASSET_BROWSE_LOCAL$9,
    ACTION_ASSET_CUSTOM_CLEAR: ACTION_ASSET_CUSTOM_CLEAR$a,
    ACTION_CHANGE_ARTWORK: ACTION_CHANGE_ARTWORK$a,
    ACTION_CHANGE_POS_LOGO_ANCHOR_POINT: ACTION_CHANGE_POS_LOGO_ANCHOR_POINT$5,
    ACTION_FILTER_RESET: ACTION_FILTER_RESET$a,
    ACTION_HIDE_POS_GUIDES: ACTION_HIDE_POS_GUIDES$8,
    ACTION_OPEN_DETAILS: ACTION_OPEN_DETAILS$a,
    ACTION_OPEN_FILTER: ACTION_OPEN_FILTER$a,
    ACTION_OPEN_OFFICIAL_ASSETS: ACTION_OPEN_OFFICIAL_ASSETS$9,
    ACTION_RESTART_STEAM_LATER: ACTION_RESTART_STEAM_LATER$9,
    ACTION_RESTART_STEAM_NOW: ACTION_RESTART_STEAM_NOW$9,
    ACTION_SGDB_BOOP: ACTION_SGDB_BOOP$a,
    ACTION_SGDB_DISCORD: ACTION_SGDB_DISCORD$a,
    ACTION_SGDB_DONATE: ACTION_SGDB_DONATE$a,
    ACTION_SGDB_GITHUB: ACTION_SGDB_GITHUB$9,
    ACTION_SGDB_TRANSLATE: ACTION_SGDB_TRANSLATE$a,
    ACTION_SHOW_LINK_QR: ACTION_SHOW_LINK_QR$a,
    ACTION_SHOW_OUTLINE: ACTION_SHOW_OUTLINE$8,
    ASSET_TYPE_CAPSULE: ASSET_TYPE_CAPSULE$a,
    ASSET_TYPE_HERO: ASSET_TYPE_HERO$a,
    ASSET_TYPE_ICON: ASSET_TYPE_ICON$a,
    ASSET_TYPE_LOGO: ASSET_TYPE_LOGO$a,
    ASSET_TYPE_WIDECAPSULE: ASSET_TYPE_WIDECAPSULE$a,
    LABEL_ANIMATED: LABEL_ANIMATED$9,
    LABEL_ASSET_CURRENT: LABEL_ASSET_CURRENT$a,
    LABEL_BEGGING_MODAL_DESC: LABEL_BEGGING_MODAL_DESC$7,
    LABEL_BEGGING_MODAL_TITLE: LABEL_BEGGING_MODAL_TITLE$8,
    LABEL_CAPSULE_GLOW: LABEL_CAPSULE_GLOW$8,
    LABEL_CAPSULE_GLOW_DESC: LABEL_CAPSULE_GLOW_DESC$7,
    LABEL_CAPSULE_GLOW_OFF: LABEL_CAPSULE_GLOW_OFF$8,
    LABEL_EPILEPSY: LABEL_EPILEPSY$9,
    LABEL_FILTER_ANIMATION_TYPE_TITLE: LABEL_FILTER_ANIMATION_TYPE_TITLE$a,
    LABEL_FILTER_DIMENSIONS: LABEL_FILTER_DIMENSIONS$a,
    LABEL_FILTER_FILE_TYPES: LABEL_FILTER_FILE_TYPES$a,
    LABEL_FILTER_GAME: LABEL_FILTER_GAME$a,
    LABEL_FILTER_MODAL_TITLE: LABEL_FILTER_MODAL_TITLE$a,
    LABEL_FILTER_STYLES: LABEL_FILTER_STYLES$a,
    LABEL_FILTER_TAGS_TITLE: LABEL_FILTER_TAGS_TITLE$a,
    LABEL_FILTER_TAG_EPILEPSY: LABEL_FILTER_TAG_EPILEPSY$9,
    LABEL_FILTER_TAG_HUMOR: LABEL_FILTER_TAG_HUMOR$9,
    LABEL_FILTER_TAG_NSFW: LABEL_FILTER_TAG_NSFW$a,
    LABEL_FILTER_TAG_UNTAGGED: LABEL_FILTER_TAG_UNTAGGED$9,
    LABEL_FILTER_TYPE_ANIMATED: LABEL_FILTER_TYPE_ANIMATED$9,
    LABEL_FILTER_TYPE_STATIC: LABEL_FILTER_TYPE_STATIC$9,
    LABEL_GAME_SEARCH_TITLE: LABEL_GAME_SEARCH_TITLE$a,
    LABEL_HUMOR: LABEL_HUMOR$9,
    LABEL_MORE_SGDB_TITLE: LABEL_MORE_SGDB_TITLE$a,
    LABEL_MOTD_ALL: LABEL_MOTD_ALL$6,
    LABEL_MOTD_THIS: LABEL_MOTD_THIS$6,
    LABEL_NOTES: LABEL_NOTES$a,
    LABEL_NSFW: LABEL_NSFW$a,
    LABEL_RESTART_STEAM_TITLE: LABEL_RESTART_STEAM_TITLE$9,
    LABEL_SETTINGS_ASSET_TABS: LABEL_SETTINGS_ASSET_TABS$8,
    LABEL_SETTINGS_DISABLE_MOTD: LABEL_SETTINGS_DISABLE_MOTD$6,
    LABEL_SETTINGS_DISABLE_MOTD_DESC: LABEL_SETTINGS_DISABLE_MOTD_DESC$5,
    LABEL_SQUARE_CAPSULES: LABEL_SQUARE_CAPSULES$8,
    LABEL_SQUARE_CAPSULES_DESC: LABEL_SQUARE_CAPSULES_DESC$7,
    LABEL_TAB_CAPSULE: LABEL_TAB_CAPSULE$a,
    LABEL_TAB_HERO: LABEL_TAB_HERO$a,
    LABEL_TAB_ICON: LABEL_TAB_ICON$a,
    LABEL_TAB_LOGO: LABEL_TAB_LOGO$a,
    LABEL_TAB_MANAGE: LABEL_TAB_MANAGE$a,
    LABEL_TAB_WIDECAPSULE: LABEL_TAB_WIDECAPSULE$a,
    LABEL_TRANSLATION_CREDIT_TITLE: LABEL_TRANSLATION_CREDIT_TITLE$a,
    LABEL_UNIFORM_RECENT: LABEL_UNIFORM_RECENT$5,
    LABEL_UNIFORM_RECENT_DESC: LABEL_UNIFORM_RECENT_DESC$5,
    LABEL_USAGE_TITLE: LABEL_USAGE_TITLE$9,
    MSG_ASSETS_FILTERED: MSG_ASSETS_FILTERED$9,
    MSG_ASSET_APPLY_ERROR: MSG_ASSET_APPLY_ERROR$9,
    MSG_ASSET_APPLY_SUCCESS: MSG_ASSET_APPLY_SUCCESS$9,
    MSG_ASSET_TAB_SETTINGS_DESC: MSG_ASSET_TAB_SETTINGS_DESC$8,
    MSG_FILTER_TAG_NSFW_ENABLED: MSG_FILTER_TAG_NSFW_ENABLED$9,
    MSG_GAME_SELECTED: MSG_GAME_SELECTED$9,
    MSG_GAME_SELECTED_AND_ASSETS_FILTERED: MSG_GAME_SELECTED_AND_ASSETS_FILTERED$9,
    MSG_RESTART_STEAM_DESC: MSG_RESTART_STEAM_DESC$8,
    MSG_USAGE_INSTRUCTIONS: MSG_USAGE_INSTRUCTIONS$9,
    TITLE_MOTD_HIDE: TITLE_MOTD_HIDE$6,
    default: pt
});

var ASSET_TYPE_CAPSULE$9="cápsula";var ASSET_TYPE_WIDECAPSULE$9="faixa";var ASSET_TYPE_HERO$9="cabeçalho";var ASSET_TYPE_LOGO$9="logotipo";var ASSET_TYPE_ICON$9="ícone";var LABEL_TAB_CAPSULE$9="Cápsula";var LABEL_TAB_WIDECAPSULE$9="Faixa";var LABEL_TAB_HERO$9="Cabeçalho";var LABEL_TAB_LOGO$9="Logótipo";var LABEL_TAB_ICON$9="Ícone";var LABEL_TAB_MANAGE$9="Gerenciar";var MSG_USAGE_INSTRUCTIONS$8="Escolha um jogo {arrow} {optionsButton} {arrow} \"{ACTION_CHANGE_ARTWORK}\"";var ACTION_CHANGE_ARTWORK$9="Alterar Arte do Jogo...";var ACTION_SHOW_LINK_QR$9="Mostrar QR do Link";var MSG_ASSET_TAB_SETTINGS_DESC$7="Reorganizar ou ocultar abas não utilizadas, e definir a aba padrão a ser aberta quando utilizar \"{ACTION_CHANGE_ARTWORK}\"";var LABEL_USAGE_TITLE$8="Perdido? Aqui está um Guia Rápido";var LABEL_SQUARE_CAPSULES$7="Cápsulas Quadradas";var LABEL_SQUARE_CAPSULES_DESC$6="Use cápsulas quadradas ao invés de cápsulas verticais (padrão). Os filtros quadrados serão selecionados automaticamente.";var LABEL_CAPSULE_GLOW$7="Cápsula Brilhante";var LABEL_CAPSULE_GLOW_DESC$6="Ajustar a intensidade do brilho da cápsula na biblioteca.";var LABEL_CAPSULE_GLOW_OFF$7="Nenhum";var LABEL_SETTINGS_ASSET_TABS$7="Configurações de Abas de Conteúdo";var LABEL_TRANSLATION_CREDIT_TITLE$9="Tradução PT-BR";var LABEL_MORE_SGDB_TITLE$9="Mais do SteamGridDB";var ACTION_SGDB_DISCORD$9="Entrar no Discord";var ACTION_SGDB_GITHUB$8="Projetos com Código Aberto";var ACTION_SGDB_DONATE$9="Apoie-nos no Patreon";var ACTION_SGDB_TRANSLATE$9="Ajude a Traduzir";var ACTION_SGDB_BOOP$9="Veja o SGDBoop";var LABEL_RESTART_STEAM_TITLE$8="Reiniciar o Steam?";var ACTION_RESTART_STEAM_LATER$8="Mais Tarde";var ACTION_RESTART_STEAM_NOW$8="Reiniciar Agora";var MSG_RESTART_STEAM_DESC$7="O Steam precisa ser reiniciado para as alterações terem efeito.";var LABEL_GAME_SEARCH_TITLE$9="Procurar jogo...";var LABEL_FILTER_MODAL_TITLE$9="Filtro de {assetType}s";var LABEL_FILTER_GAME$9="Jogo";var LABEL_FILTER_DIMENSIONS$9="Dimensões";var LABEL_FILTER_STYLES$9="Estilos";var LABEL_FILTER_FILE_TYPES$9="Tipos de Arquivo";var LABEL_FILTER_ANIMATION_TYPE_TITLE$9="Tipos";var LABEL_FILTER_TYPE_ANIMATED$8="Animado";var LABEL_FILTER_TYPE_STATIC$8="Inerte";var LABEL_FILTER_TAGS_TITLE$9="Etiquetas";var LABEL_FILTER_TAG_NSFW$9="Conteúdo Adulto";var MSG_FILTER_TAG_NSFW_ENABLED$8="Verifique se não tem ninguém olhando antes.";var LABEL_FILTER_TAG_HUMOR$8="Humor";var LABEL_FILTER_TAG_EPILEPSY$8="Epilepsia";var LABEL_FILTER_TAG_UNTAGGED$8="Sem Etiqueta";var ACTION_FILTER_RESET$9="Limpar Filtros";var LABEL_BEGGING_MODAL_TITLE$7="Obrigado por usar o SteamGridDB!";var LABEL_BEGGING_MODAL_DESC$6="Por favor, considere fazer uma doação para ajudar com custos de manutenção e servidor!";var ACTION_HIDE_POS_GUIDES$7="Ocultar Guias";var ACTION_SHOW_OUTLINE$7="Exibir Guias";var ACTION_ADJUST_POS_SIZE$8="Ajustar Tamanho";var LABEL_ASSET_CURRENT$9="{assetType} atual";var ACTION_ASSET_CUSTOM_CLEAR$9="Limpar recurso personalizado";var ACTION_ASSET_BROWSE_LOCAL$8="Navegar pelos arquivos locais";var ACTION_ASSET_APPLY_TRANSPARENT$8="Usar recurso invisível";var LABEL_NOTES$9="Notas";var LABEL_ANIMATED$8="Animação";var LABEL_NSFW$9="Conteúdo Adulto";var LABEL_HUMOR$8="Humor";var LABEL_EPILEPSY$8="Epilepsia";var ACTION_OPEN_FILTER$9="Filtrar";var ACTION_OPEN_OFFICIAL_ASSETS$8="{assetType} Oficial";var ACTION_ASSET_APPLY$8="Aplicar {assetType}";var MSG_GAME_SELECTED$8="Selecionou {gameName}";var MSG_ASSETS_FILTERED$8="Algumas artes podem estar ocultas devido aos filtros";var MSG_GAME_SELECTED_AND_ASSETS_FILTERED$8="Selecionou {gameName} com filtros";var MSG_ASSET_APPLY_SUCCESS$8="Imagem aplicada com sucesso!";var MSG_ASSET_APPLY_ERROR$8="Houve um problema ao aplicar este recurso.";var ACTION_OPEN_DETAILS$9="Detalhes";var ptBr = {ASSET_TYPE_CAPSULE:ASSET_TYPE_CAPSULE$9,ASSET_TYPE_WIDECAPSULE:ASSET_TYPE_WIDECAPSULE$9,ASSET_TYPE_HERO:ASSET_TYPE_HERO$9,ASSET_TYPE_LOGO:ASSET_TYPE_LOGO$9,ASSET_TYPE_ICON:ASSET_TYPE_ICON$9,LABEL_TAB_CAPSULE:LABEL_TAB_CAPSULE$9,LABEL_TAB_WIDECAPSULE:LABEL_TAB_WIDECAPSULE$9,LABEL_TAB_HERO:LABEL_TAB_HERO$9,LABEL_TAB_LOGO:LABEL_TAB_LOGO$9,LABEL_TAB_ICON:LABEL_TAB_ICON$9,LABEL_TAB_MANAGE:LABEL_TAB_MANAGE$9,MSG_USAGE_INSTRUCTIONS:MSG_USAGE_INSTRUCTIONS$8,ACTION_CHANGE_ARTWORK:ACTION_CHANGE_ARTWORK$9,ACTION_SHOW_LINK_QR:ACTION_SHOW_LINK_QR$9,MSG_ASSET_TAB_SETTINGS_DESC:MSG_ASSET_TAB_SETTINGS_DESC$7,LABEL_USAGE_TITLE:LABEL_USAGE_TITLE$8,LABEL_SQUARE_CAPSULES:LABEL_SQUARE_CAPSULES$7,LABEL_SQUARE_CAPSULES_DESC:LABEL_SQUARE_CAPSULES_DESC$6,LABEL_CAPSULE_GLOW:LABEL_CAPSULE_GLOW$7,LABEL_CAPSULE_GLOW_DESC:LABEL_CAPSULE_GLOW_DESC$6,LABEL_CAPSULE_GLOW_OFF:LABEL_CAPSULE_GLOW_OFF$7,LABEL_SETTINGS_ASSET_TABS:LABEL_SETTINGS_ASSET_TABS$7,LABEL_TRANSLATION_CREDIT_TITLE:LABEL_TRANSLATION_CREDIT_TITLE$9,LABEL_MORE_SGDB_TITLE:LABEL_MORE_SGDB_TITLE$9,ACTION_SGDB_DISCORD:ACTION_SGDB_DISCORD$9,ACTION_SGDB_GITHUB:ACTION_SGDB_GITHUB$8,ACTION_SGDB_DONATE:ACTION_SGDB_DONATE$9,ACTION_SGDB_TRANSLATE:ACTION_SGDB_TRANSLATE$9,ACTION_SGDB_BOOP:ACTION_SGDB_BOOP$9,LABEL_RESTART_STEAM_TITLE:LABEL_RESTART_STEAM_TITLE$8,ACTION_RESTART_STEAM_LATER:ACTION_RESTART_STEAM_LATER$8,ACTION_RESTART_STEAM_NOW:ACTION_RESTART_STEAM_NOW$8,MSG_RESTART_STEAM_DESC:MSG_RESTART_STEAM_DESC$7,LABEL_GAME_SEARCH_TITLE:LABEL_GAME_SEARCH_TITLE$9,LABEL_FILTER_MODAL_TITLE:LABEL_FILTER_MODAL_TITLE$9,LABEL_FILTER_GAME:LABEL_FILTER_GAME$9,LABEL_FILTER_DIMENSIONS:LABEL_FILTER_DIMENSIONS$9,LABEL_FILTER_STYLES:LABEL_FILTER_STYLES$9,LABEL_FILTER_FILE_TYPES:LABEL_FILTER_FILE_TYPES$9,LABEL_FILTER_ANIMATION_TYPE_TITLE:LABEL_FILTER_ANIMATION_TYPE_TITLE$9,LABEL_FILTER_TYPE_ANIMATED:LABEL_FILTER_TYPE_ANIMATED$8,LABEL_FILTER_TYPE_STATIC:LABEL_FILTER_TYPE_STATIC$8,LABEL_FILTER_TAGS_TITLE:LABEL_FILTER_TAGS_TITLE$9,LABEL_FILTER_TAG_NSFW:LABEL_FILTER_TAG_NSFW$9,MSG_FILTER_TAG_NSFW_ENABLED:MSG_FILTER_TAG_NSFW_ENABLED$8,LABEL_FILTER_TAG_HUMOR:LABEL_FILTER_TAG_HUMOR$8,LABEL_FILTER_TAG_EPILEPSY:LABEL_FILTER_TAG_EPILEPSY$8,LABEL_FILTER_TAG_UNTAGGED:LABEL_FILTER_TAG_UNTAGGED$8,ACTION_FILTER_RESET:ACTION_FILTER_RESET$9,LABEL_BEGGING_MODAL_TITLE:LABEL_BEGGING_MODAL_TITLE$7,LABEL_BEGGING_MODAL_DESC:LABEL_BEGGING_MODAL_DESC$6,ACTION_HIDE_POS_GUIDES:ACTION_HIDE_POS_GUIDES$7,ACTION_SHOW_OUTLINE:ACTION_SHOW_OUTLINE$7,ACTION_ADJUST_POS_SIZE:ACTION_ADJUST_POS_SIZE$8,LABEL_ASSET_CURRENT:LABEL_ASSET_CURRENT$9,ACTION_ASSET_CUSTOM_CLEAR:ACTION_ASSET_CUSTOM_CLEAR$9,ACTION_ASSET_BROWSE_LOCAL:ACTION_ASSET_BROWSE_LOCAL$8,ACTION_ASSET_APPLY_TRANSPARENT:ACTION_ASSET_APPLY_TRANSPARENT$8,LABEL_NOTES:LABEL_NOTES$9,LABEL_ANIMATED:LABEL_ANIMATED$8,LABEL_NSFW:LABEL_NSFW$9,LABEL_HUMOR:LABEL_HUMOR$8,LABEL_EPILEPSY:LABEL_EPILEPSY$8,ACTION_OPEN_FILTER:ACTION_OPEN_FILTER$9,ACTION_OPEN_OFFICIAL_ASSETS:ACTION_OPEN_OFFICIAL_ASSETS$8,ACTION_ASSET_APPLY:ACTION_ASSET_APPLY$8,MSG_GAME_SELECTED:MSG_GAME_SELECTED$8,MSG_ASSETS_FILTERED:MSG_ASSETS_FILTERED$8,MSG_GAME_SELECTED_AND_ASSETS_FILTERED:MSG_GAME_SELECTED_AND_ASSETS_FILTERED$8,MSG_ASSET_APPLY_SUCCESS:MSG_ASSET_APPLY_SUCCESS$8,MSG_ASSET_APPLY_ERROR:MSG_ASSET_APPLY_ERROR$8,ACTION_OPEN_DETAILS:ACTION_OPEN_DETAILS$9};

var ptBr$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    ACTION_ADJUST_POS_SIZE: ACTION_ADJUST_POS_SIZE$8,
    ACTION_ASSET_APPLY: ACTION_ASSET_APPLY$8,
    ACTION_ASSET_APPLY_TRANSPARENT: ACTION_ASSET_APPLY_TRANSPARENT$8,
    ACTION_ASSET_BROWSE_LOCAL: ACTION_ASSET_BROWSE_LOCAL$8,
    ACTION_ASSET_CUSTOM_CLEAR: ACTION_ASSET_CUSTOM_CLEAR$9,
    ACTION_CHANGE_ARTWORK: ACTION_CHANGE_ARTWORK$9,
    ACTION_FILTER_RESET: ACTION_FILTER_RESET$9,
    ACTION_HIDE_POS_GUIDES: ACTION_HIDE_POS_GUIDES$7,
    ACTION_OPEN_DETAILS: ACTION_OPEN_DETAILS$9,
    ACTION_OPEN_FILTER: ACTION_OPEN_FILTER$9,
    ACTION_OPEN_OFFICIAL_ASSETS: ACTION_OPEN_OFFICIAL_ASSETS$8,
    ACTION_RESTART_STEAM_LATER: ACTION_RESTART_STEAM_LATER$8,
    ACTION_RESTART_STEAM_NOW: ACTION_RESTART_STEAM_NOW$8,
    ACTION_SGDB_BOOP: ACTION_SGDB_BOOP$9,
    ACTION_SGDB_DISCORD: ACTION_SGDB_DISCORD$9,
    ACTION_SGDB_DONATE: ACTION_SGDB_DONATE$9,
    ACTION_SGDB_GITHUB: ACTION_SGDB_GITHUB$8,
    ACTION_SGDB_TRANSLATE: ACTION_SGDB_TRANSLATE$9,
    ACTION_SHOW_LINK_QR: ACTION_SHOW_LINK_QR$9,
    ACTION_SHOW_OUTLINE: ACTION_SHOW_OUTLINE$7,
    ASSET_TYPE_CAPSULE: ASSET_TYPE_CAPSULE$9,
    ASSET_TYPE_HERO: ASSET_TYPE_HERO$9,
    ASSET_TYPE_ICON: ASSET_TYPE_ICON$9,
    ASSET_TYPE_LOGO: ASSET_TYPE_LOGO$9,
    ASSET_TYPE_WIDECAPSULE: ASSET_TYPE_WIDECAPSULE$9,
    LABEL_ANIMATED: LABEL_ANIMATED$8,
    LABEL_ASSET_CURRENT: LABEL_ASSET_CURRENT$9,
    LABEL_BEGGING_MODAL_DESC: LABEL_BEGGING_MODAL_DESC$6,
    LABEL_BEGGING_MODAL_TITLE: LABEL_BEGGING_MODAL_TITLE$7,
    LABEL_CAPSULE_GLOW: LABEL_CAPSULE_GLOW$7,
    LABEL_CAPSULE_GLOW_DESC: LABEL_CAPSULE_GLOW_DESC$6,
    LABEL_CAPSULE_GLOW_OFF: LABEL_CAPSULE_GLOW_OFF$7,
    LABEL_EPILEPSY: LABEL_EPILEPSY$8,
    LABEL_FILTER_ANIMATION_TYPE_TITLE: LABEL_FILTER_ANIMATION_TYPE_TITLE$9,
    LABEL_FILTER_DIMENSIONS: LABEL_FILTER_DIMENSIONS$9,
    LABEL_FILTER_FILE_TYPES: LABEL_FILTER_FILE_TYPES$9,
    LABEL_FILTER_GAME: LABEL_FILTER_GAME$9,
    LABEL_FILTER_MODAL_TITLE: LABEL_FILTER_MODAL_TITLE$9,
    LABEL_FILTER_STYLES: LABEL_FILTER_STYLES$9,
    LABEL_FILTER_TAGS_TITLE: LABEL_FILTER_TAGS_TITLE$9,
    LABEL_FILTER_TAG_EPILEPSY: LABEL_FILTER_TAG_EPILEPSY$8,
    LABEL_FILTER_TAG_HUMOR: LABEL_FILTER_TAG_HUMOR$8,
    LABEL_FILTER_TAG_NSFW: LABEL_FILTER_TAG_NSFW$9,
    LABEL_FILTER_TAG_UNTAGGED: LABEL_FILTER_TAG_UNTAGGED$8,
    LABEL_FILTER_TYPE_ANIMATED: LABEL_FILTER_TYPE_ANIMATED$8,
    LABEL_FILTER_TYPE_STATIC: LABEL_FILTER_TYPE_STATIC$8,
    LABEL_GAME_SEARCH_TITLE: LABEL_GAME_SEARCH_TITLE$9,
    LABEL_HUMOR: LABEL_HUMOR$8,
    LABEL_MORE_SGDB_TITLE: LABEL_MORE_SGDB_TITLE$9,
    LABEL_NOTES: LABEL_NOTES$9,
    LABEL_NSFW: LABEL_NSFW$9,
    LABEL_RESTART_STEAM_TITLE: LABEL_RESTART_STEAM_TITLE$8,
    LABEL_SETTINGS_ASSET_TABS: LABEL_SETTINGS_ASSET_TABS$7,
    LABEL_SQUARE_CAPSULES: LABEL_SQUARE_CAPSULES$7,
    LABEL_SQUARE_CAPSULES_DESC: LABEL_SQUARE_CAPSULES_DESC$6,
    LABEL_TAB_CAPSULE: LABEL_TAB_CAPSULE$9,
    LABEL_TAB_HERO: LABEL_TAB_HERO$9,
    LABEL_TAB_ICON: LABEL_TAB_ICON$9,
    LABEL_TAB_LOGO: LABEL_TAB_LOGO$9,
    LABEL_TAB_MANAGE: LABEL_TAB_MANAGE$9,
    LABEL_TAB_WIDECAPSULE: LABEL_TAB_WIDECAPSULE$9,
    LABEL_TRANSLATION_CREDIT_TITLE: LABEL_TRANSLATION_CREDIT_TITLE$9,
    LABEL_USAGE_TITLE: LABEL_USAGE_TITLE$8,
    MSG_ASSETS_FILTERED: MSG_ASSETS_FILTERED$8,
    MSG_ASSET_APPLY_ERROR: MSG_ASSET_APPLY_ERROR$8,
    MSG_ASSET_APPLY_SUCCESS: MSG_ASSET_APPLY_SUCCESS$8,
    MSG_ASSET_TAB_SETTINGS_DESC: MSG_ASSET_TAB_SETTINGS_DESC$7,
    MSG_FILTER_TAG_NSFW_ENABLED: MSG_FILTER_TAG_NSFW_ENABLED$8,
    MSG_GAME_SELECTED: MSG_GAME_SELECTED$8,
    MSG_GAME_SELECTED_AND_ASSETS_FILTERED: MSG_GAME_SELECTED_AND_ASSETS_FILTERED$8,
    MSG_RESTART_STEAM_DESC: MSG_RESTART_STEAM_DESC$7,
    MSG_USAGE_INSTRUCTIONS: MSG_USAGE_INSTRUCTIONS$8,
    default: ptBr
});

var ASSET_TYPE_CAPSULE$8="Capsulă";var ASSET_TYPE_WIDECAPSULE$8="Capsulă lată";var ASSET_TYPE_HERO$8="Erou";var ASSET_TYPE_LOGO$8="Logo";var ASSET_TYPE_ICON$8="Pictogramă";var LABEL_TAB_CAPSULE$8="Capsulă";var LABEL_TAB_WIDECAPSULE$8="Capsulă lată";var LABEL_TAB_HERO$8="Erou";var LABEL_TAB_LOGO$8="Logo";var LABEL_TAB_ICON$8="Pictogramă";var LABEL_TAB_MANAGE$8="Administrează";var ACTION_CHANGE_ARTWORK$8="Schimbă imagine...";var ACTION_SHOW_LINK_QR$8="Arată link QR";var LABEL_TRANSLATION_CREDIT_TITLE$8="Traducere Română";var LABEL_MORE_SGDB_TITLE$8="Alte legături SteamGridDB";var ACTION_SGDB_DISCORD$8="Alătură-te serverului de Discord";var ACTION_SGDB_GITHUB$7="Proiecte Open-source";var ACTION_SGDB_DONATE$8="Sprijină-ne pe Patreon";var ACTION_SGDB_TRANSLATE$8="Ajută cu traducerile";var ACTION_SGDB_BOOP$8="Încearcă SGDBoop";var LABEL_GAME_SEARCH_TITLE$8="Caută joc";var LABEL_FILTER_MODAL_TITLE$8="Filtre selecție {assetType}";var LABEL_FILTER_GAME$8="Joc";var LABEL_FILTER_DIMENSIONS$8="Dimensiuni";var LABEL_FILTER_STYLES$8="Stiluri";var LABEL_FILTER_FILE_TYPES$8="Tipuri de fișier";var LABEL_FILTER_ANIMATION_TYPE_TITLE$8="Tipuri";var LABEL_FILTER_TYPE_ANIMATED$7="Animație";var LABEL_FILTER_TYPE_STATIC$7="Static";var LABEL_FILTER_TAGS_TITLE$8="Etichete";var LABEL_FILTER_TAG_NSFW$8="Conținut pentru adulți";var MSG_FILTER_TAG_NSFW_ENABLED$7="Vezi sa nu fie cineva în spatele tău.";var LABEL_FILTER_TAG_HUMOR$7="Umor";var LABEL_FILTER_TAG_EPILEPSY$7="Epilepsie";var LABEL_FILTER_TAG_UNTAGGED$7="Fară etichetă";var ACTION_FILTER_RESET$8="Resetează filtre";var LABEL_ASSET_CURRENT$8="{assetType} activă";var ACTION_ASSET_CUSTOM_CLEAR$8="Șterge selecție personalizată";var ACTION_ASSET_BROWSE_LOCAL$7="Răsfoiește fișiere locale";var ACTION_ASSET_APPLY_TRANSPARENT$7="Folosește selecție invizibilă";var LABEL_NOTES$8="Notițe";var LABEL_ANIMATED$7="Animație";var LABEL_NSFW$8="Conținut pentru adulți";var LABEL_HUMOR$7="Umor";var LABEL_EPILEPSY$7="Epilepsie";var ACTION_OPEN_FILTER$8="Filtrează";var ACTION_ASSET_APPLY$7="Aplică {assetType}";var MSG_GAME_SELECTED$7="{gameName} selectat";var MSG_ASSETS_FILTERED$7="Unele rezultate pot fi ascunse datorită filtrelor";var MSG_GAME_SELECTED_AND_ASSETS_FILTERED$7="{gameName} selectat cu filtre";var MSG_ASSET_APPLY_SUCCESS$7="{assetType} a fost aplicat cu succes!";var MSG_ASSET_APPLY_ERROR$7="A apărut o problemă în aplicarea seleției.";var ACTION_OPEN_DETAILS$8="Detalii";var ro = {ASSET_TYPE_CAPSULE:ASSET_TYPE_CAPSULE$8,ASSET_TYPE_WIDECAPSULE:ASSET_TYPE_WIDECAPSULE$8,ASSET_TYPE_HERO:ASSET_TYPE_HERO$8,ASSET_TYPE_LOGO:ASSET_TYPE_LOGO$8,ASSET_TYPE_ICON:ASSET_TYPE_ICON$8,LABEL_TAB_CAPSULE:LABEL_TAB_CAPSULE$8,LABEL_TAB_WIDECAPSULE:LABEL_TAB_WIDECAPSULE$8,LABEL_TAB_HERO:LABEL_TAB_HERO$8,LABEL_TAB_LOGO:LABEL_TAB_LOGO$8,LABEL_TAB_ICON:LABEL_TAB_ICON$8,LABEL_TAB_MANAGE:LABEL_TAB_MANAGE$8,ACTION_CHANGE_ARTWORK:ACTION_CHANGE_ARTWORK$8,ACTION_SHOW_LINK_QR:ACTION_SHOW_LINK_QR$8,LABEL_TRANSLATION_CREDIT_TITLE:LABEL_TRANSLATION_CREDIT_TITLE$8,LABEL_MORE_SGDB_TITLE:LABEL_MORE_SGDB_TITLE$8,ACTION_SGDB_DISCORD:ACTION_SGDB_DISCORD$8,ACTION_SGDB_GITHUB:ACTION_SGDB_GITHUB$7,ACTION_SGDB_DONATE:ACTION_SGDB_DONATE$8,ACTION_SGDB_TRANSLATE:ACTION_SGDB_TRANSLATE$8,ACTION_SGDB_BOOP:ACTION_SGDB_BOOP$8,LABEL_GAME_SEARCH_TITLE:LABEL_GAME_SEARCH_TITLE$8,LABEL_FILTER_MODAL_TITLE:LABEL_FILTER_MODAL_TITLE$8,LABEL_FILTER_GAME:LABEL_FILTER_GAME$8,LABEL_FILTER_DIMENSIONS:LABEL_FILTER_DIMENSIONS$8,LABEL_FILTER_STYLES:LABEL_FILTER_STYLES$8,LABEL_FILTER_FILE_TYPES:LABEL_FILTER_FILE_TYPES$8,LABEL_FILTER_ANIMATION_TYPE_TITLE:LABEL_FILTER_ANIMATION_TYPE_TITLE$8,LABEL_FILTER_TYPE_ANIMATED:LABEL_FILTER_TYPE_ANIMATED$7,LABEL_FILTER_TYPE_STATIC:LABEL_FILTER_TYPE_STATIC$7,LABEL_FILTER_TAGS_TITLE:LABEL_FILTER_TAGS_TITLE$8,LABEL_FILTER_TAG_NSFW:LABEL_FILTER_TAG_NSFW$8,MSG_FILTER_TAG_NSFW_ENABLED:MSG_FILTER_TAG_NSFW_ENABLED$7,LABEL_FILTER_TAG_HUMOR:LABEL_FILTER_TAG_HUMOR$7,LABEL_FILTER_TAG_EPILEPSY:LABEL_FILTER_TAG_EPILEPSY$7,LABEL_FILTER_TAG_UNTAGGED:LABEL_FILTER_TAG_UNTAGGED$7,ACTION_FILTER_RESET:ACTION_FILTER_RESET$8,LABEL_ASSET_CURRENT:LABEL_ASSET_CURRENT$8,ACTION_ASSET_CUSTOM_CLEAR:ACTION_ASSET_CUSTOM_CLEAR$8,ACTION_ASSET_BROWSE_LOCAL:ACTION_ASSET_BROWSE_LOCAL$7,ACTION_ASSET_APPLY_TRANSPARENT:ACTION_ASSET_APPLY_TRANSPARENT$7,LABEL_NOTES:LABEL_NOTES$8,LABEL_ANIMATED:LABEL_ANIMATED$7,LABEL_NSFW:LABEL_NSFW$8,LABEL_HUMOR:LABEL_HUMOR$7,LABEL_EPILEPSY:LABEL_EPILEPSY$7,ACTION_OPEN_FILTER:ACTION_OPEN_FILTER$8,ACTION_ASSET_APPLY:ACTION_ASSET_APPLY$7,MSG_GAME_SELECTED:MSG_GAME_SELECTED$7,MSG_ASSETS_FILTERED:MSG_ASSETS_FILTERED$7,MSG_GAME_SELECTED_AND_ASSETS_FILTERED:MSG_GAME_SELECTED_AND_ASSETS_FILTERED$7,MSG_ASSET_APPLY_SUCCESS:MSG_ASSET_APPLY_SUCCESS$7,MSG_ASSET_APPLY_ERROR:MSG_ASSET_APPLY_ERROR$7,ACTION_OPEN_DETAILS:ACTION_OPEN_DETAILS$8};

var ro$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    ACTION_ASSET_APPLY: ACTION_ASSET_APPLY$7,
    ACTION_ASSET_APPLY_TRANSPARENT: ACTION_ASSET_APPLY_TRANSPARENT$7,
    ACTION_ASSET_BROWSE_LOCAL: ACTION_ASSET_BROWSE_LOCAL$7,
    ACTION_ASSET_CUSTOM_CLEAR: ACTION_ASSET_CUSTOM_CLEAR$8,
    ACTION_CHANGE_ARTWORK: ACTION_CHANGE_ARTWORK$8,
    ACTION_FILTER_RESET: ACTION_FILTER_RESET$8,
    ACTION_OPEN_DETAILS: ACTION_OPEN_DETAILS$8,
    ACTION_OPEN_FILTER: ACTION_OPEN_FILTER$8,
    ACTION_SGDB_BOOP: ACTION_SGDB_BOOP$8,
    ACTION_SGDB_DISCORD: ACTION_SGDB_DISCORD$8,
    ACTION_SGDB_DONATE: ACTION_SGDB_DONATE$8,
    ACTION_SGDB_GITHUB: ACTION_SGDB_GITHUB$7,
    ACTION_SGDB_TRANSLATE: ACTION_SGDB_TRANSLATE$8,
    ACTION_SHOW_LINK_QR: ACTION_SHOW_LINK_QR$8,
    ASSET_TYPE_CAPSULE: ASSET_TYPE_CAPSULE$8,
    ASSET_TYPE_HERO: ASSET_TYPE_HERO$8,
    ASSET_TYPE_ICON: ASSET_TYPE_ICON$8,
    ASSET_TYPE_LOGO: ASSET_TYPE_LOGO$8,
    ASSET_TYPE_WIDECAPSULE: ASSET_TYPE_WIDECAPSULE$8,
    LABEL_ANIMATED: LABEL_ANIMATED$7,
    LABEL_ASSET_CURRENT: LABEL_ASSET_CURRENT$8,
    LABEL_EPILEPSY: LABEL_EPILEPSY$7,
    LABEL_FILTER_ANIMATION_TYPE_TITLE: LABEL_FILTER_ANIMATION_TYPE_TITLE$8,
    LABEL_FILTER_DIMENSIONS: LABEL_FILTER_DIMENSIONS$8,
    LABEL_FILTER_FILE_TYPES: LABEL_FILTER_FILE_TYPES$8,
    LABEL_FILTER_GAME: LABEL_FILTER_GAME$8,
    LABEL_FILTER_MODAL_TITLE: LABEL_FILTER_MODAL_TITLE$8,
    LABEL_FILTER_STYLES: LABEL_FILTER_STYLES$8,
    LABEL_FILTER_TAGS_TITLE: LABEL_FILTER_TAGS_TITLE$8,
    LABEL_FILTER_TAG_EPILEPSY: LABEL_FILTER_TAG_EPILEPSY$7,
    LABEL_FILTER_TAG_HUMOR: LABEL_FILTER_TAG_HUMOR$7,
    LABEL_FILTER_TAG_NSFW: LABEL_FILTER_TAG_NSFW$8,
    LABEL_FILTER_TAG_UNTAGGED: LABEL_FILTER_TAG_UNTAGGED$7,
    LABEL_FILTER_TYPE_ANIMATED: LABEL_FILTER_TYPE_ANIMATED$7,
    LABEL_FILTER_TYPE_STATIC: LABEL_FILTER_TYPE_STATIC$7,
    LABEL_GAME_SEARCH_TITLE: LABEL_GAME_SEARCH_TITLE$8,
    LABEL_HUMOR: LABEL_HUMOR$7,
    LABEL_MORE_SGDB_TITLE: LABEL_MORE_SGDB_TITLE$8,
    LABEL_NOTES: LABEL_NOTES$8,
    LABEL_NSFW: LABEL_NSFW$8,
    LABEL_TAB_CAPSULE: LABEL_TAB_CAPSULE$8,
    LABEL_TAB_HERO: LABEL_TAB_HERO$8,
    LABEL_TAB_ICON: LABEL_TAB_ICON$8,
    LABEL_TAB_LOGO: LABEL_TAB_LOGO$8,
    LABEL_TAB_MANAGE: LABEL_TAB_MANAGE$8,
    LABEL_TAB_WIDECAPSULE: LABEL_TAB_WIDECAPSULE$8,
    LABEL_TRANSLATION_CREDIT_TITLE: LABEL_TRANSLATION_CREDIT_TITLE$8,
    MSG_ASSETS_FILTERED: MSG_ASSETS_FILTERED$7,
    MSG_ASSET_APPLY_ERROR: MSG_ASSET_APPLY_ERROR$7,
    MSG_ASSET_APPLY_SUCCESS: MSG_ASSET_APPLY_SUCCESS$7,
    MSG_FILTER_TAG_NSFW_ENABLED: MSG_FILTER_TAG_NSFW_ENABLED$7,
    MSG_GAME_SELECTED: MSG_GAME_SELECTED$7,
    MSG_GAME_SELECTED_AND_ASSETS_FILTERED: MSG_GAME_SELECTED_AND_ASSETS_FILTERED$7,
    default: ro
});

var ASSET_TYPE_CAPSULE$7="Обложка";var ASSET_TYPE_WIDECAPSULE$7="Широкая обложка";var ASSET_TYPE_HERO$7="Баннер";var ASSET_TYPE_LOGO$7="Логотип";var ASSET_TYPE_ICON$7="Иконка";var LABEL_TAB_CAPSULE$7="Обложка";var LABEL_TAB_WIDECAPSULE$7="Широкая обложка";var LABEL_TAB_HERO$7="Баннер";var LABEL_TAB_LOGO$7="Лого";var LABEL_TAB_ICON$7="Иконка";var LABEL_TAB_MANAGE$7="Управлять";var MSG_USAGE_INSTRUCTIONS$7="Выберите игру {arrow} {optionsButton} {arrow} \"{ACTION_CHANGE_ARTWORK}\"";var ACTION_CHANGE_ARTWORK$7="Сменить картинку...";var ACTION_SHOW_LINK_QR$7="Показать QR ссылку";var MSG_ASSET_TAB_SETTINGS_DESC$6="Сортировать или скрыть неиспользуемые вкладки, также установить вкладку по умолчанию, которая открывается при использовании \"{ACTION_CHANGE_ARTWORK}\"";var LABEL_USAGE_TITLE$7="Потерялись? Вот краткое руководство";var LABEL_SQUARE_CAPSULES$6="Квадратные обложки";var LABEL_SQUARE_CAPSULES_DESC$5="Использовать квадратные обложки вместо портретных. Фильтр по умолчанию изменится на квадратные.";var LABEL_UNIFORM_RECENT$4="Однообразие размеров обложек";var LABEL_UNIFORM_RECENT_DESC$4="Сделать обложку последней сыгранной игры на главном экране соответствующей остальным обложкам.";var LABEL_CAPSULE_GLOW$6="Свечение обложки";var LABEL_CAPSULE_GLOW_DESC$5="Настройка интенсивности свечения обложки в библиотеке.";var LABEL_CAPSULE_GLOW_OFF$6="Ничего";var LABEL_SETTINGS_ASSET_TABS$6="Настройка вкладок";var LABEL_SETTINGS_DISABLE_MOTD$5="Отключить оповещения";var LABEL_SETTINGS_DISABLE_MOTD_DESC$4="Оповещения используются избирательно для отображения важной информации или событий сообщества.";var LABEL_TRANSLATION_CREDIT_TITLE$7="Русский перевод";var LABEL_MORE_SGDB_TITLE$7="Больше на SteamGridDB";var ACTION_SGDB_DISCORD$7="Вступить в Discord";var ACTION_SGDB_GITHUB$6="Проекты с исходным кодом";var ACTION_SGDB_DONATE$7="Поддержать на Patreon";var ACTION_SGDB_TRANSLATE$7="Помочь в переводе";var ACTION_SGDB_BOOP$7="Попробовать SGDBoop";var LABEL_RESTART_STEAM_TITLE$7="Перезапустить Steam?";var ACTION_RESTART_STEAM_LATER$7="Позже";var ACTION_RESTART_STEAM_NOW$7="Перезапустить сейчас";var MSG_RESTART_STEAM_DESC$6="Steam должен быть перезапущен, чтобы изменения вступили в силу.";var LABEL_GAME_SEARCH_TITLE$7="Поиск игры...";var LABEL_FILTER_MODAL_TITLE$7="Фильтр {assetType}";var LABEL_FILTER_GAME$7="Игра";var LABEL_FILTER_DIMENSIONS$7="Размеры";var LABEL_FILTER_STYLES$7="Стили";var LABEL_FILTER_FILE_TYPES$7="Типы файлов";var LABEL_FILTER_ANIMATION_TYPE_TITLE$7="Вид";var LABEL_FILTER_TYPE_ANIMATED$6="Анимированные";var LABEL_FILTER_TYPE_STATIC$6="Статичные";var LABEL_FILTER_TAGS_TITLE$7="Метки";var LABEL_FILTER_TAG_NSFW$7="Взрослый контент";var MSG_FILTER_TAG_NSFW_ENABLED$6="Стоит занавесить шторы.";var LABEL_FILTER_TAG_HUMOR$6="Юмор";var LABEL_FILTER_TAG_EPILEPSY$6="Эпилепсия";var LABEL_FILTER_TAG_UNTAGGED$6="Без метки";var ACTION_FILTER_RESET$7="Сбросить фильтры";var LABEL_BEGGING_MODAL_TITLE$6="Спасибо за использование SteamGridDB!";var LABEL_BEGGING_MODAL_DESC$5="Пожалуйста, подумайте о пожертвовании, чтобы помочь с обслуживанием и расходами на сервер!";var ACTION_HIDE_POS_GUIDES$6="Скрыть подсказки";var ACTION_SHOW_OUTLINE$6="Показать подсказки";var ACTION_ADJUST_POS_SIZE$7="Изменить размер";var ACTION_CHANGE_POS_LOGO_ANCHOR_POINT$4="Изменить точку привязки";var LABEL_ASSET_CURRENT$7="Текущий {assetType}";var ACTION_ASSET_CUSTOM_CLEAR$7="Убрать кастомный файл";var ACTION_ASSET_BROWSE_LOCAL$6="Просмотр локальных файлов";var ACTION_ASSET_APPLY_TRANSPARENT$6="Использовать невидимый файл";var LABEL_NOTES$7="Примечание";var LABEL_ANIMATED$6="Анимация";var LABEL_NSFW$7="Взрослый контент";var LABEL_HUMOR$6="Юмор";var LABEL_EPILEPSY$6="Эпилепсия";var ACTION_OPEN_FILTER$7="Фильтр";var ACTION_OPEN_OFFICIAL_ASSETS$7="Офиц. {assetType}";var ACTION_ASSET_APPLY$6="Применить {assetType}";var MSG_GAME_SELECTED$6="Выбрана {gameName}";var MSG_ASSETS_FILTERED$6="Некоторые файлы могут быть скрыты из-за фильтра";var MSG_GAME_SELECTED_AND_ASSETS_FILTERED$6="Выбрана {gameName} с фильтром";var TITLE_MOTD_HIDE$5="Скрыть оповещение?";var LABEL_MOTD_THIS$5="Это оповещение";var LABEL_MOTD_ALL$5="Все оповещения";var MSG_ASSET_APPLY_SUCCESS$6="{assetType} успешно применен!";var MSG_ASSET_APPLY_ERROR$6="Возникла проблема с добавлением этого файла.";var ACTION_OPEN_DETAILS$7="Детали";var ru = {ASSET_TYPE_CAPSULE:ASSET_TYPE_CAPSULE$7,ASSET_TYPE_WIDECAPSULE:ASSET_TYPE_WIDECAPSULE$7,ASSET_TYPE_HERO:ASSET_TYPE_HERO$7,ASSET_TYPE_LOGO:ASSET_TYPE_LOGO$7,ASSET_TYPE_ICON:ASSET_TYPE_ICON$7,LABEL_TAB_CAPSULE:LABEL_TAB_CAPSULE$7,LABEL_TAB_WIDECAPSULE:LABEL_TAB_WIDECAPSULE$7,LABEL_TAB_HERO:LABEL_TAB_HERO$7,LABEL_TAB_LOGO:LABEL_TAB_LOGO$7,LABEL_TAB_ICON:LABEL_TAB_ICON$7,LABEL_TAB_MANAGE:LABEL_TAB_MANAGE$7,MSG_USAGE_INSTRUCTIONS:MSG_USAGE_INSTRUCTIONS$7,ACTION_CHANGE_ARTWORK:ACTION_CHANGE_ARTWORK$7,ACTION_SHOW_LINK_QR:ACTION_SHOW_LINK_QR$7,MSG_ASSET_TAB_SETTINGS_DESC:MSG_ASSET_TAB_SETTINGS_DESC$6,LABEL_USAGE_TITLE:LABEL_USAGE_TITLE$7,LABEL_SQUARE_CAPSULES:LABEL_SQUARE_CAPSULES$6,LABEL_SQUARE_CAPSULES_DESC:LABEL_SQUARE_CAPSULES_DESC$5,LABEL_UNIFORM_RECENT:LABEL_UNIFORM_RECENT$4,LABEL_UNIFORM_RECENT_DESC:LABEL_UNIFORM_RECENT_DESC$4,LABEL_CAPSULE_GLOW:LABEL_CAPSULE_GLOW$6,LABEL_CAPSULE_GLOW_DESC:LABEL_CAPSULE_GLOW_DESC$5,LABEL_CAPSULE_GLOW_OFF:LABEL_CAPSULE_GLOW_OFF$6,LABEL_SETTINGS_ASSET_TABS:LABEL_SETTINGS_ASSET_TABS$6,LABEL_SETTINGS_DISABLE_MOTD:LABEL_SETTINGS_DISABLE_MOTD$5,LABEL_SETTINGS_DISABLE_MOTD_DESC:LABEL_SETTINGS_DISABLE_MOTD_DESC$4,LABEL_TRANSLATION_CREDIT_TITLE:LABEL_TRANSLATION_CREDIT_TITLE$7,LABEL_MORE_SGDB_TITLE:LABEL_MORE_SGDB_TITLE$7,ACTION_SGDB_DISCORD:ACTION_SGDB_DISCORD$7,ACTION_SGDB_GITHUB:ACTION_SGDB_GITHUB$6,ACTION_SGDB_DONATE:ACTION_SGDB_DONATE$7,ACTION_SGDB_TRANSLATE:ACTION_SGDB_TRANSLATE$7,ACTION_SGDB_BOOP:ACTION_SGDB_BOOP$7,LABEL_RESTART_STEAM_TITLE:LABEL_RESTART_STEAM_TITLE$7,ACTION_RESTART_STEAM_LATER:ACTION_RESTART_STEAM_LATER$7,ACTION_RESTART_STEAM_NOW:ACTION_RESTART_STEAM_NOW$7,MSG_RESTART_STEAM_DESC:MSG_RESTART_STEAM_DESC$6,LABEL_GAME_SEARCH_TITLE:LABEL_GAME_SEARCH_TITLE$7,LABEL_FILTER_MODAL_TITLE:LABEL_FILTER_MODAL_TITLE$7,LABEL_FILTER_GAME:LABEL_FILTER_GAME$7,LABEL_FILTER_DIMENSIONS:LABEL_FILTER_DIMENSIONS$7,LABEL_FILTER_STYLES:LABEL_FILTER_STYLES$7,LABEL_FILTER_FILE_TYPES:LABEL_FILTER_FILE_TYPES$7,LABEL_FILTER_ANIMATION_TYPE_TITLE:LABEL_FILTER_ANIMATION_TYPE_TITLE$7,LABEL_FILTER_TYPE_ANIMATED:LABEL_FILTER_TYPE_ANIMATED$6,LABEL_FILTER_TYPE_STATIC:LABEL_FILTER_TYPE_STATIC$6,LABEL_FILTER_TAGS_TITLE:LABEL_FILTER_TAGS_TITLE$7,LABEL_FILTER_TAG_NSFW:LABEL_FILTER_TAG_NSFW$7,MSG_FILTER_TAG_NSFW_ENABLED:MSG_FILTER_TAG_NSFW_ENABLED$6,LABEL_FILTER_TAG_HUMOR:LABEL_FILTER_TAG_HUMOR$6,LABEL_FILTER_TAG_EPILEPSY:LABEL_FILTER_TAG_EPILEPSY$6,LABEL_FILTER_TAG_UNTAGGED:LABEL_FILTER_TAG_UNTAGGED$6,ACTION_FILTER_RESET:ACTION_FILTER_RESET$7,LABEL_BEGGING_MODAL_TITLE:LABEL_BEGGING_MODAL_TITLE$6,LABEL_BEGGING_MODAL_DESC:LABEL_BEGGING_MODAL_DESC$5,ACTION_HIDE_POS_GUIDES:ACTION_HIDE_POS_GUIDES$6,ACTION_SHOW_OUTLINE:ACTION_SHOW_OUTLINE$6,ACTION_ADJUST_POS_SIZE:ACTION_ADJUST_POS_SIZE$7,ACTION_CHANGE_POS_LOGO_ANCHOR_POINT:ACTION_CHANGE_POS_LOGO_ANCHOR_POINT$4,LABEL_ASSET_CURRENT:LABEL_ASSET_CURRENT$7,ACTION_ASSET_CUSTOM_CLEAR:ACTION_ASSET_CUSTOM_CLEAR$7,ACTION_ASSET_BROWSE_LOCAL:ACTION_ASSET_BROWSE_LOCAL$6,ACTION_ASSET_APPLY_TRANSPARENT:ACTION_ASSET_APPLY_TRANSPARENT$6,LABEL_NOTES:LABEL_NOTES$7,LABEL_ANIMATED:LABEL_ANIMATED$6,LABEL_NSFW:LABEL_NSFW$7,LABEL_HUMOR:LABEL_HUMOR$6,LABEL_EPILEPSY:LABEL_EPILEPSY$6,ACTION_OPEN_FILTER:ACTION_OPEN_FILTER$7,ACTION_OPEN_OFFICIAL_ASSETS:ACTION_OPEN_OFFICIAL_ASSETS$7,ACTION_ASSET_APPLY:ACTION_ASSET_APPLY$6,MSG_GAME_SELECTED:MSG_GAME_SELECTED$6,MSG_ASSETS_FILTERED:MSG_ASSETS_FILTERED$6,MSG_GAME_SELECTED_AND_ASSETS_FILTERED:MSG_GAME_SELECTED_AND_ASSETS_FILTERED$6,TITLE_MOTD_HIDE:TITLE_MOTD_HIDE$5,LABEL_MOTD_THIS:LABEL_MOTD_THIS$5,LABEL_MOTD_ALL:LABEL_MOTD_ALL$5,MSG_ASSET_APPLY_SUCCESS:MSG_ASSET_APPLY_SUCCESS$6,MSG_ASSET_APPLY_ERROR:MSG_ASSET_APPLY_ERROR$6,ACTION_OPEN_DETAILS:ACTION_OPEN_DETAILS$7};

var ru$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    ACTION_ADJUST_POS_SIZE: ACTION_ADJUST_POS_SIZE$7,
    ACTION_ASSET_APPLY: ACTION_ASSET_APPLY$6,
    ACTION_ASSET_APPLY_TRANSPARENT: ACTION_ASSET_APPLY_TRANSPARENT$6,
    ACTION_ASSET_BROWSE_LOCAL: ACTION_ASSET_BROWSE_LOCAL$6,
    ACTION_ASSET_CUSTOM_CLEAR: ACTION_ASSET_CUSTOM_CLEAR$7,
    ACTION_CHANGE_ARTWORK: ACTION_CHANGE_ARTWORK$7,
    ACTION_CHANGE_POS_LOGO_ANCHOR_POINT: ACTION_CHANGE_POS_LOGO_ANCHOR_POINT$4,
    ACTION_FILTER_RESET: ACTION_FILTER_RESET$7,
    ACTION_HIDE_POS_GUIDES: ACTION_HIDE_POS_GUIDES$6,
    ACTION_OPEN_DETAILS: ACTION_OPEN_DETAILS$7,
    ACTION_OPEN_FILTER: ACTION_OPEN_FILTER$7,
    ACTION_OPEN_OFFICIAL_ASSETS: ACTION_OPEN_OFFICIAL_ASSETS$7,
    ACTION_RESTART_STEAM_LATER: ACTION_RESTART_STEAM_LATER$7,
    ACTION_RESTART_STEAM_NOW: ACTION_RESTART_STEAM_NOW$7,
    ACTION_SGDB_BOOP: ACTION_SGDB_BOOP$7,
    ACTION_SGDB_DISCORD: ACTION_SGDB_DISCORD$7,
    ACTION_SGDB_DONATE: ACTION_SGDB_DONATE$7,
    ACTION_SGDB_GITHUB: ACTION_SGDB_GITHUB$6,
    ACTION_SGDB_TRANSLATE: ACTION_SGDB_TRANSLATE$7,
    ACTION_SHOW_LINK_QR: ACTION_SHOW_LINK_QR$7,
    ACTION_SHOW_OUTLINE: ACTION_SHOW_OUTLINE$6,
    ASSET_TYPE_CAPSULE: ASSET_TYPE_CAPSULE$7,
    ASSET_TYPE_HERO: ASSET_TYPE_HERO$7,
    ASSET_TYPE_ICON: ASSET_TYPE_ICON$7,
    ASSET_TYPE_LOGO: ASSET_TYPE_LOGO$7,
    ASSET_TYPE_WIDECAPSULE: ASSET_TYPE_WIDECAPSULE$7,
    LABEL_ANIMATED: LABEL_ANIMATED$6,
    LABEL_ASSET_CURRENT: LABEL_ASSET_CURRENT$7,
    LABEL_BEGGING_MODAL_DESC: LABEL_BEGGING_MODAL_DESC$5,
    LABEL_BEGGING_MODAL_TITLE: LABEL_BEGGING_MODAL_TITLE$6,
    LABEL_CAPSULE_GLOW: LABEL_CAPSULE_GLOW$6,
    LABEL_CAPSULE_GLOW_DESC: LABEL_CAPSULE_GLOW_DESC$5,
    LABEL_CAPSULE_GLOW_OFF: LABEL_CAPSULE_GLOW_OFF$6,
    LABEL_EPILEPSY: LABEL_EPILEPSY$6,
    LABEL_FILTER_ANIMATION_TYPE_TITLE: LABEL_FILTER_ANIMATION_TYPE_TITLE$7,
    LABEL_FILTER_DIMENSIONS: LABEL_FILTER_DIMENSIONS$7,
    LABEL_FILTER_FILE_TYPES: LABEL_FILTER_FILE_TYPES$7,
    LABEL_FILTER_GAME: LABEL_FILTER_GAME$7,
    LABEL_FILTER_MODAL_TITLE: LABEL_FILTER_MODAL_TITLE$7,
    LABEL_FILTER_STYLES: LABEL_FILTER_STYLES$7,
    LABEL_FILTER_TAGS_TITLE: LABEL_FILTER_TAGS_TITLE$7,
    LABEL_FILTER_TAG_EPILEPSY: LABEL_FILTER_TAG_EPILEPSY$6,
    LABEL_FILTER_TAG_HUMOR: LABEL_FILTER_TAG_HUMOR$6,
    LABEL_FILTER_TAG_NSFW: LABEL_FILTER_TAG_NSFW$7,
    LABEL_FILTER_TAG_UNTAGGED: LABEL_FILTER_TAG_UNTAGGED$6,
    LABEL_FILTER_TYPE_ANIMATED: LABEL_FILTER_TYPE_ANIMATED$6,
    LABEL_FILTER_TYPE_STATIC: LABEL_FILTER_TYPE_STATIC$6,
    LABEL_GAME_SEARCH_TITLE: LABEL_GAME_SEARCH_TITLE$7,
    LABEL_HUMOR: LABEL_HUMOR$6,
    LABEL_MORE_SGDB_TITLE: LABEL_MORE_SGDB_TITLE$7,
    LABEL_MOTD_ALL: LABEL_MOTD_ALL$5,
    LABEL_MOTD_THIS: LABEL_MOTD_THIS$5,
    LABEL_NOTES: LABEL_NOTES$7,
    LABEL_NSFW: LABEL_NSFW$7,
    LABEL_RESTART_STEAM_TITLE: LABEL_RESTART_STEAM_TITLE$7,
    LABEL_SETTINGS_ASSET_TABS: LABEL_SETTINGS_ASSET_TABS$6,
    LABEL_SETTINGS_DISABLE_MOTD: LABEL_SETTINGS_DISABLE_MOTD$5,
    LABEL_SETTINGS_DISABLE_MOTD_DESC: LABEL_SETTINGS_DISABLE_MOTD_DESC$4,
    LABEL_SQUARE_CAPSULES: LABEL_SQUARE_CAPSULES$6,
    LABEL_SQUARE_CAPSULES_DESC: LABEL_SQUARE_CAPSULES_DESC$5,
    LABEL_TAB_CAPSULE: LABEL_TAB_CAPSULE$7,
    LABEL_TAB_HERO: LABEL_TAB_HERO$7,
    LABEL_TAB_ICON: LABEL_TAB_ICON$7,
    LABEL_TAB_LOGO: LABEL_TAB_LOGO$7,
    LABEL_TAB_MANAGE: LABEL_TAB_MANAGE$7,
    LABEL_TAB_WIDECAPSULE: LABEL_TAB_WIDECAPSULE$7,
    LABEL_TRANSLATION_CREDIT_TITLE: LABEL_TRANSLATION_CREDIT_TITLE$7,
    LABEL_UNIFORM_RECENT: LABEL_UNIFORM_RECENT$4,
    LABEL_UNIFORM_RECENT_DESC: LABEL_UNIFORM_RECENT_DESC$4,
    LABEL_USAGE_TITLE: LABEL_USAGE_TITLE$7,
    MSG_ASSETS_FILTERED: MSG_ASSETS_FILTERED$6,
    MSG_ASSET_APPLY_ERROR: MSG_ASSET_APPLY_ERROR$6,
    MSG_ASSET_APPLY_SUCCESS: MSG_ASSET_APPLY_SUCCESS$6,
    MSG_ASSET_TAB_SETTINGS_DESC: MSG_ASSET_TAB_SETTINGS_DESC$6,
    MSG_FILTER_TAG_NSFW_ENABLED: MSG_FILTER_TAG_NSFW_ENABLED$6,
    MSG_GAME_SELECTED: MSG_GAME_SELECTED$6,
    MSG_GAME_SELECTED_AND_ASSETS_FILTERED: MSG_GAME_SELECTED_AND_ASSETS_FILTERED$6,
    MSG_RESTART_STEAM_DESC: MSG_RESTART_STEAM_DESC$6,
    MSG_USAGE_INSTRUCTIONS: MSG_USAGE_INSTRUCTIONS$7,
    TITLE_MOTD_HIDE: TITLE_MOTD_HIDE$5,
    default: ru
});

var ASSET_TYPE_CAPSULE$6="Omslag";var ASSET_TYPE_WIDECAPSULE$6="Brett omslag";var ASSET_TYPE_HERO$6="Banderoll";var ASSET_TYPE_LOGO$6="Logotyp";var ASSET_TYPE_ICON$6="Ikon";var LABEL_TAB_CAPSULE$6="Omslag";var LABEL_TAB_WIDECAPSULE$6="Brett omslag";var LABEL_TAB_HERO$6="Banderoll";var LABEL_TAB_LOGO$6="Logotyp";var LABEL_TAB_ICON$6="Ikon";var LABEL_TAB_MANAGE$6="Hantera";var MSG_USAGE_INSTRUCTIONS$6="Välj ett spel {arrow} {optionsButton} {arrow} \"{ACTION_CHANGE_ARTWORK}\"";var ACTION_CHANGE_ARTWORK$6="Ändra bilder...";var ACTION_SHOW_LINK_QR$6="Visa länk till QR-kod";var MSG_ASSET_TAB_SETTINGS_DESC$5="Ordna om eller dölj oanvända flikar och ställ in standardfliken som öppnas när du använder \"{ACTION_CHANGE_ARTWORK}\"";var LABEL_USAGE_TITLE$6="Snabbguide";var LABEL_SQUARE_CAPSULES$5="Fyrkantiga omslag";var LABEL_SQUARE_CAPSULES_DESC$4="Använd fyrkantiga omslag istället för stående. Fyrkantsfilter väljs automatiskt.";var LABEL_UNIFORM_RECENT$3="Matchande tidigare omslag";var LABEL_UNIFORM_RECENT_DESC$3="Se till att det senast spelade spelet på startskärmen matchar resten av omslagen.";var LABEL_CAPSULE_GLOW$5="Omslagsglöd";var LABEL_CAPSULE_GLOW_DESC$4="Justera glödintensitet för omslag i biblioteket.";var LABEL_CAPSULE_GLOW_OFF$5="Inget";var LABEL_SETTINGS_ASSET_TABS$5="Inställningar för tillgångsflikar";var LABEL_SETTINGS_DISABLE_MOTD$4="Inaktivera aviseringar";var LABEL_SETTINGS_DISABLE_MOTD_DESC$3="Aviseringar används sparsamt för att visa viktig information eller händelser i gemenskapen.";var LABEL_TRANSLATION_CREDIT_TITLE$6="Svensk översättning";var LABEL_MORE_SGDB_TITLE$6="Mer SteamGridDB-grejer";var ACTION_SGDB_DISCORD$6="Gå med i vår Discord";var ACTION_SGDB_GITHUB$5="Projekt med öppen källkod";var ACTION_SGDB_DONATE$6="Stöd oss på Patreon";var ACTION_SGDB_TRANSLATE$6="Hjälp till att översätta";var ACTION_SGDB_BOOP$6="Kolla in SGDBoop";var LABEL_RESTART_STEAM_TITLE$6="Starta om Steam?";var ACTION_RESTART_STEAM_LATER$6="Senare";var ACTION_RESTART_STEAM_NOW$6="Starta om nu";var MSG_RESTART_STEAM_DESC$5="Steam måste startas om för att ändringarna ska träda i kraft.";var LABEL_GAME_SEARCH_TITLE$6="Sök efter ett spel...";var LABEL_FILTER_MODAL_TITLE$6="{assetType}-filter";var LABEL_FILTER_GAME$6="Spel";var LABEL_FILTER_DIMENSIONS$6="Dimensioner";var LABEL_FILTER_STYLES$6="Stilar";var LABEL_FILTER_FILE_TYPES$6="Filtyper";var LABEL_FILTER_ANIMATION_TYPE_TITLE$6="Typer";var LABEL_FILTER_TYPE_ANIMATED$5="Animerad";var LABEL_FILTER_TYPE_STATIC$5="Statisk";var LABEL_FILTER_TAGS_TITLE$6="Taggar";var LABEL_FILTER_TAG_NSFW$6="Vuxet Innehåll";var MSG_FILTER_TAG_NSFW_ENABLED$5="Det är nog bäst att du ser dig för.";var LABEL_FILTER_TAG_HUMOR$5="Humor";var LABEL_FILTER_TAG_EPILEPSY$5="Epilepsi";var LABEL_FILTER_TAG_UNTAGGED$5="Otaggade";var ACTION_FILTER_RESET$6="Återställ filter";var LABEL_BEGGING_MODAL_TITLE$5="Tack för att du använder SteamGridDB!";var LABEL_BEGGING_MODAL_DESC$4="Överväg att donera för att hjälpa till med underhålls- och serverkostnader!";var ACTION_HIDE_POS_GUIDES$5="Dölj guider";var ACTION_SHOW_OUTLINE$5="Visa guider";var ACTION_ADJUST_POS_SIZE$6="Justera storleken";var ACTION_CHANGE_POS_LOGO_ANCHOR_POINT$3="Ändra ankringspunkt";var LABEL_ASSET_CURRENT$6="Nuvarande {assetType}";var ACTION_ASSET_CUSTOM_CLEAR$6="Töm anpassad tillgång";var ACTION_ASSET_BROWSE_LOCAL$5="Bläddra efter lokala filer";var ACTION_ASSET_APPLY_TRANSPARENT$5="Använd osynlig tillgång";var LABEL_NOTES$6="Kommentar";var LABEL_ANIMATED$5="Animerad";var LABEL_NSFW$6="Vuxet innehåll";var LABEL_HUMOR$5="Humor";var LABEL_EPILEPSY$5="Epilepsi";var ACTION_OPEN_FILTER$6="Filtrera";var ACTION_OPEN_OFFICIAL_ASSETS$6="Officiell {assetType}";var ACTION_ASSET_APPLY$5="Tillämpa {assetType}";var MSG_GAME_SELECTED$5="Vald {gameName}";var MSG_ASSETS_FILTERED$5="Vissa tillgångar kan döljas på grund av filter";var MSG_GAME_SELECTED_AND_ASSETS_FILTERED$5="Vald {gameName} med filter";var TITLE_MOTD_HIDE$4="Dölj avisering?";var LABEL_MOTD_THIS$4="Denna avisering";var LABEL_MOTD_ALL$4="Alla aviseringar";var MSG_ASSET_APPLY_SUCCESS$5="{assetType} har tillämpats!";var MSG_ASSET_APPLY_ERROR$5="Det gick inte att tillämpa denna tillgång.";var ACTION_OPEN_DETAILS$6="Detaljer";var sv = {ASSET_TYPE_CAPSULE:ASSET_TYPE_CAPSULE$6,ASSET_TYPE_WIDECAPSULE:ASSET_TYPE_WIDECAPSULE$6,ASSET_TYPE_HERO:ASSET_TYPE_HERO$6,ASSET_TYPE_LOGO:ASSET_TYPE_LOGO$6,ASSET_TYPE_ICON:ASSET_TYPE_ICON$6,LABEL_TAB_CAPSULE:LABEL_TAB_CAPSULE$6,LABEL_TAB_WIDECAPSULE:LABEL_TAB_WIDECAPSULE$6,LABEL_TAB_HERO:LABEL_TAB_HERO$6,LABEL_TAB_LOGO:LABEL_TAB_LOGO$6,LABEL_TAB_ICON:LABEL_TAB_ICON$6,LABEL_TAB_MANAGE:LABEL_TAB_MANAGE$6,MSG_USAGE_INSTRUCTIONS:MSG_USAGE_INSTRUCTIONS$6,ACTION_CHANGE_ARTWORK:ACTION_CHANGE_ARTWORK$6,ACTION_SHOW_LINK_QR:ACTION_SHOW_LINK_QR$6,MSG_ASSET_TAB_SETTINGS_DESC:MSG_ASSET_TAB_SETTINGS_DESC$5,LABEL_USAGE_TITLE:LABEL_USAGE_TITLE$6,LABEL_SQUARE_CAPSULES:LABEL_SQUARE_CAPSULES$5,LABEL_SQUARE_CAPSULES_DESC:LABEL_SQUARE_CAPSULES_DESC$4,LABEL_UNIFORM_RECENT:LABEL_UNIFORM_RECENT$3,LABEL_UNIFORM_RECENT_DESC:LABEL_UNIFORM_RECENT_DESC$3,LABEL_CAPSULE_GLOW:LABEL_CAPSULE_GLOW$5,LABEL_CAPSULE_GLOW_DESC:LABEL_CAPSULE_GLOW_DESC$4,LABEL_CAPSULE_GLOW_OFF:LABEL_CAPSULE_GLOW_OFF$5,LABEL_SETTINGS_ASSET_TABS:LABEL_SETTINGS_ASSET_TABS$5,LABEL_SETTINGS_DISABLE_MOTD:LABEL_SETTINGS_DISABLE_MOTD$4,LABEL_SETTINGS_DISABLE_MOTD_DESC:LABEL_SETTINGS_DISABLE_MOTD_DESC$3,LABEL_TRANSLATION_CREDIT_TITLE:LABEL_TRANSLATION_CREDIT_TITLE$6,LABEL_MORE_SGDB_TITLE:LABEL_MORE_SGDB_TITLE$6,ACTION_SGDB_DISCORD:ACTION_SGDB_DISCORD$6,ACTION_SGDB_GITHUB:ACTION_SGDB_GITHUB$5,ACTION_SGDB_DONATE:ACTION_SGDB_DONATE$6,ACTION_SGDB_TRANSLATE:ACTION_SGDB_TRANSLATE$6,ACTION_SGDB_BOOP:ACTION_SGDB_BOOP$6,LABEL_RESTART_STEAM_TITLE:LABEL_RESTART_STEAM_TITLE$6,ACTION_RESTART_STEAM_LATER:ACTION_RESTART_STEAM_LATER$6,ACTION_RESTART_STEAM_NOW:ACTION_RESTART_STEAM_NOW$6,MSG_RESTART_STEAM_DESC:MSG_RESTART_STEAM_DESC$5,LABEL_GAME_SEARCH_TITLE:LABEL_GAME_SEARCH_TITLE$6,LABEL_FILTER_MODAL_TITLE:LABEL_FILTER_MODAL_TITLE$6,LABEL_FILTER_GAME:LABEL_FILTER_GAME$6,LABEL_FILTER_DIMENSIONS:LABEL_FILTER_DIMENSIONS$6,LABEL_FILTER_STYLES:LABEL_FILTER_STYLES$6,LABEL_FILTER_FILE_TYPES:LABEL_FILTER_FILE_TYPES$6,LABEL_FILTER_ANIMATION_TYPE_TITLE:LABEL_FILTER_ANIMATION_TYPE_TITLE$6,LABEL_FILTER_TYPE_ANIMATED:LABEL_FILTER_TYPE_ANIMATED$5,LABEL_FILTER_TYPE_STATIC:LABEL_FILTER_TYPE_STATIC$5,LABEL_FILTER_TAGS_TITLE:LABEL_FILTER_TAGS_TITLE$6,LABEL_FILTER_TAG_NSFW:LABEL_FILTER_TAG_NSFW$6,MSG_FILTER_TAG_NSFW_ENABLED:MSG_FILTER_TAG_NSFW_ENABLED$5,LABEL_FILTER_TAG_HUMOR:LABEL_FILTER_TAG_HUMOR$5,LABEL_FILTER_TAG_EPILEPSY:LABEL_FILTER_TAG_EPILEPSY$5,LABEL_FILTER_TAG_UNTAGGED:LABEL_FILTER_TAG_UNTAGGED$5,ACTION_FILTER_RESET:ACTION_FILTER_RESET$6,LABEL_BEGGING_MODAL_TITLE:LABEL_BEGGING_MODAL_TITLE$5,LABEL_BEGGING_MODAL_DESC:LABEL_BEGGING_MODAL_DESC$4,ACTION_HIDE_POS_GUIDES:ACTION_HIDE_POS_GUIDES$5,ACTION_SHOW_OUTLINE:ACTION_SHOW_OUTLINE$5,ACTION_ADJUST_POS_SIZE:ACTION_ADJUST_POS_SIZE$6,ACTION_CHANGE_POS_LOGO_ANCHOR_POINT:ACTION_CHANGE_POS_LOGO_ANCHOR_POINT$3,LABEL_ASSET_CURRENT:LABEL_ASSET_CURRENT$6,ACTION_ASSET_CUSTOM_CLEAR:ACTION_ASSET_CUSTOM_CLEAR$6,ACTION_ASSET_BROWSE_LOCAL:ACTION_ASSET_BROWSE_LOCAL$5,ACTION_ASSET_APPLY_TRANSPARENT:ACTION_ASSET_APPLY_TRANSPARENT$5,LABEL_NOTES:LABEL_NOTES$6,LABEL_ANIMATED:LABEL_ANIMATED$5,LABEL_NSFW:LABEL_NSFW$6,LABEL_HUMOR:LABEL_HUMOR$5,LABEL_EPILEPSY:LABEL_EPILEPSY$5,ACTION_OPEN_FILTER:ACTION_OPEN_FILTER$6,ACTION_OPEN_OFFICIAL_ASSETS:ACTION_OPEN_OFFICIAL_ASSETS$6,ACTION_ASSET_APPLY:ACTION_ASSET_APPLY$5,MSG_GAME_SELECTED:MSG_GAME_SELECTED$5,MSG_ASSETS_FILTERED:MSG_ASSETS_FILTERED$5,MSG_GAME_SELECTED_AND_ASSETS_FILTERED:MSG_GAME_SELECTED_AND_ASSETS_FILTERED$5,TITLE_MOTD_HIDE:TITLE_MOTD_HIDE$4,LABEL_MOTD_THIS:LABEL_MOTD_THIS$4,LABEL_MOTD_ALL:LABEL_MOTD_ALL$4,MSG_ASSET_APPLY_SUCCESS:MSG_ASSET_APPLY_SUCCESS$5,MSG_ASSET_APPLY_ERROR:MSG_ASSET_APPLY_ERROR$5,ACTION_OPEN_DETAILS:ACTION_OPEN_DETAILS$6};

var sv$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    ACTION_ADJUST_POS_SIZE: ACTION_ADJUST_POS_SIZE$6,
    ACTION_ASSET_APPLY: ACTION_ASSET_APPLY$5,
    ACTION_ASSET_APPLY_TRANSPARENT: ACTION_ASSET_APPLY_TRANSPARENT$5,
    ACTION_ASSET_BROWSE_LOCAL: ACTION_ASSET_BROWSE_LOCAL$5,
    ACTION_ASSET_CUSTOM_CLEAR: ACTION_ASSET_CUSTOM_CLEAR$6,
    ACTION_CHANGE_ARTWORK: ACTION_CHANGE_ARTWORK$6,
    ACTION_CHANGE_POS_LOGO_ANCHOR_POINT: ACTION_CHANGE_POS_LOGO_ANCHOR_POINT$3,
    ACTION_FILTER_RESET: ACTION_FILTER_RESET$6,
    ACTION_HIDE_POS_GUIDES: ACTION_HIDE_POS_GUIDES$5,
    ACTION_OPEN_DETAILS: ACTION_OPEN_DETAILS$6,
    ACTION_OPEN_FILTER: ACTION_OPEN_FILTER$6,
    ACTION_OPEN_OFFICIAL_ASSETS: ACTION_OPEN_OFFICIAL_ASSETS$6,
    ACTION_RESTART_STEAM_LATER: ACTION_RESTART_STEAM_LATER$6,
    ACTION_RESTART_STEAM_NOW: ACTION_RESTART_STEAM_NOW$6,
    ACTION_SGDB_BOOP: ACTION_SGDB_BOOP$6,
    ACTION_SGDB_DISCORD: ACTION_SGDB_DISCORD$6,
    ACTION_SGDB_DONATE: ACTION_SGDB_DONATE$6,
    ACTION_SGDB_GITHUB: ACTION_SGDB_GITHUB$5,
    ACTION_SGDB_TRANSLATE: ACTION_SGDB_TRANSLATE$6,
    ACTION_SHOW_LINK_QR: ACTION_SHOW_LINK_QR$6,
    ACTION_SHOW_OUTLINE: ACTION_SHOW_OUTLINE$5,
    ASSET_TYPE_CAPSULE: ASSET_TYPE_CAPSULE$6,
    ASSET_TYPE_HERO: ASSET_TYPE_HERO$6,
    ASSET_TYPE_ICON: ASSET_TYPE_ICON$6,
    ASSET_TYPE_LOGO: ASSET_TYPE_LOGO$6,
    ASSET_TYPE_WIDECAPSULE: ASSET_TYPE_WIDECAPSULE$6,
    LABEL_ANIMATED: LABEL_ANIMATED$5,
    LABEL_ASSET_CURRENT: LABEL_ASSET_CURRENT$6,
    LABEL_BEGGING_MODAL_DESC: LABEL_BEGGING_MODAL_DESC$4,
    LABEL_BEGGING_MODAL_TITLE: LABEL_BEGGING_MODAL_TITLE$5,
    LABEL_CAPSULE_GLOW: LABEL_CAPSULE_GLOW$5,
    LABEL_CAPSULE_GLOW_DESC: LABEL_CAPSULE_GLOW_DESC$4,
    LABEL_CAPSULE_GLOW_OFF: LABEL_CAPSULE_GLOW_OFF$5,
    LABEL_EPILEPSY: LABEL_EPILEPSY$5,
    LABEL_FILTER_ANIMATION_TYPE_TITLE: LABEL_FILTER_ANIMATION_TYPE_TITLE$6,
    LABEL_FILTER_DIMENSIONS: LABEL_FILTER_DIMENSIONS$6,
    LABEL_FILTER_FILE_TYPES: LABEL_FILTER_FILE_TYPES$6,
    LABEL_FILTER_GAME: LABEL_FILTER_GAME$6,
    LABEL_FILTER_MODAL_TITLE: LABEL_FILTER_MODAL_TITLE$6,
    LABEL_FILTER_STYLES: LABEL_FILTER_STYLES$6,
    LABEL_FILTER_TAGS_TITLE: LABEL_FILTER_TAGS_TITLE$6,
    LABEL_FILTER_TAG_EPILEPSY: LABEL_FILTER_TAG_EPILEPSY$5,
    LABEL_FILTER_TAG_HUMOR: LABEL_FILTER_TAG_HUMOR$5,
    LABEL_FILTER_TAG_NSFW: LABEL_FILTER_TAG_NSFW$6,
    LABEL_FILTER_TAG_UNTAGGED: LABEL_FILTER_TAG_UNTAGGED$5,
    LABEL_FILTER_TYPE_ANIMATED: LABEL_FILTER_TYPE_ANIMATED$5,
    LABEL_FILTER_TYPE_STATIC: LABEL_FILTER_TYPE_STATIC$5,
    LABEL_GAME_SEARCH_TITLE: LABEL_GAME_SEARCH_TITLE$6,
    LABEL_HUMOR: LABEL_HUMOR$5,
    LABEL_MORE_SGDB_TITLE: LABEL_MORE_SGDB_TITLE$6,
    LABEL_MOTD_ALL: LABEL_MOTD_ALL$4,
    LABEL_MOTD_THIS: LABEL_MOTD_THIS$4,
    LABEL_NOTES: LABEL_NOTES$6,
    LABEL_NSFW: LABEL_NSFW$6,
    LABEL_RESTART_STEAM_TITLE: LABEL_RESTART_STEAM_TITLE$6,
    LABEL_SETTINGS_ASSET_TABS: LABEL_SETTINGS_ASSET_TABS$5,
    LABEL_SETTINGS_DISABLE_MOTD: LABEL_SETTINGS_DISABLE_MOTD$4,
    LABEL_SETTINGS_DISABLE_MOTD_DESC: LABEL_SETTINGS_DISABLE_MOTD_DESC$3,
    LABEL_SQUARE_CAPSULES: LABEL_SQUARE_CAPSULES$5,
    LABEL_SQUARE_CAPSULES_DESC: LABEL_SQUARE_CAPSULES_DESC$4,
    LABEL_TAB_CAPSULE: LABEL_TAB_CAPSULE$6,
    LABEL_TAB_HERO: LABEL_TAB_HERO$6,
    LABEL_TAB_ICON: LABEL_TAB_ICON$6,
    LABEL_TAB_LOGO: LABEL_TAB_LOGO$6,
    LABEL_TAB_MANAGE: LABEL_TAB_MANAGE$6,
    LABEL_TAB_WIDECAPSULE: LABEL_TAB_WIDECAPSULE$6,
    LABEL_TRANSLATION_CREDIT_TITLE: LABEL_TRANSLATION_CREDIT_TITLE$6,
    LABEL_UNIFORM_RECENT: LABEL_UNIFORM_RECENT$3,
    LABEL_UNIFORM_RECENT_DESC: LABEL_UNIFORM_RECENT_DESC$3,
    LABEL_USAGE_TITLE: LABEL_USAGE_TITLE$6,
    MSG_ASSETS_FILTERED: MSG_ASSETS_FILTERED$5,
    MSG_ASSET_APPLY_ERROR: MSG_ASSET_APPLY_ERROR$5,
    MSG_ASSET_APPLY_SUCCESS: MSG_ASSET_APPLY_SUCCESS$5,
    MSG_ASSET_TAB_SETTINGS_DESC: MSG_ASSET_TAB_SETTINGS_DESC$5,
    MSG_FILTER_TAG_NSFW_ENABLED: MSG_FILTER_TAG_NSFW_ENABLED$5,
    MSG_GAME_SELECTED: MSG_GAME_SELECTED$5,
    MSG_GAME_SELECTED_AND_ASSETS_FILTERED: MSG_GAME_SELECTED_AND_ASSETS_FILTERED$5,
    MSG_RESTART_STEAM_DESC: MSG_RESTART_STEAM_DESC$5,
    MSG_USAGE_INSTRUCTIONS: MSG_USAGE_INSTRUCTIONS$6,
    TITLE_MOTD_HIDE: TITLE_MOTD_HIDE$4,
    default: sv
});

var ASSET_TYPE_CAPSULE$5="Kapak";var ASSET_TYPE_WIDECAPSULE$5="Geniş Kapak";var ASSET_TYPE_HERO$5="Arkaplan";var ASSET_TYPE_LOGO$5="Logo";var ASSET_TYPE_ICON$5="İkon";var LABEL_TAB_CAPSULE$5="Kapak";var LABEL_TAB_WIDECAPSULE$5="Geniş Kapak";var LABEL_TAB_HERO$5="Arkaplan";var LABEL_TAB_LOGO$5="Logo";var LABEL_TAB_ICON$5="İkon";var LABEL_TAB_MANAGE$5="Yönet";var MSG_USAGE_INSTRUCTIONS$5="Bir oyun seç {arrow} {optionsButton}'a Bas {arrow} \"{ACTION_CHANGE_ARTWORK}\"";var ACTION_CHANGE_ARTWORK$5="Kapak Değiştir";var ACTION_SHOW_LINK_QR$5="Link QR'ını Göster";var MSG_ASSET_TAB_SETTINGS_DESC$4="Sekmeleri sırala, gizle veya ilk açılacak sekmeyi seç.";var LABEL_USAGE_TITLE$5="Nasıl Kullanılır?";var LABEL_SQUARE_CAPSULES$4="Kare Kapaklar";var LABEL_SQUARE_CAPSULES_DESC$3="Dikdörtgen yerine kare kapaklar kullanın. Kare kapak filtresi otomatik olarak seçilecektir.";var LABEL_UNIFORM_RECENT$2="Son Kapaklarla Eşleşenler";var LABEL_UNIFORM_RECENT_DESC$2="Ana ekrandaki en çok oynanan oyunun diğer kapaklarla eşleşmesini sağla.";var LABEL_CAPSULE_GLOW$4="Kapak Parıltısı";var LABEL_CAPSULE_GLOW_DESC$3="Kütüphanedeki kapak parıltısınının yoğunluğunu ayarlayın.";var LABEL_CAPSULE_GLOW_OFF$4="Yok";var LABEL_SETTINGS_ASSET_TABS$4="İçerik Sekmesi Ayarları";var LABEL_SETTINGS_DISABLE_MOTD$3="Bilgilendirmeleri kapat";var LABEL_SETTINGS_DISABLE_MOTD_DESC$2="Bilgilendirmeler önemli bilgileri veya topluluk etkinliklerinden haberdar olmanız için yapılır";var LABEL_TRANSLATION_CREDIT_TITLE$5="Türkçe Çeviri";var LABEL_MORE_SGDB_TITLE$5="Daha Fazla SteamGridDB İçeriği";var ACTION_SGDB_DISCORD$5="Discord Sunucusuna Katıl";var ACTION_SGDB_GITHUB$4="Açık Kaynak Kodlu Projeler";var ACTION_SGDB_DONATE$5="Patreon'da Destekle";var ACTION_SGDB_TRANSLATE$5="Çeviriye Yardım Et";var ACTION_SGDB_BOOP$5="SGDBoop'a Gözat";var LABEL_RESTART_STEAM_TITLE$5="Steam Yeniden Başlatılsın Mı?";var ACTION_RESTART_STEAM_LATER$5="Daha Sonra";var ACTION_RESTART_STEAM_NOW$5="Şimdi Yeniden Başlat";var MSG_RESTART_STEAM_DESC$4="Değişikliklerin uygulanabilmesi için Steam yeniden başlatılmalıdır.";var LABEL_GAME_SEARCH_TITLE$5="Oyun Ara";var LABEL_FILTER_MODAL_TITLE$5="{assetType} Filtreleri";var LABEL_FILTER_GAME$5="Oyun";var LABEL_FILTER_DIMENSIONS$5="Boyutlar";var LABEL_FILTER_STYLES$5="Stiller";var LABEL_FILTER_FILE_TYPES$5="Dosya Tipleri";var LABEL_FILTER_ANIMATION_TYPE_TITLE$5="Türler";var LABEL_FILTER_TYPE_ANIMATED$4="Hareketli";var LABEL_FILTER_TYPE_STATIC$4="Hareketsiz";var LABEL_FILTER_TAGS_TITLE$5="Etiketler";var LABEL_FILTER_TAG_NSFW$5="Yetişkin İçeriği";var MSG_FILTER_TAG_NSFW_ENABLED$4="Biraz gözatmaktan zarar gelmez ;)";var LABEL_FILTER_TAG_HUMOR$4="Komik";var LABEL_FILTER_TAG_EPILEPSY$4="Epilepsi";var LABEL_FILTER_TAG_UNTAGGED$4="Etiketlenmemiş";var ACTION_FILTER_RESET$5="Filtreleri Sıfırla";var LABEL_BEGGING_MODAL_TITLE$4="SteamGridDB'yi kullandığınız için teşekkürler!";var LABEL_BEGGING_MODAL_DESC$3="Bağış yaparak geliştirme ve sunucu maliyetleri için destek olabilirsiniz!";var ACTION_HIDE_POS_GUIDES$4="Kılavuzu Gizle";var ACTION_SHOW_OUTLINE$4="Kılavuzu Göster";var ACTION_ADJUST_POS_SIZE$5="Boyutu Ayarla";var ACTION_CHANGE_POS_LOGO_ANCHOR_POINT$2="Sabitlenecek Noktayı Değiştir";var LABEL_ASSET_CURRENT$5="Mevcut {assetType}";var ACTION_ASSET_CUSTOM_CLEAR$5="Seçilen Görseli Kaldır";var ACTION_ASSET_BROWSE_LOCAL$4="Yerel Dosyalara Gözat";var ACTION_ASSET_APPLY_TRANSPARENT$4="Görünmez Görsel Kullan";var LABEL_NOTES$5="Notlar";var LABEL_ANIMATED$4="Hareketli";var LABEL_NSFW$5="Yetişkin İçeriği";var LABEL_HUMOR$4="Komik";var LABEL_EPILEPSY$4="Epilepsi";var ACTION_OPEN_FILTER$5="Filtre";var ACTION_OPEN_OFFICIAL_ASSETS$5="Resmi {assetType}";var ACTION_ASSET_APPLY$4="{assetType} Uygula";var MSG_GAME_SELECTED$4="{gameName} Seçildi";var MSG_ASSETS_FILTERED$4="Bazı İçerikler Filtre Sebebiyle Görünmüyor Olabilir";var MSG_GAME_SELECTED_AND_ASSETS_FILTERED$4="Filtrelenmiş {gameName} Seçildi";var TITLE_MOTD_HIDE$3="Bilgilendirmeler kapatılsın mı?";var LABEL_MOTD_THIS$3="Bu bilgilendirme";var LABEL_MOTD_ALL$3="Tüm bilgilendirmeler";var MSG_ASSET_APPLY_SUCCESS$4="{assetType} başarıyla uygulandı!";var MSG_ASSET_APPLY_ERROR$4="Görsel uygulanırken bir problem oluştu.";var ACTION_OPEN_DETAILS$5="Ayrıntılar";var tr = {ASSET_TYPE_CAPSULE:ASSET_TYPE_CAPSULE$5,ASSET_TYPE_WIDECAPSULE:ASSET_TYPE_WIDECAPSULE$5,ASSET_TYPE_HERO:ASSET_TYPE_HERO$5,ASSET_TYPE_LOGO:ASSET_TYPE_LOGO$5,ASSET_TYPE_ICON:ASSET_TYPE_ICON$5,LABEL_TAB_CAPSULE:LABEL_TAB_CAPSULE$5,LABEL_TAB_WIDECAPSULE:LABEL_TAB_WIDECAPSULE$5,LABEL_TAB_HERO:LABEL_TAB_HERO$5,LABEL_TAB_LOGO:LABEL_TAB_LOGO$5,LABEL_TAB_ICON:LABEL_TAB_ICON$5,LABEL_TAB_MANAGE:LABEL_TAB_MANAGE$5,MSG_USAGE_INSTRUCTIONS:MSG_USAGE_INSTRUCTIONS$5,ACTION_CHANGE_ARTWORK:ACTION_CHANGE_ARTWORK$5,ACTION_SHOW_LINK_QR:ACTION_SHOW_LINK_QR$5,MSG_ASSET_TAB_SETTINGS_DESC:MSG_ASSET_TAB_SETTINGS_DESC$4,LABEL_USAGE_TITLE:LABEL_USAGE_TITLE$5,LABEL_SQUARE_CAPSULES:LABEL_SQUARE_CAPSULES$4,LABEL_SQUARE_CAPSULES_DESC:LABEL_SQUARE_CAPSULES_DESC$3,LABEL_UNIFORM_RECENT:LABEL_UNIFORM_RECENT$2,LABEL_UNIFORM_RECENT_DESC:LABEL_UNIFORM_RECENT_DESC$2,LABEL_CAPSULE_GLOW:LABEL_CAPSULE_GLOW$4,LABEL_CAPSULE_GLOW_DESC:LABEL_CAPSULE_GLOW_DESC$3,LABEL_CAPSULE_GLOW_OFF:LABEL_CAPSULE_GLOW_OFF$4,LABEL_SETTINGS_ASSET_TABS:LABEL_SETTINGS_ASSET_TABS$4,LABEL_SETTINGS_DISABLE_MOTD:LABEL_SETTINGS_DISABLE_MOTD$3,LABEL_SETTINGS_DISABLE_MOTD_DESC:LABEL_SETTINGS_DISABLE_MOTD_DESC$2,LABEL_TRANSLATION_CREDIT_TITLE:LABEL_TRANSLATION_CREDIT_TITLE$5,LABEL_MORE_SGDB_TITLE:LABEL_MORE_SGDB_TITLE$5,ACTION_SGDB_DISCORD:ACTION_SGDB_DISCORD$5,ACTION_SGDB_GITHUB:ACTION_SGDB_GITHUB$4,ACTION_SGDB_DONATE:ACTION_SGDB_DONATE$5,ACTION_SGDB_TRANSLATE:ACTION_SGDB_TRANSLATE$5,ACTION_SGDB_BOOP:ACTION_SGDB_BOOP$5,LABEL_RESTART_STEAM_TITLE:LABEL_RESTART_STEAM_TITLE$5,ACTION_RESTART_STEAM_LATER:ACTION_RESTART_STEAM_LATER$5,ACTION_RESTART_STEAM_NOW:ACTION_RESTART_STEAM_NOW$5,MSG_RESTART_STEAM_DESC:MSG_RESTART_STEAM_DESC$4,LABEL_GAME_SEARCH_TITLE:LABEL_GAME_SEARCH_TITLE$5,LABEL_FILTER_MODAL_TITLE:LABEL_FILTER_MODAL_TITLE$5,LABEL_FILTER_GAME:LABEL_FILTER_GAME$5,LABEL_FILTER_DIMENSIONS:LABEL_FILTER_DIMENSIONS$5,LABEL_FILTER_STYLES:LABEL_FILTER_STYLES$5,LABEL_FILTER_FILE_TYPES:LABEL_FILTER_FILE_TYPES$5,LABEL_FILTER_ANIMATION_TYPE_TITLE:LABEL_FILTER_ANIMATION_TYPE_TITLE$5,LABEL_FILTER_TYPE_ANIMATED:LABEL_FILTER_TYPE_ANIMATED$4,LABEL_FILTER_TYPE_STATIC:LABEL_FILTER_TYPE_STATIC$4,LABEL_FILTER_TAGS_TITLE:LABEL_FILTER_TAGS_TITLE$5,LABEL_FILTER_TAG_NSFW:LABEL_FILTER_TAG_NSFW$5,MSG_FILTER_TAG_NSFW_ENABLED:MSG_FILTER_TAG_NSFW_ENABLED$4,LABEL_FILTER_TAG_HUMOR:LABEL_FILTER_TAG_HUMOR$4,LABEL_FILTER_TAG_EPILEPSY:LABEL_FILTER_TAG_EPILEPSY$4,LABEL_FILTER_TAG_UNTAGGED:LABEL_FILTER_TAG_UNTAGGED$4,ACTION_FILTER_RESET:ACTION_FILTER_RESET$5,LABEL_BEGGING_MODAL_TITLE:LABEL_BEGGING_MODAL_TITLE$4,LABEL_BEGGING_MODAL_DESC:LABEL_BEGGING_MODAL_DESC$3,ACTION_HIDE_POS_GUIDES:ACTION_HIDE_POS_GUIDES$4,ACTION_SHOW_OUTLINE:ACTION_SHOW_OUTLINE$4,ACTION_ADJUST_POS_SIZE:ACTION_ADJUST_POS_SIZE$5,ACTION_CHANGE_POS_LOGO_ANCHOR_POINT:ACTION_CHANGE_POS_LOGO_ANCHOR_POINT$2,LABEL_ASSET_CURRENT:LABEL_ASSET_CURRENT$5,ACTION_ASSET_CUSTOM_CLEAR:ACTION_ASSET_CUSTOM_CLEAR$5,ACTION_ASSET_BROWSE_LOCAL:ACTION_ASSET_BROWSE_LOCAL$4,ACTION_ASSET_APPLY_TRANSPARENT:ACTION_ASSET_APPLY_TRANSPARENT$4,LABEL_NOTES:LABEL_NOTES$5,LABEL_ANIMATED:LABEL_ANIMATED$4,LABEL_NSFW:LABEL_NSFW$5,LABEL_HUMOR:LABEL_HUMOR$4,LABEL_EPILEPSY:LABEL_EPILEPSY$4,ACTION_OPEN_FILTER:ACTION_OPEN_FILTER$5,ACTION_OPEN_OFFICIAL_ASSETS:ACTION_OPEN_OFFICIAL_ASSETS$5,ACTION_ASSET_APPLY:ACTION_ASSET_APPLY$4,MSG_GAME_SELECTED:MSG_GAME_SELECTED$4,MSG_ASSETS_FILTERED:MSG_ASSETS_FILTERED$4,MSG_GAME_SELECTED_AND_ASSETS_FILTERED:MSG_GAME_SELECTED_AND_ASSETS_FILTERED$4,TITLE_MOTD_HIDE:TITLE_MOTD_HIDE$3,LABEL_MOTD_THIS:LABEL_MOTD_THIS$3,LABEL_MOTD_ALL:LABEL_MOTD_ALL$3,MSG_ASSET_APPLY_SUCCESS:MSG_ASSET_APPLY_SUCCESS$4,MSG_ASSET_APPLY_ERROR:MSG_ASSET_APPLY_ERROR$4,ACTION_OPEN_DETAILS:ACTION_OPEN_DETAILS$5};

var tr$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    ACTION_ADJUST_POS_SIZE: ACTION_ADJUST_POS_SIZE$5,
    ACTION_ASSET_APPLY: ACTION_ASSET_APPLY$4,
    ACTION_ASSET_APPLY_TRANSPARENT: ACTION_ASSET_APPLY_TRANSPARENT$4,
    ACTION_ASSET_BROWSE_LOCAL: ACTION_ASSET_BROWSE_LOCAL$4,
    ACTION_ASSET_CUSTOM_CLEAR: ACTION_ASSET_CUSTOM_CLEAR$5,
    ACTION_CHANGE_ARTWORK: ACTION_CHANGE_ARTWORK$5,
    ACTION_CHANGE_POS_LOGO_ANCHOR_POINT: ACTION_CHANGE_POS_LOGO_ANCHOR_POINT$2,
    ACTION_FILTER_RESET: ACTION_FILTER_RESET$5,
    ACTION_HIDE_POS_GUIDES: ACTION_HIDE_POS_GUIDES$4,
    ACTION_OPEN_DETAILS: ACTION_OPEN_DETAILS$5,
    ACTION_OPEN_FILTER: ACTION_OPEN_FILTER$5,
    ACTION_OPEN_OFFICIAL_ASSETS: ACTION_OPEN_OFFICIAL_ASSETS$5,
    ACTION_RESTART_STEAM_LATER: ACTION_RESTART_STEAM_LATER$5,
    ACTION_RESTART_STEAM_NOW: ACTION_RESTART_STEAM_NOW$5,
    ACTION_SGDB_BOOP: ACTION_SGDB_BOOP$5,
    ACTION_SGDB_DISCORD: ACTION_SGDB_DISCORD$5,
    ACTION_SGDB_DONATE: ACTION_SGDB_DONATE$5,
    ACTION_SGDB_GITHUB: ACTION_SGDB_GITHUB$4,
    ACTION_SGDB_TRANSLATE: ACTION_SGDB_TRANSLATE$5,
    ACTION_SHOW_LINK_QR: ACTION_SHOW_LINK_QR$5,
    ACTION_SHOW_OUTLINE: ACTION_SHOW_OUTLINE$4,
    ASSET_TYPE_CAPSULE: ASSET_TYPE_CAPSULE$5,
    ASSET_TYPE_HERO: ASSET_TYPE_HERO$5,
    ASSET_TYPE_ICON: ASSET_TYPE_ICON$5,
    ASSET_TYPE_LOGO: ASSET_TYPE_LOGO$5,
    ASSET_TYPE_WIDECAPSULE: ASSET_TYPE_WIDECAPSULE$5,
    LABEL_ANIMATED: LABEL_ANIMATED$4,
    LABEL_ASSET_CURRENT: LABEL_ASSET_CURRENT$5,
    LABEL_BEGGING_MODAL_DESC: LABEL_BEGGING_MODAL_DESC$3,
    LABEL_BEGGING_MODAL_TITLE: LABEL_BEGGING_MODAL_TITLE$4,
    LABEL_CAPSULE_GLOW: LABEL_CAPSULE_GLOW$4,
    LABEL_CAPSULE_GLOW_DESC: LABEL_CAPSULE_GLOW_DESC$3,
    LABEL_CAPSULE_GLOW_OFF: LABEL_CAPSULE_GLOW_OFF$4,
    LABEL_EPILEPSY: LABEL_EPILEPSY$4,
    LABEL_FILTER_ANIMATION_TYPE_TITLE: LABEL_FILTER_ANIMATION_TYPE_TITLE$5,
    LABEL_FILTER_DIMENSIONS: LABEL_FILTER_DIMENSIONS$5,
    LABEL_FILTER_FILE_TYPES: LABEL_FILTER_FILE_TYPES$5,
    LABEL_FILTER_GAME: LABEL_FILTER_GAME$5,
    LABEL_FILTER_MODAL_TITLE: LABEL_FILTER_MODAL_TITLE$5,
    LABEL_FILTER_STYLES: LABEL_FILTER_STYLES$5,
    LABEL_FILTER_TAGS_TITLE: LABEL_FILTER_TAGS_TITLE$5,
    LABEL_FILTER_TAG_EPILEPSY: LABEL_FILTER_TAG_EPILEPSY$4,
    LABEL_FILTER_TAG_HUMOR: LABEL_FILTER_TAG_HUMOR$4,
    LABEL_FILTER_TAG_NSFW: LABEL_FILTER_TAG_NSFW$5,
    LABEL_FILTER_TAG_UNTAGGED: LABEL_FILTER_TAG_UNTAGGED$4,
    LABEL_FILTER_TYPE_ANIMATED: LABEL_FILTER_TYPE_ANIMATED$4,
    LABEL_FILTER_TYPE_STATIC: LABEL_FILTER_TYPE_STATIC$4,
    LABEL_GAME_SEARCH_TITLE: LABEL_GAME_SEARCH_TITLE$5,
    LABEL_HUMOR: LABEL_HUMOR$4,
    LABEL_MORE_SGDB_TITLE: LABEL_MORE_SGDB_TITLE$5,
    LABEL_MOTD_ALL: LABEL_MOTD_ALL$3,
    LABEL_MOTD_THIS: LABEL_MOTD_THIS$3,
    LABEL_NOTES: LABEL_NOTES$5,
    LABEL_NSFW: LABEL_NSFW$5,
    LABEL_RESTART_STEAM_TITLE: LABEL_RESTART_STEAM_TITLE$5,
    LABEL_SETTINGS_ASSET_TABS: LABEL_SETTINGS_ASSET_TABS$4,
    LABEL_SETTINGS_DISABLE_MOTD: LABEL_SETTINGS_DISABLE_MOTD$3,
    LABEL_SETTINGS_DISABLE_MOTD_DESC: LABEL_SETTINGS_DISABLE_MOTD_DESC$2,
    LABEL_SQUARE_CAPSULES: LABEL_SQUARE_CAPSULES$4,
    LABEL_SQUARE_CAPSULES_DESC: LABEL_SQUARE_CAPSULES_DESC$3,
    LABEL_TAB_CAPSULE: LABEL_TAB_CAPSULE$5,
    LABEL_TAB_HERO: LABEL_TAB_HERO$5,
    LABEL_TAB_ICON: LABEL_TAB_ICON$5,
    LABEL_TAB_LOGO: LABEL_TAB_LOGO$5,
    LABEL_TAB_MANAGE: LABEL_TAB_MANAGE$5,
    LABEL_TAB_WIDECAPSULE: LABEL_TAB_WIDECAPSULE$5,
    LABEL_TRANSLATION_CREDIT_TITLE: LABEL_TRANSLATION_CREDIT_TITLE$5,
    LABEL_UNIFORM_RECENT: LABEL_UNIFORM_RECENT$2,
    LABEL_UNIFORM_RECENT_DESC: LABEL_UNIFORM_RECENT_DESC$2,
    LABEL_USAGE_TITLE: LABEL_USAGE_TITLE$5,
    MSG_ASSETS_FILTERED: MSG_ASSETS_FILTERED$4,
    MSG_ASSET_APPLY_ERROR: MSG_ASSET_APPLY_ERROR$4,
    MSG_ASSET_APPLY_SUCCESS: MSG_ASSET_APPLY_SUCCESS$4,
    MSG_ASSET_TAB_SETTINGS_DESC: MSG_ASSET_TAB_SETTINGS_DESC$4,
    MSG_FILTER_TAG_NSFW_ENABLED: MSG_FILTER_TAG_NSFW_ENABLED$4,
    MSG_GAME_SELECTED: MSG_GAME_SELECTED$4,
    MSG_GAME_SELECTED_AND_ASSETS_FILTERED: MSG_GAME_SELECTED_AND_ASSETS_FILTERED$4,
    MSG_RESTART_STEAM_DESC: MSG_RESTART_STEAM_DESC$4,
    MSG_USAGE_INSTRUCTIONS: MSG_USAGE_INSTRUCTIONS$5,
    TITLE_MOTD_HIDE: TITLE_MOTD_HIDE$3,
    default: tr
});

var ASSET_TYPE_CAPSULE$4="Капсула";var ASSET_TYPE_WIDECAPSULE$4="Широка капсула";var ASSET_TYPE_HERO$4="Банер";var ASSET_TYPE_LOGO$4="Логотип";var ASSET_TYPE_ICON$4="Піктограма";var LABEL_TAB_CAPSULE$4="Капсула";var LABEL_TAB_WIDECAPSULE$4="Широка капсула";var LABEL_TAB_HERO$4="Банер";var LABEL_TAB_LOGO$4="Логотип";var LABEL_TAB_ICON$4="Піктограма";var LABEL_TAB_MANAGE$4="Керувати";var MSG_USAGE_INSTRUCTIONS$4="Вибрати гру {arrow} {optionsButton} {arrow} «{ACTION_CHANGE_ARTWORK}»";var ACTION_CHANGE_ARTWORK$4="Змінити обкладинку...";var ACTION_SHOW_LINK_QR$4="Показати посилання QR";var MSG_ASSET_TAB_SETTINGS_DESC$3="Змінити порядок або приховати вкладки, які не використовуються, і встановити стандартну вкладку, яка відкриватиметься під час використання «{ACTION_CHANGE_ARTWORK}»";var LABEL_USAGE_TITLE$4="Нічого не розумієте? Ось короткий посібник";var LABEL_SQUARE_CAPSULES$3="Квадратні капсули";var LABEL_SQUARE_CAPSULES_DESC$2="Використовувати квадратні капсули замість портретних. Квадратні фільтри будуть обрані автоматично.";var LABEL_UNIFORM_RECENT$1="Збіги з останніми обкладинками";var LABEL_UNIFORM_RECENT_DESC$1="Робить так, щоб остання зіграна гра на головному екрані збігалася з рештою обкладинок.";var LABEL_CAPSULE_GLOW$3="Світіння капсули";var LABEL_CAPSULE_GLOW_DESC$2="Налаштування інтенсивності світіння капсули в бібліотеці.";var LABEL_CAPSULE_GLOW_OFF$3="Немає";var LABEL_SETTINGS_ASSET_TABS$3="Налаштування вкладок";var LABEL_SETTINGS_DISABLE_MOTD$2="Вимкнути сповіщення";var LABEL_SETTINGS_DISABLE_MOTD_DESC$1="Сповіщення використовуються рідко, щоб показати важливу інформацію або події в спільноті.";var LABEL_TRANSLATION_CREDIT_TITLE$4="Український переклад";var LABEL_MORE_SGDB_TITLE$4="Більше про SteamGridDB";var ACTION_SGDB_DISCORD$4="Приєднатися до Discord";var ACTION_SGDB_GITHUB$3="Проєкти з відкритим кодом";var ACTION_SGDB_DONATE$4="Підтримати на Patreon";var ACTION_SGDB_TRANSLATE$4="Допомога в перекладі";var ACTION_SGDB_BOOP$4="Перевірити SGDBoop";var LABEL_RESTART_STEAM_TITLE$4="Перезапустити Steam?";var ACTION_RESTART_STEAM_LATER$4="Пізніше";var ACTION_RESTART_STEAM_NOW$4="Перезапустити зараз";var MSG_RESTART_STEAM_DESC$3="Потрібно перезапустити Steam, щоб зміни набули чинності.";var LABEL_GAME_SEARCH_TITLE$4="Пошук гри...";var LABEL_FILTER_MODAL_TITLE$4="Фільтр {assetType}";var LABEL_FILTER_GAME$4="Гра";var LABEL_FILTER_DIMENSIONS$4="Розміри";var LABEL_FILTER_STYLES$4="Стилі";var LABEL_FILTER_FILE_TYPES$4="Типи файлів";var LABEL_FILTER_ANIMATION_TYPE_TITLE$4="Типи";var LABEL_FILTER_TYPE_ANIMATED$3="Анімовані";var LABEL_FILTER_TYPE_STATIC$3="Статичні";var LABEL_FILTER_TAGS_TITLE$4="Позначки";var LABEL_FILTER_TAG_NSFW$4="Вміст для дорослих";var MSG_FILTER_TAG_NSFW_ENABLED$3="Варто швидко перевірити чи немає когось позаду.";var LABEL_FILTER_TAG_HUMOR$3="Гумор";var LABEL_FILTER_TAG_EPILEPSY$3="Епілепсія";var LABEL_FILTER_TAG_UNTAGGED$3="Без позначок";var ACTION_FILTER_RESET$4="Скинути фільтри";var LABEL_BEGGING_MODAL_TITLE$3="Дякуємо за використання SteamGridDB!";var LABEL_BEGGING_MODAL_DESC$2="Будь ласка, розгляньте можливість зробити пожертву, щоби допомогти з підтримкою та витратами на сервер!";var ACTION_HIDE_POS_GUIDES$3="Приховати вказівки";var ACTION_SHOW_OUTLINE$3="Показати вказівки";var ACTION_ADJUST_POS_SIZE$4="Відрегулювати розмір";var ACTION_CHANGE_POS_LOGO_ANCHOR_POINT$1="Змінити точку прив'язки";var LABEL_ASSET_CURRENT$4="Поточний: {assetType}";var ACTION_ASSET_CUSTOM_CLEAR$4="Вилучити користувацький файл";var ACTION_ASSET_BROWSE_LOCAL$3="Перегляд локальних файлів";var ACTION_ASSET_APPLY_TRANSPARENT$3="Використати невидимий файл";var LABEL_NOTES$4="Примітки";var LABEL_ANIMATED$3="Анімований";var LABEL_NSFW$4="Вміст для дорослих";var LABEL_HUMOR$3="Гумор";var LABEL_EPILEPSY$3="Епілепсія";var ACTION_OPEN_FILTER$4="Фільтр";var ACTION_OPEN_OFFICIAL_ASSETS$4="Офіційний ресурс";var ACTION_ASSET_APPLY$3="Застосувати {assetType}";var MSG_GAME_SELECTED$3="Вибрано: {gameName}";var MSG_ASSETS_FILTERED$3="Деякі файли можуть бути приховані через фільтр";var MSG_GAME_SELECTED_AND_ASSETS_FILTERED$3="Вибрано: {gameName}, із фільтром";var TITLE_MOTD_HIDE$2="Приховати сповіщення?";var LABEL_MOTD_THIS$2="Це сповіщення";var LABEL_MOTD_ALL$2="Всі сповіщення";var MSG_ASSET_APPLY_SUCCESS$3="{assetType} успішно застосовано!";var MSG_ASSET_APPLY_ERROR$3="Під час застосування цього файлу виникла проблема.";var ACTION_OPEN_DETAILS$4="Деталі";var uk = {ASSET_TYPE_CAPSULE:ASSET_TYPE_CAPSULE$4,ASSET_TYPE_WIDECAPSULE:ASSET_TYPE_WIDECAPSULE$4,ASSET_TYPE_HERO:ASSET_TYPE_HERO$4,ASSET_TYPE_LOGO:ASSET_TYPE_LOGO$4,ASSET_TYPE_ICON:ASSET_TYPE_ICON$4,LABEL_TAB_CAPSULE:LABEL_TAB_CAPSULE$4,LABEL_TAB_WIDECAPSULE:LABEL_TAB_WIDECAPSULE$4,LABEL_TAB_HERO:LABEL_TAB_HERO$4,LABEL_TAB_LOGO:LABEL_TAB_LOGO$4,LABEL_TAB_ICON:LABEL_TAB_ICON$4,LABEL_TAB_MANAGE:LABEL_TAB_MANAGE$4,MSG_USAGE_INSTRUCTIONS:MSG_USAGE_INSTRUCTIONS$4,ACTION_CHANGE_ARTWORK:ACTION_CHANGE_ARTWORK$4,ACTION_SHOW_LINK_QR:ACTION_SHOW_LINK_QR$4,MSG_ASSET_TAB_SETTINGS_DESC:MSG_ASSET_TAB_SETTINGS_DESC$3,LABEL_USAGE_TITLE:LABEL_USAGE_TITLE$4,LABEL_SQUARE_CAPSULES:LABEL_SQUARE_CAPSULES$3,LABEL_SQUARE_CAPSULES_DESC:LABEL_SQUARE_CAPSULES_DESC$2,LABEL_UNIFORM_RECENT:LABEL_UNIFORM_RECENT$1,LABEL_UNIFORM_RECENT_DESC:LABEL_UNIFORM_RECENT_DESC$1,LABEL_CAPSULE_GLOW:LABEL_CAPSULE_GLOW$3,LABEL_CAPSULE_GLOW_DESC:LABEL_CAPSULE_GLOW_DESC$2,LABEL_CAPSULE_GLOW_OFF:LABEL_CAPSULE_GLOW_OFF$3,LABEL_SETTINGS_ASSET_TABS:LABEL_SETTINGS_ASSET_TABS$3,LABEL_SETTINGS_DISABLE_MOTD:LABEL_SETTINGS_DISABLE_MOTD$2,LABEL_SETTINGS_DISABLE_MOTD_DESC:LABEL_SETTINGS_DISABLE_MOTD_DESC$1,LABEL_TRANSLATION_CREDIT_TITLE:LABEL_TRANSLATION_CREDIT_TITLE$4,LABEL_MORE_SGDB_TITLE:LABEL_MORE_SGDB_TITLE$4,ACTION_SGDB_DISCORD:ACTION_SGDB_DISCORD$4,ACTION_SGDB_GITHUB:ACTION_SGDB_GITHUB$3,ACTION_SGDB_DONATE:ACTION_SGDB_DONATE$4,ACTION_SGDB_TRANSLATE:ACTION_SGDB_TRANSLATE$4,ACTION_SGDB_BOOP:ACTION_SGDB_BOOP$4,LABEL_RESTART_STEAM_TITLE:LABEL_RESTART_STEAM_TITLE$4,ACTION_RESTART_STEAM_LATER:ACTION_RESTART_STEAM_LATER$4,ACTION_RESTART_STEAM_NOW:ACTION_RESTART_STEAM_NOW$4,MSG_RESTART_STEAM_DESC:MSG_RESTART_STEAM_DESC$3,LABEL_GAME_SEARCH_TITLE:LABEL_GAME_SEARCH_TITLE$4,LABEL_FILTER_MODAL_TITLE:LABEL_FILTER_MODAL_TITLE$4,LABEL_FILTER_GAME:LABEL_FILTER_GAME$4,LABEL_FILTER_DIMENSIONS:LABEL_FILTER_DIMENSIONS$4,LABEL_FILTER_STYLES:LABEL_FILTER_STYLES$4,LABEL_FILTER_FILE_TYPES:LABEL_FILTER_FILE_TYPES$4,LABEL_FILTER_ANIMATION_TYPE_TITLE:LABEL_FILTER_ANIMATION_TYPE_TITLE$4,LABEL_FILTER_TYPE_ANIMATED:LABEL_FILTER_TYPE_ANIMATED$3,LABEL_FILTER_TYPE_STATIC:LABEL_FILTER_TYPE_STATIC$3,LABEL_FILTER_TAGS_TITLE:LABEL_FILTER_TAGS_TITLE$4,LABEL_FILTER_TAG_NSFW:LABEL_FILTER_TAG_NSFW$4,MSG_FILTER_TAG_NSFW_ENABLED:MSG_FILTER_TAG_NSFW_ENABLED$3,LABEL_FILTER_TAG_HUMOR:LABEL_FILTER_TAG_HUMOR$3,LABEL_FILTER_TAG_EPILEPSY:LABEL_FILTER_TAG_EPILEPSY$3,LABEL_FILTER_TAG_UNTAGGED:LABEL_FILTER_TAG_UNTAGGED$3,ACTION_FILTER_RESET:ACTION_FILTER_RESET$4,LABEL_BEGGING_MODAL_TITLE:LABEL_BEGGING_MODAL_TITLE$3,LABEL_BEGGING_MODAL_DESC:LABEL_BEGGING_MODAL_DESC$2,ACTION_HIDE_POS_GUIDES:ACTION_HIDE_POS_GUIDES$3,ACTION_SHOW_OUTLINE:ACTION_SHOW_OUTLINE$3,ACTION_ADJUST_POS_SIZE:ACTION_ADJUST_POS_SIZE$4,ACTION_CHANGE_POS_LOGO_ANCHOR_POINT:ACTION_CHANGE_POS_LOGO_ANCHOR_POINT$1,LABEL_ASSET_CURRENT:LABEL_ASSET_CURRENT$4,ACTION_ASSET_CUSTOM_CLEAR:ACTION_ASSET_CUSTOM_CLEAR$4,ACTION_ASSET_BROWSE_LOCAL:ACTION_ASSET_BROWSE_LOCAL$3,ACTION_ASSET_APPLY_TRANSPARENT:ACTION_ASSET_APPLY_TRANSPARENT$3,LABEL_NOTES:LABEL_NOTES$4,LABEL_ANIMATED:LABEL_ANIMATED$3,LABEL_NSFW:LABEL_NSFW$4,LABEL_HUMOR:LABEL_HUMOR$3,LABEL_EPILEPSY:LABEL_EPILEPSY$3,ACTION_OPEN_FILTER:ACTION_OPEN_FILTER$4,ACTION_OPEN_OFFICIAL_ASSETS:ACTION_OPEN_OFFICIAL_ASSETS$4,ACTION_ASSET_APPLY:ACTION_ASSET_APPLY$3,MSG_GAME_SELECTED:MSG_GAME_SELECTED$3,MSG_ASSETS_FILTERED:MSG_ASSETS_FILTERED$3,MSG_GAME_SELECTED_AND_ASSETS_FILTERED:MSG_GAME_SELECTED_AND_ASSETS_FILTERED$3,TITLE_MOTD_HIDE:TITLE_MOTD_HIDE$2,LABEL_MOTD_THIS:LABEL_MOTD_THIS$2,LABEL_MOTD_ALL:LABEL_MOTD_ALL$2,MSG_ASSET_APPLY_SUCCESS:MSG_ASSET_APPLY_SUCCESS$3,MSG_ASSET_APPLY_ERROR:MSG_ASSET_APPLY_ERROR$3,ACTION_OPEN_DETAILS:ACTION_OPEN_DETAILS$4};

var uk$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    ACTION_ADJUST_POS_SIZE: ACTION_ADJUST_POS_SIZE$4,
    ACTION_ASSET_APPLY: ACTION_ASSET_APPLY$3,
    ACTION_ASSET_APPLY_TRANSPARENT: ACTION_ASSET_APPLY_TRANSPARENT$3,
    ACTION_ASSET_BROWSE_LOCAL: ACTION_ASSET_BROWSE_LOCAL$3,
    ACTION_ASSET_CUSTOM_CLEAR: ACTION_ASSET_CUSTOM_CLEAR$4,
    ACTION_CHANGE_ARTWORK: ACTION_CHANGE_ARTWORK$4,
    ACTION_CHANGE_POS_LOGO_ANCHOR_POINT: ACTION_CHANGE_POS_LOGO_ANCHOR_POINT$1,
    ACTION_FILTER_RESET: ACTION_FILTER_RESET$4,
    ACTION_HIDE_POS_GUIDES: ACTION_HIDE_POS_GUIDES$3,
    ACTION_OPEN_DETAILS: ACTION_OPEN_DETAILS$4,
    ACTION_OPEN_FILTER: ACTION_OPEN_FILTER$4,
    ACTION_OPEN_OFFICIAL_ASSETS: ACTION_OPEN_OFFICIAL_ASSETS$4,
    ACTION_RESTART_STEAM_LATER: ACTION_RESTART_STEAM_LATER$4,
    ACTION_RESTART_STEAM_NOW: ACTION_RESTART_STEAM_NOW$4,
    ACTION_SGDB_BOOP: ACTION_SGDB_BOOP$4,
    ACTION_SGDB_DISCORD: ACTION_SGDB_DISCORD$4,
    ACTION_SGDB_DONATE: ACTION_SGDB_DONATE$4,
    ACTION_SGDB_GITHUB: ACTION_SGDB_GITHUB$3,
    ACTION_SGDB_TRANSLATE: ACTION_SGDB_TRANSLATE$4,
    ACTION_SHOW_LINK_QR: ACTION_SHOW_LINK_QR$4,
    ACTION_SHOW_OUTLINE: ACTION_SHOW_OUTLINE$3,
    ASSET_TYPE_CAPSULE: ASSET_TYPE_CAPSULE$4,
    ASSET_TYPE_HERO: ASSET_TYPE_HERO$4,
    ASSET_TYPE_ICON: ASSET_TYPE_ICON$4,
    ASSET_TYPE_LOGO: ASSET_TYPE_LOGO$4,
    ASSET_TYPE_WIDECAPSULE: ASSET_TYPE_WIDECAPSULE$4,
    LABEL_ANIMATED: LABEL_ANIMATED$3,
    LABEL_ASSET_CURRENT: LABEL_ASSET_CURRENT$4,
    LABEL_BEGGING_MODAL_DESC: LABEL_BEGGING_MODAL_DESC$2,
    LABEL_BEGGING_MODAL_TITLE: LABEL_BEGGING_MODAL_TITLE$3,
    LABEL_CAPSULE_GLOW: LABEL_CAPSULE_GLOW$3,
    LABEL_CAPSULE_GLOW_DESC: LABEL_CAPSULE_GLOW_DESC$2,
    LABEL_CAPSULE_GLOW_OFF: LABEL_CAPSULE_GLOW_OFF$3,
    LABEL_EPILEPSY: LABEL_EPILEPSY$3,
    LABEL_FILTER_ANIMATION_TYPE_TITLE: LABEL_FILTER_ANIMATION_TYPE_TITLE$4,
    LABEL_FILTER_DIMENSIONS: LABEL_FILTER_DIMENSIONS$4,
    LABEL_FILTER_FILE_TYPES: LABEL_FILTER_FILE_TYPES$4,
    LABEL_FILTER_GAME: LABEL_FILTER_GAME$4,
    LABEL_FILTER_MODAL_TITLE: LABEL_FILTER_MODAL_TITLE$4,
    LABEL_FILTER_STYLES: LABEL_FILTER_STYLES$4,
    LABEL_FILTER_TAGS_TITLE: LABEL_FILTER_TAGS_TITLE$4,
    LABEL_FILTER_TAG_EPILEPSY: LABEL_FILTER_TAG_EPILEPSY$3,
    LABEL_FILTER_TAG_HUMOR: LABEL_FILTER_TAG_HUMOR$3,
    LABEL_FILTER_TAG_NSFW: LABEL_FILTER_TAG_NSFW$4,
    LABEL_FILTER_TAG_UNTAGGED: LABEL_FILTER_TAG_UNTAGGED$3,
    LABEL_FILTER_TYPE_ANIMATED: LABEL_FILTER_TYPE_ANIMATED$3,
    LABEL_FILTER_TYPE_STATIC: LABEL_FILTER_TYPE_STATIC$3,
    LABEL_GAME_SEARCH_TITLE: LABEL_GAME_SEARCH_TITLE$4,
    LABEL_HUMOR: LABEL_HUMOR$3,
    LABEL_MORE_SGDB_TITLE: LABEL_MORE_SGDB_TITLE$4,
    LABEL_MOTD_ALL: LABEL_MOTD_ALL$2,
    LABEL_MOTD_THIS: LABEL_MOTD_THIS$2,
    LABEL_NOTES: LABEL_NOTES$4,
    LABEL_NSFW: LABEL_NSFW$4,
    LABEL_RESTART_STEAM_TITLE: LABEL_RESTART_STEAM_TITLE$4,
    LABEL_SETTINGS_ASSET_TABS: LABEL_SETTINGS_ASSET_TABS$3,
    LABEL_SETTINGS_DISABLE_MOTD: LABEL_SETTINGS_DISABLE_MOTD$2,
    LABEL_SETTINGS_DISABLE_MOTD_DESC: LABEL_SETTINGS_DISABLE_MOTD_DESC$1,
    LABEL_SQUARE_CAPSULES: LABEL_SQUARE_CAPSULES$3,
    LABEL_SQUARE_CAPSULES_DESC: LABEL_SQUARE_CAPSULES_DESC$2,
    LABEL_TAB_CAPSULE: LABEL_TAB_CAPSULE$4,
    LABEL_TAB_HERO: LABEL_TAB_HERO$4,
    LABEL_TAB_ICON: LABEL_TAB_ICON$4,
    LABEL_TAB_LOGO: LABEL_TAB_LOGO$4,
    LABEL_TAB_MANAGE: LABEL_TAB_MANAGE$4,
    LABEL_TAB_WIDECAPSULE: LABEL_TAB_WIDECAPSULE$4,
    LABEL_TRANSLATION_CREDIT_TITLE: LABEL_TRANSLATION_CREDIT_TITLE$4,
    LABEL_UNIFORM_RECENT: LABEL_UNIFORM_RECENT$1,
    LABEL_UNIFORM_RECENT_DESC: LABEL_UNIFORM_RECENT_DESC$1,
    LABEL_USAGE_TITLE: LABEL_USAGE_TITLE$4,
    MSG_ASSETS_FILTERED: MSG_ASSETS_FILTERED$3,
    MSG_ASSET_APPLY_ERROR: MSG_ASSET_APPLY_ERROR$3,
    MSG_ASSET_APPLY_SUCCESS: MSG_ASSET_APPLY_SUCCESS$3,
    MSG_ASSET_TAB_SETTINGS_DESC: MSG_ASSET_TAB_SETTINGS_DESC$3,
    MSG_FILTER_TAG_NSFW_ENABLED: MSG_FILTER_TAG_NSFW_ENABLED$3,
    MSG_GAME_SELECTED: MSG_GAME_SELECTED$3,
    MSG_GAME_SELECTED_AND_ASSETS_FILTERED: MSG_GAME_SELECTED_AND_ASSETS_FILTERED$3,
    MSG_RESTART_STEAM_DESC: MSG_RESTART_STEAM_DESC$3,
    MSG_USAGE_INSTRUCTIONS: MSG_USAGE_INSTRUCTIONS$4,
    TITLE_MOTD_HIDE: TITLE_MOTD_HIDE$2,
    default: uk
});

var ASSET_TYPE_CAPSULE$3="封面";var ASSET_TYPE_WIDECAPSULE$3="大宣传图";var ASSET_TYPE_HERO$3="库主页图";var ASSET_TYPE_LOGO$3="徽标";var ASSET_TYPE_ICON$3="图标";var LABEL_TAB_CAPSULE$3="封面";var LABEL_TAB_WIDECAPSULE$3="大宣传图";var LABEL_TAB_HERO$3="库主页图";var LABEL_TAB_LOGO$3="徽标";var LABEL_TAB_ICON$3="图标";var LABEL_TAB_MANAGE$3="管理";var MSG_USAGE_INSTRUCTIONS$3="选择一个游戏 {arrow} {optionsButton} {arrow} \"{ACTION_CHANGE_ARTWORK}\"";var ACTION_CHANGE_ARTWORK$3="更改封面...";var ACTION_SHOW_LINK_QR$3="显示二维码";var MSG_ASSET_TAB_SETTINGS_DESC$2="管理资源标签页。当你从一款游戏并从菜单中 \"{ACTION_CHANGE_ARTWORK}\" 时显示的默认标签。";var LABEL_USAGE_TITLE$3="不知道怎么开始？";var LABEL_SQUARE_CAPSULES$2="方形封面";var LABEL_SQUARE_CAPSULES_DESC$1="调整库中的封面显示比例，使用方形比例代替竖版封面。资源图库的方形过滤器将自动被开启。";var LABEL_CAPSULE_GLOW$2="封面特效";var LABEL_CAPSULE_GLOW_DESC$1="调整库中的封面高光效果的强度。";var LABEL_CAPSULE_GLOW_OFF$2="无";var LABEL_SETTINGS_ASSET_TABS$2="管理资源标签";var LABEL_TRANSLATION_CREDIT_TITLE$3="感谢翻译人员";var LABEL_MORE_SGDB_TITLE$3="关于 SteamGridDB";var ACTION_SGDB_DISCORD$3="加入 Discord 社区";var ACTION_SGDB_GITHUB$2="开源项目";var ACTION_SGDB_DONATE$3="在 Patreon 支持我们";var ACTION_SGDB_TRANSLATE$3="帮助翻译";var ACTION_SGDB_BOOP$3="关于 SGDBoop";var LABEL_RESTART_STEAM_TITLE$3="重启Steam？";var ACTION_RESTART_STEAM_LATER$3="稍后再说";var ACTION_RESTART_STEAM_NOW$3="立即重启";var MSG_RESTART_STEAM_DESC$2="Steam 需要重启以使更新生效。";var LABEL_GAME_SEARCH_TITLE$3="搜索游戏...";var LABEL_FILTER_MODAL_TITLE$3="筛选{assetType}";var LABEL_FILTER_GAME$3="游戏";var LABEL_FILTER_DIMENSIONS$3="尺寸";var LABEL_FILTER_STYLES$3="风格";var LABEL_FILTER_FILE_TYPES$3="文件类型";var LABEL_FILTER_ANIMATION_TYPE_TITLE$3="类型";var LABEL_FILTER_TYPE_ANIMATED$2="动画";var LABEL_FILTER_TYPE_STATIC$2="静态";var LABEL_FILTER_TAGS_TITLE$3="标签";var LABEL_FILTER_TAG_NSFW$3="成人内容";var MSG_FILTER_TAG_NSFW_ENABLED$2="小心你的背后！这将会包含不适合在公共场合下访问的内容！";var LABEL_FILTER_TAG_HUMOR$2="幽默";var LABEL_FILTER_TAG_EPILEPSY$2="癫痫";var LABEL_FILTER_TAG_UNTAGGED$2="无标签";var ACTION_FILTER_RESET$3="重置过滤器";var LABEL_BEGGING_MODAL_TITLE$2="感谢您使用SteamGridDB!";var LABEL_BEGGING_MODAL_DESC$1="如果这款工具对你有帮助，可以考虑捐助我们以维持服务器的费用！";var ACTION_HIDE_POS_GUIDES$2="隐藏边框";var ACTION_SHOW_OUTLINE$2="显示边框";var ACTION_ADJUST_POS_SIZE$3="调整尺寸";var LABEL_ASSET_CURRENT$3="当前{assetType}";var ACTION_ASSET_CUSTOM_CLEAR$3="清除自定义资源";var ACTION_ASSET_BROWSE_LOCAL$2="浏览本地文件";var ACTION_ASSET_APPLY_TRANSPARENT$2="设置为不可见";var LABEL_NOTES$3="说明";var LABEL_ANIMATED$2="动画";var LABEL_NSFW$3="成人内容";var LABEL_HUMOR$2="幽默";var LABEL_EPILEPSY$2="癫痫";var ACTION_OPEN_FILTER$3="筛选";var ACTION_OPEN_OFFICIAL_ASSETS$3="官方{assetType}";var ACTION_ASSET_APPLY$2="应用到{assetType}";var MSG_GAME_SELECTED$2="已选择{gameName}";var MSG_ASSETS_FILTERED$2="某些内容可能由于筛选而被隐藏";var MSG_GAME_SELECTED_AND_ASSETS_FILTERED$2="已选择{gameName}(已过滤部分资源)";var MSG_ASSET_APPLY_SUCCESS$2="已成功应用 {assetType} ！";var MSG_ASSET_APPLY_ERROR$2="应用内容时出现问题。";var ACTION_OPEN_DETAILS$3="详情";var zhCn = {ASSET_TYPE_CAPSULE:ASSET_TYPE_CAPSULE$3,ASSET_TYPE_WIDECAPSULE:ASSET_TYPE_WIDECAPSULE$3,ASSET_TYPE_HERO:ASSET_TYPE_HERO$3,ASSET_TYPE_LOGO:ASSET_TYPE_LOGO$3,ASSET_TYPE_ICON:ASSET_TYPE_ICON$3,LABEL_TAB_CAPSULE:LABEL_TAB_CAPSULE$3,LABEL_TAB_WIDECAPSULE:LABEL_TAB_WIDECAPSULE$3,LABEL_TAB_HERO:LABEL_TAB_HERO$3,LABEL_TAB_LOGO:LABEL_TAB_LOGO$3,LABEL_TAB_ICON:LABEL_TAB_ICON$3,LABEL_TAB_MANAGE:LABEL_TAB_MANAGE$3,MSG_USAGE_INSTRUCTIONS:MSG_USAGE_INSTRUCTIONS$3,ACTION_CHANGE_ARTWORK:ACTION_CHANGE_ARTWORK$3,ACTION_SHOW_LINK_QR:ACTION_SHOW_LINK_QR$3,MSG_ASSET_TAB_SETTINGS_DESC:MSG_ASSET_TAB_SETTINGS_DESC$2,LABEL_USAGE_TITLE:LABEL_USAGE_TITLE$3,LABEL_SQUARE_CAPSULES:LABEL_SQUARE_CAPSULES$2,LABEL_SQUARE_CAPSULES_DESC:LABEL_SQUARE_CAPSULES_DESC$1,LABEL_CAPSULE_GLOW:LABEL_CAPSULE_GLOW$2,LABEL_CAPSULE_GLOW_DESC:LABEL_CAPSULE_GLOW_DESC$1,LABEL_CAPSULE_GLOW_OFF:LABEL_CAPSULE_GLOW_OFF$2,LABEL_SETTINGS_ASSET_TABS:LABEL_SETTINGS_ASSET_TABS$2,LABEL_TRANSLATION_CREDIT_TITLE:LABEL_TRANSLATION_CREDIT_TITLE$3,LABEL_MORE_SGDB_TITLE:LABEL_MORE_SGDB_TITLE$3,ACTION_SGDB_DISCORD:ACTION_SGDB_DISCORD$3,ACTION_SGDB_GITHUB:ACTION_SGDB_GITHUB$2,ACTION_SGDB_DONATE:ACTION_SGDB_DONATE$3,ACTION_SGDB_TRANSLATE:ACTION_SGDB_TRANSLATE$3,ACTION_SGDB_BOOP:ACTION_SGDB_BOOP$3,LABEL_RESTART_STEAM_TITLE:LABEL_RESTART_STEAM_TITLE$3,ACTION_RESTART_STEAM_LATER:ACTION_RESTART_STEAM_LATER$3,ACTION_RESTART_STEAM_NOW:ACTION_RESTART_STEAM_NOW$3,MSG_RESTART_STEAM_DESC:MSG_RESTART_STEAM_DESC$2,LABEL_GAME_SEARCH_TITLE:LABEL_GAME_SEARCH_TITLE$3,LABEL_FILTER_MODAL_TITLE:LABEL_FILTER_MODAL_TITLE$3,LABEL_FILTER_GAME:LABEL_FILTER_GAME$3,LABEL_FILTER_DIMENSIONS:LABEL_FILTER_DIMENSIONS$3,LABEL_FILTER_STYLES:LABEL_FILTER_STYLES$3,LABEL_FILTER_FILE_TYPES:LABEL_FILTER_FILE_TYPES$3,LABEL_FILTER_ANIMATION_TYPE_TITLE:LABEL_FILTER_ANIMATION_TYPE_TITLE$3,LABEL_FILTER_TYPE_ANIMATED:LABEL_FILTER_TYPE_ANIMATED$2,LABEL_FILTER_TYPE_STATIC:LABEL_FILTER_TYPE_STATIC$2,LABEL_FILTER_TAGS_TITLE:LABEL_FILTER_TAGS_TITLE$3,LABEL_FILTER_TAG_NSFW:LABEL_FILTER_TAG_NSFW$3,MSG_FILTER_TAG_NSFW_ENABLED:MSG_FILTER_TAG_NSFW_ENABLED$2,LABEL_FILTER_TAG_HUMOR:LABEL_FILTER_TAG_HUMOR$2,LABEL_FILTER_TAG_EPILEPSY:LABEL_FILTER_TAG_EPILEPSY$2,LABEL_FILTER_TAG_UNTAGGED:LABEL_FILTER_TAG_UNTAGGED$2,ACTION_FILTER_RESET:ACTION_FILTER_RESET$3,LABEL_BEGGING_MODAL_TITLE:LABEL_BEGGING_MODAL_TITLE$2,LABEL_BEGGING_MODAL_DESC:LABEL_BEGGING_MODAL_DESC$1,ACTION_HIDE_POS_GUIDES:ACTION_HIDE_POS_GUIDES$2,ACTION_SHOW_OUTLINE:ACTION_SHOW_OUTLINE$2,ACTION_ADJUST_POS_SIZE:ACTION_ADJUST_POS_SIZE$3,LABEL_ASSET_CURRENT:LABEL_ASSET_CURRENT$3,ACTION_ASSET_CUSTOM_CLEAR:ACTION_ASSET_CUSTOM_CLEAR$3,ACTION_ASSET_BROWSE_LOCAL:ACTION_ASSET_BROWSE_LOCAL$2,ACTION_ASSET_APPLY_TRANSPARENT:ACTION_ASSET_APPLY_TRANSPARENT$2,LABEL_NOTES:LABEL_NOTES$3,LABEL_ANIMATED:LABEL_ANIMATED$2,LABEL_NSFW:LABEL_NSFW$3,LABEL_HUMOR:LABEL_HUMOR$2,LABEL_EPILEPSY:LABEL_EPILEPSY$2,ACTION_OPEN_FILTER:ACTION_OPEN_FILTER$3,ACTION_OPEN_OFFICIAL_ASSETS:ACTION_OPEN_OFFICIAL_ASSETS$3,ACTION_ASSET_APPLY:ACTION_ASSET_APPLY$2,MSG_GAME_SELECTED:MSG_GAME_SELECTED$2,MSG_ASSETS_FILTERED:MSG_ASSETS_FILTERED$2,MSG_GAME_SELECTED_AND_ASSETS_FILTERED:MSG_GAME_SELECTED_AND_ASSETS_FILTERED$2,MSG_ASSET_APPLY_SUCCESS:MSG_ASSET_APPLY_SUCCESS$2,MSG_ASSET_APPLY_ERROR:MSG_ASSET_APPLY_ERROR$2,ACTION_OPEN_DETAILS:ACTION_OPEN_DETAILS$3};

var zhCn$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    ACTION_ADJUST_POS_SIZE: ACTION_ADJUST_POS_SIZE$3,
    ACTION_ASSET_APPLY: ACTION_ASSET_APPLY$2,
    ACTION_ASSET_APPLY_TRANSPARENT: ACTION_ASSET_APPLY_TRANSPARENT$2,
    ACTION_ASSET_BROWSE_LOCAL: ACTION_ASSET_BROWSE_LOCAL$2,
    ACTION_ASSET_CUSTOM_CLEAR: ACTION_ASSET_CUSTOM_CLEAR$3,
    ACTION_CHANGE_ARTWORK: ACTION_CHANGE_ARTWORK$3,
    ACTION_FILTER_RESET: ACTION_FILTER_RESET$3,
    ACTION_HIDE_POS_GUIDES: ACTION_HIDE_POS_GUIDES$2,
    ACTION_OPEN_DETAILS: ACTION_OPEN_DETAILS$3,
    ACTION_OPEN_FILTER: ACTION_OPEN_FILTER$3,
    ACTION_OPEN_OFFICIAL_ASSETS: ACTION_OPEN_OFFICIAL_ASSETS$3,
    ACTION_RESTART_STEAM_LATER: ACTION_RESTART_STEAM_LATER$3,
    ACTION_RESTART_STEAM_NOW: ACTION_RESTART_STEAM_NOW$3,
    ACTION_SGDB_BOOP: ACTION_SGDB_BOOP$3,
    ACTION_SGDB_DISCORD: ACTION_SGDB_DISCORD$3,
    ACTION_SGDB_DONATE: ACTION_SGDB_DONATE$3,
    ACTION_SGDB_GITHUB: ACTION_SGDB_GITHUB$2,
    ACTION_SGDB_TRANSLATE: ACTION_SGDB_TRANSLATE$3,
    ACTION_SHOW_LINK_QR: ACTION_SHOW_LINK_QR$3,
    ACTION_SHOW_OUTLINE: ACTION_SHOW_OUTLINE$2,
    ASSET_TYPE_CAPSULE: ASSET_TYPE_CAPSULE$3,
    ASSET_TYPE_HERO: ASSET_TYPE_HERO$3,
    ASSET_TYPE_ICON: ASSET_TYPE_ICON$3,
    ASSET_TYPE_LOGO: ASSET_TYPE_LOGO$3,
    ASSET_TYPE_WIDECAPSULE: ASSET_TYPE_WIDECAPSULE$3,
    LABEL_ANIMATED: LABEL_ANIMATED$2,
    LABEL_ASSET_CURRENT: LABEL_ASSET_CURRENT$3,
    LABEL_BEGGING_MODAL_DESC: LABEL_BEGGING_MODAL_DESC$1,
    LABEL_BEGGING_MODAL_TITLE: LABEL_BEGGING_MODAL_TITLE$2,
    LABEL_CAPSULE_GLOW: LABEL_CAPSULE_GLOW$2,
    LABEL_CAPSULE_GLOW_DESC: LABEL_CAPSULE_GLOW_DESC$1,
    LABEL_CAPSULE_GLOW_OFF: LABEL_CAPSULE_GLOW_OFF$2,
    LABEL_EPILEPSY: LABEL_EPILEPSY$2,
    LABEL_FILTER_ANIMATION_TYPE_TITLE: LABEL_FILTER_ANIMATION_TYPE_TITLE$3,
    LABEL_FILTER_DIMENSIONS: LABEL_FILTER_DIMENSIONS$3,
    LABEL_FILTER_FILE_TYPES: LABEL_FILTER_FILE_TYPES$3,
    LABEL_FILTER_GAME: LABEL_FILTER_GAME$3,
    LABEL_FILTER_MODAL_TITLE: LABEL_FILTER_MODAL_TITLE$3,
    LABEL_FILTER_STYLES: LABEL_FILTER_STYLES$3,
    LABEL_FILTER_TAGS_TITLE: LABEL_FILTER_TAGS_TITLE$3,
    LABEL_FILTER_TAG_EPILEPSY: LABEL_FILTER_TAG_EPILEPSY$2,
    LABEL_FILTER_TAG_HUMOR: LABEL_FILTER_TAG_HUMOR$2,
    LABEL_FILTER_TAG_NSFW: LABEL_FILTER_TAG_NSFW$3,
    LABEL_FILTER_TAG_UNTAGGED: LABEL_FILTER_TAG_UNTAGGED$2,
    LABEL_FILTER_TYPE_ANIMATED: LABEL_FILTER_TYPE_ANIMATED$2,
    LABEL_FILTER_TYPE_STATIC: LABEL_FILTER_TYPE_STATIC$2,
    LABEL_GAME_SEARCH_TITLE: LABEL_GAME_SEARCH_TITLE$3,
    LABEL_HUMOR: LABEL_HUMOR$2,
    LABEL_MORE_SGDB_TITLE: LABEL_MORE_SGDB_TITLE$3,
    LABEL_NOTES: LABEL_NOTES$3,
    LABEL_NSFW: LABEL_NSFW$3,
    LABEL_RESTART_STEAM_TITLE: LABEL_RESTART_STEAM_TITLE$3,
    LABEL_SETTINGS_ASSET_TABS: LABEL_SETTINGS_ASSET_TABS$2,
    LABEL_SQUARE_CAPSULES: LABEL_SQUARE_CAPSULES$2,
    LABEL_SQUARE_CAPSULES_DESC: LABEL_SQUARE_CAPSULES_DESC$1,
    LABEL_TAB_CAPSULE: LABEL_TAB_CAPSULE$3,
    LABEL_TAB_HERO: LABEL_TAB_HERO$3,
    LABEL_TAB_ICON: LABEL_TAB_ICON$3,
    LABEL_TAB_LOGO: LABEL_TAB_LOGO$3,
    LABEL_TAB_MANAGE: LABEL_TAB_MANAGE$3,
    LABEL_TAB_WIDECAPSULE: LABEL_TAB_WIDECAPSULE$3,
    LABEL_TRANSLATION_CREDIT_TITLE: LABEL_TRANSLATION_CREDIT_TITLE$3,
    LABEL_USAGE_TITLE: LABEL_USAGE_TITLE$3,
    MSG_ASSETS_FILTERED: MSG_ASSETS_FILTERED$2,
    MSG_ASSET_APPLY_ERROR: MSG_ASSET_APPLY_ERROR$2,
    MSG_ASSET_APPLY_SUCCESS: MSG_ASSET_APPLY_SUCCESS$2,
    MSG_ASSET_TAB_SETTINGS_DESC: MSG_ASSET_TAB_SETTINGS_DESC$2,
    MSG_FILTER_TAG_NSFW_ENABLED: MSG_FILTER_TAG_NSFW_ENABLED$2,
    MSG_GAME_SELECTED: MSG_GAME_SELECTED$2,
    MSG_GAME_SELECTED_AND_ASSETS_FILTERED: MSG_GAME_SELECTED_AND_ASSETS_FILTERED$2,
    MSG_RESTART_STEAM_DESC: MSG_RESTART_STEAM_DESC$2,
    MSG_USAGE_INSTRUCTIONS: MSG_USAGE_INSTRUCTIONS$3,
    default: zhCn
});

var ASSET_TYPE_CAPSULE$2="宣傳圖";var ASSET_TYPE_WIDECAPSULE$2="大宣傳圖";var ASSET_TYPE_HERO$2="主頁橫幅";var ASSET_TYPE_LOGO$2="標誌";var ASSET_TYPE_ICON$2="小圖標";var LABEL_TAB_CAPSULE$2="宣傳圖";var LABEL_TAB_WIDECAPSULE$2="大宣傳圖";var LABEL_TAB_HERO$2="主頁橫幅";var LABEL_TAB_LOGO$2="標誌";var LABEL_TAB_ICON$2="小圖標";var LABEL_TAB_MANAGE$2="管理";var MSG_USAGE_INSTRUCTIONS$2="選擇一個遊戲 {arrow} {optionsButton} {arrow} \"{ACTION_CHANGE_ARTWORK}\"";var ACTION_CHANGE_ARTWORK$2="更改遊戲圖片...";var ACTION_SHOW_LINK_QR$2="顯示 QR Code";var MSG_ASSET_TAB_SETTINGS_DESC$1="重新排序或隱藏無用的分頁，並設定使用「{ACTION_CHANGE_ARTWORK}」時開啟的預設分頁";var LABEL_USAGE_TITLE$2="不知道如何使用？";var LABEL_SETTINGS_ASSET_TABS$1="素材分頁設定";var LABEL_TRANSLATION_CREDIT_TITLE$2="正體中文翻譯";var LABEL_MORE_SGDB_TITLE$2="關於 SteamGridDB";var ACTION_SGDB_DISCORD$2="加入 Discord";var ACTION_SGDB_GITHUB$1="開源專案";var ACTION_SGDB_DONATE$2="在 Patreon 上支持我們";var ACTION_SGDB_TRANSLATE$2="幫助翻譯";var ACTION_SGDB_BOOP$2="查看 SGDBoop";var LABEL_RESTART_STEAM_TITLE$2="重新啟動 Steam？";var ACTION_RESTART_STEAM_LATER$2="稍後再說";var ACTION_RESTART_STEAM_NOW$2="立刻重新啟動";var MSG_RESTART_STEAM_DESC$1="需要現在重新啟動 Steam 才能使改動生效。";var LABEL_GAME_SEARCH_TITLE$2="搜尋遊戲...";var LABEL_FILTER_MODAL_TITLE$2="{assetType} 篩選器";var LABEL_FILTER_GAME$2="遊戲";var LABEL_FILTER_DIMENSIONS$2="尺寸";var LABEL_FILTER_STYLES$2="風格";var LABEL_FILTER_FILE_TYPES$2="檔案格式";var LABEL_FILTER_ANIMATION_TYPE_TITLE$2="類型";var LABEL_FILTER_TYPE_ANIMATED$1="動畫";var LABEL_FILTER_TYPE_STATIC$1="靜態";var LABEL_FILTER_TAGS_TITLE$2="標籤";var LABEL_FILTER_TAG_NSFW$2="成人內容";var MSG_FILTER_TAG_NSFW_ENABLED$1="小心背後有人";var LABEL_FILTER_TAG_HUMOR$1="幽默";var LABEL_FILTER_TAG_EPILEPSY$1="癲癇";var LABEL_FILTER_TAG_UNTAGGED$1="未標籤";var ACTION_FILTER_RESET$2="重設篩選器";var ACTION_HIDE_POS_GUIDES$1="隱藏指引";var ACTION_SHOW_OUTLINE$1="顯示指引";var ACTION_ADJUST_POS_SIZE$2="調整大小";var LABEL_ASSET_CURRENT$2="當前 {assetType}";var ACTION_ASSET_CUSTOM_CLEAR$2="清除自定義素材";var ACTION_ASSET_BROWSE_LOCAL$1="瀏覽本地檔案";var ACTION_ASSET_APPLY_TRANSPARENT$1="使用隱形素材";var LABEL_NOTES$2="說明";var LABEL_ANIMATED$1="動畫";var LABEL_NSFW$2="成人內容";var LABEL_HUMOR$1="幽默";var LABEL_EPILEPSY$1="癲癇";var ACTION_OPEN_FILTER$2="篩選";var ACTION_OPEN_OFFICIAL_ASSETS$2="官方的 {assetType}";var ACTION_ASSET_APPLY$1="套用 {assetType}";var MSG_GAME_SELECTED$1="已選擇 {gameName}";var MSG_ASSETS_FILTERED$1="篩選器可能隱藏某些素材";var MSG_GAME_SELECTED_AND_ASSETS_FILTERED$1="已選擇 {gameName} 與篩選器";var MSG_ASSET_APPLY_SUCCESS$1="成功套用 {assetType}！";var MSG_ASSET_APPLY_ERROR$1="套用素材時出現問題。";var ACTION_OPEN_DETAILS$2="查看更多";var zhTw = {ASSET_TYPE_CAPSULE:ASSET_TYPE_CAPSULE$2,ASSET_TYPE_WIDECAPSULE:ASSET_TYPE_WIDECAPSULE$2,ASSET_TYPE_HERO:ASSET_TYPE_HERO$2,ASSET_TYPE_LOGO:ASSET_TYPE_LOGO$2,ASSET_TYPE_ICON:ASSET_TYPE_ICON$2,LABEL_TAB_CAPSULE:LABEL_TAB_CAPSULE$2,LABEL_TAB_WIDECAPSULE:LABEL_TAB_WIDECAPSULE$2,LABEL_TAB_HERO:LABEL_TAB_HERO$2,LABEL_TAB_LOGO:LABEL_TAB_LOGO$2,LABEL_TAB_ICON:LABEL_TAB_ICON$2,LABEL_TAB_MANAGE:LABEL_TAB_MANAGE$2,MSG_USAGE_INSTRUCTIONS:MSG_USAGE_INSTRUCTIONS$2,ACTION_CHANGE_ARTWORK:ACTION_CHANGE_ARTWORK$2,ACTION_SHOW_LINK_QR:ACTION_SHOW_LINK_QR$2,MSG_ASSET_TAB_SETTINGS_DESC:MSG_ASSET_TAB_SETTINGS_DESC$1,LABEL_USAGE_TITLE:LABEL_USAGE_TITLE$2,LABEL_SETTINGS_ASSET_TABS:LABEL_SETTINGS_ASSET_TABS$1,LABEL_TRANSLATION_CREDIT_TITLE:LABEL_TRANSLATION_CREDIT_TITLE$2,LABEL_MORE_SGDB_TITLE:LABEL_MORE_SGDB_TITLE$2,ACTION_SGDB_DISCORD:ACTION_SGDB_DISCORD$2,ACTION_SGDB_GITHUB:ACTION_SGDB_GITHUB$1,ACTION_SGDB_DONATE:ACTION_SGDB_DONATE$2,ACTION_SGDB_TRANSLATE:ACTION_SGDB_TRANSLATE$2,ACTION_SGDB_BOOP:ACTION_SGDB_BOOP$2,LABEL_RESTART_STEAM_TITLE:LABEL_RESTART_STEAM_TITLE$2,ACTION_RESTART_STEAM_LATER:ACTION_RESTART_STEAM_LATER$2,ACTION_RESTART_STEAM_NOW:ACTION_RESTART_STEAM_NOW$2,MSG_RESTART_STEAM_DESC:MSG_RESTART_STEAM_DESC$1,LABEL_GAME_SEARCH_TITLE:LABEL_GAME_SEARCH_TITLE$2,LABEL_FILTER_MODAL_TITLE:LABEL_FILTER_MODAL_TITLE$2,LABEL_FILTER_GAME:LABEL_FILTER_GAME$2,LABEL_FILTER_DIMENSIONS:LABEL_FILTER_DIMENSIONS$2,LABEL_FILTER_STYLES:LABEL_FILTER_STYLES$2,LABEL_FILTER_FILE_TYPES:LABEL_FILTER_FILE_TYPES$2,LABEL_FILTER_ANIMATION_TYPE_TITLE:LABEL_FILTER_ANIMATION_TYPE_TITLE$2,LABEL_FILTER_TYPE_ANIMATED:LABEL_FILTER_TYPE_ANIMATED$1,LABEL_FILTER_TYPE_STATIC:LABEL_FILTER_TYPE_STATIC$1,LABEL_FILTER_TAGS_TITLE:LABEL_FILTER_TAGS_TITLE$2,LABEL_FILTER_TAG_NSFW:LABEL_FILTER_TAG_NSFW$2,MSG_FILTER_TAG_NSFW_ENABLED:MSG_FILTER_TAG_NSFW_ENABLED$1,LABEL_FILTER_TAG_HUMOR:LABEL_FILTER_TAG_HUMOR$1,LABEL_FILTER_TAG_EPILEPSY:LABEL_FILTER_TAG_EPILEPSY$1,LABEL_FILTER_TAG_UNTAGGED:LABEL_FILTER_TAG_UNTAGGED$1,ACTION_FILTER_RESET:ACTION_FILTER_RESET$2,ACTION_HIDE_POS_GUIDES:ACTION_HIDE_POS_GUIDES$1,ACTION_SHOW_OUTLINE:ACTION_SHOW_OUTLINE$1,ACTION_ADJUST_POS_SIZE:ACTION_ADJUST_POS_SIZE$2,LABEL_ASSET_CURRENT:LABEL_ASSET_CURRENT$2,ACTION_ASSET_CUSTOM_CLEAR:ACTION_ASSET_CUSTOM_CLEAR$2,ACTION_ASSET_BROWSE_LOCAL:ACTION_ASSET_BROWSE_LOCAL$1,ACTION_ASSET_APPLY_TRANSPARENT:ACTION_ASSET_APPLY_TRANSPARENT$1,LABEL_NOTES:LABEL_NOTES$2,LABEL_ANIMATED:LABEL_ANIMATED$1,LABEL_NSFW:LABEL_NSFW$2,LABEL_HUMOR:LABEL_HUMOR$1,LABEL_EPILEPSY:LABEL_EPILEPSY$1,ACTION_OPEN_FILTER:ACTION_OPEN_FILTER$2,ACTION_OPEN_OFFICIAL_ASSETS:ACTION_OPEN_OFFICIAL_ASSETS$2,ACTION_ASSET_APPLY:ACTION_ASSET_APPLY$1,MSG_GAME_SELECTED:MSG_GAME_SELECTED$1,MSG_ASSETS_FILTERED:MSG_ASSETS_FILTERED$1,MSG_GAME_SELECTED_AND_ASSETS_FILTERED:MSG_GAME_SELECTED_AND_ASSETS_FILTERED$1,MSG_ASSET_APPLY_SUCCESS:MSG_ASSET_APPLY_SUCCESS$1,MSG_ASSET_APPLY_ERROR:MSG_ASSET_APPLY_ERROR$1,ACTION_OPEN_DETAILS:ACTION_OPEN_DETAILS$2};

var zhTw$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    ACTION_ADJUST_POS_SIZE: ACTION_ADJUST_POS_SIZE$2,
    ACTION_ASSET_APPLY: ACTION_ASSET_APPLY$1,
    ACTION_ASSET_APPLY_TRANSPARENT: ACTION_ASSET_APPLY_TRANSPARENT$1,
    ACTION_ASSET_BROWSE_LOCAL: ACTION_ASSET_BROWSE_LOCAL$1,
    ACTION_ASSET_CUSTOM_CLEAR: ACTION_ASSET_CUSTOM_CLEAR$2,
    ACTION_CHANGE_ARTWORK: ACTION_CHANGE_ARTWORK$2,
    ACTION_FILTER_RESET: ACTION_FILTER_RESET$2,
    ACTION_HIDE_POS_GUIDES: ACTION_HIDE_POS_GUIDES$1,
    ACTION_OPEN_DETAILS: ACTION_OPEN_DETAILS$2,
    ACTION_OPEN_FILTER: ACTION_OPEN_FILTER$2,
    ACTION_OPEN_OFFICIAL_ASSETS: ACTION_OPEN_OFFICIAL_ASSETS$2,
    ACTION_RESTART_STEAM_LATER: ACTION_RESTART_STEAM_LATER$2,
    ACTION_RESTART_STEAM_NOW: ACTION_RESTART_STEAM_NOW$2,
    ACTION_SGDB_BOOP: ACTION_SGDB_BOOP$2,
    ACTION_SGDB_DISCORD: ACTION_SGDB_DISCORD$2,
    ACTION_SGDB_DONATE: ACTION_SGDB_DONATE$2,
    ACTION_SGDB_GITHUB: ACTION_SGDB_GITHUB$1,
    ACTION_SGDB_TRANSLATE: ACTION_SGDB_TRANSLATE$2,
    ACTION_SHOW_LINK_QR: ACTION_SHOW_LINK_QR$2,
    ACTION_SHOW_OUTLINE: ACTION_SHOW_OUTLINE$1,
    ASSET_TYPE_CAPSULE: ASSET_TYPE_CAPSULE$2,
    ASSET_TYPE_HERO: ASSET_TYPE_HERO$2,
    ASSET_TYPE_ICON: ASSET_TYPE_ICON$2,
    ASSET_TYPE_LOGO: ASSET_TYPE_LOGO$2,
    ASSET_TYPE_WIDECAPSULE: ASSET_TYPE_WIDECAPSULE$2,
    LABEL_ANIMATED: LABEL_ANIMATED$1,
    LABEL_ASSET_CURRENT: LABEL_ASSET_CURRENT$2,
    LABEL_EPILEPSY: LABEL_EPILEPSY$1,
    LABEL_FILTER_ANIMATION_TYPE_TITLE: LABEL_FILTER_ANIMATION_TYPE_TITLE$2,
    LABEL_FILTER_DIMENSIONS: LABEL_FILTER_DIMENSIONS$2,
    LABEL_FILTER_FILE_TYPES: LABEL_FILTER_FILE_TYPES$2,
    LABEL_FILTER_GAME: LABEL_FILTER_GAME$2,
    LABEL_FILTER_MODAL_TITLE: LABEL_FILTER_MODAL_TITLE$2,
    LABEL_FILTER_STYLES: LABEL_FILTER_STYLES$2,
    LABEL_FILTER_TAGS_TITLE: LABEL_FILTER_TAGS_TITLE$2,
    LABEL_FILTER_TAG_EPILEPSY: LABEL_FILTER_TAG_EPILEPSY$1,
    LABEL_FILTER_TAG_HUMOR: LABEL_FILTER_TAG_HUMOR$1,
    LABEL_FILTER_TAG_NSFW: LABEL_FILTER_TAG_NSFW$2,
    LABEL_FILTER_TAG_UNTAGGED: LABEL_FILTER_TAG_UNTAGGED$1,
    LABEL_FILTER_TYPE_ANIMATED: LABEL_FILTER_TYPE_ANIMATED$1,
    LABEL_FILTER_TYPE_STATIC: LABEL_FILTER_TYPE_STATIC$1,
    LABEL_GAME_SEARCH_TITLE: LABEL_GAME_SEARCH_TITLE$2,
    LABEL_HUMOR: LABEL_HUMOR$1,
    LABEL_MORE_SGDB_TITLE: LABEL_MORE_SGDB_TITLE$2,
    LABEL_NOTES: LABEL_NOTES$2,
    LABEL_NSFW: LABEL_NSFW$2,
    LABEL_RESTART_STEAM_TITLE: LABEL_RESTART_STEAM_TITLE$2,
    LABEL_SETTINGS_ASSET_TABS: LABEL_SETTINGS_ASSET_TABS$1,
    LABEL_TAB_CAPSULE: LABEL_TAB_CAPSULE$2,
    LABEL_TAB_HERO: LABEL_TAB_HERO$2,
    LABEL_TAB_ICON: LABEL_TAB_ICON$2,
    LABEL_TAB_LOGO: LABEL_TAB_LOGO$2,
    LABEL_TAB_MANAGE: LABEL_TAB_MANAGE$2,
    LABEL_TAB_WIDECAPSULE: LABEL_TAB_WIDECAPSULE$2,
    LABEL_TRANSLATION_CREDIT_TITLE: LABEL_TRANSLATION_CREDIT_TITLE$2,
    LABEL_USAGE_TITLE: LABEL_USAGE_TITLE$2,
    MSG_ASSETS_FILTERED: MSG_ASSETS_FILTERED$1,
    MSG_ASSET_APPLY_ERROR: MSG_ASSET_APPLY_ERROR$1,
    MSG_ASSET_APPLY_SUCCESS: MSG_ASSET_APPLY_SUCCESS$1,
    MSG_ASSET_TAB_SETTINGS_DESC: MSG_ASSET_TAB_SETTINGS_DESC$1,
    MSG_FILTER_TAG_NSFW_ENABLED: MSG_FILTER_TAG_NSFW_ENABLED$1,
    MSG_GAME_SELECTED: MSG_GAME_SELECTED$1,
    MSG_GAME_SELECTED_AND_ASSETS_FILTERED: MSG_GAME_SELECTED_AND_ASSETS_FILTERED$1,
    MSG_RESTART_STEAM_DESC: MSG_RESTART_STEAM_DESC$1,
    MSG_USAGE_INSTRUCTIONS: MSG_USAGE_INSTRUCTIONS$2,
    default: zhTw
});

var ASSET_TYPE_CAPSULE$1="Kapsel";var ASSET_TYPE_WIDECAPSULE$1="Bred kapsel";var ASSET_TYPE_HERO$1="Banner";var ASSET_TYPE_LOGO$1="Logo";var ASSET_TYPE_ICON$1="Ikon";var LABEL_TAB_CAPSULE$1="Kapsel";var LABEL_TAB_WIDECAPSULE$1="Bred kapsel";var LABEL_TAB_HERO$1="Banner";var LABEL_TAB_LOGO$1="Logo";var LABEL_TAB_ICON$1="Ikon";var LABEL_TAB_MANAGE$1="Administrer";var MSG_USAGE_INSTRUCTIONS$1="Velg et spill {arrow} {optionsButton} {arrow} \"{ACTION_CHANGE_ARTWORK}\"";var ACTION_CHANGE_ARTWORK$1="Endre grafikk ...";var ACTION_SHOW_LINK_QR$1="Vis QR-kodelenke";var MSG_ASSET_TAB_SETTINGS_DESC="Omorganiser eller skjul ubrukte faner, og velg standardfanen som åpnes når du bruker \"{ACTION_CHANGE_ARTWORK}\"";var LABEL_USAGE_TITLE$1="Hurtig brukerveiledning";var LABEL_SQUARE_CAPSULES$1="Kvadratiske kapsler";var LABEL_SQUARE_CAPSULES_DESC="Bruk kvadratiske kapsler istedenfor kapsler i portrettformat. Kvadratiske filtre vil velges automatisk.";var LABEL_UNIFORM_RECENT="Lik \"nylig spilt\"-kapsel";var LABEL_UNIFORM_RECENT_DESC="Vis kapselen til det nyligst spilte spillet på startskjermen likt som de andre.";var LABEL_CAPSULE_GLOW$1="Kapselglød";var LABEL_CAPSULE_GLOW_DESC="Juster intensiteten på kapselgløden i biblioteket.";var LABEL_CAPSULE_GLOW_OFF$1="Ingen";var LABEL_SETTINGS_ASSET_TABS="Innstillinger for grafikkfanen";var LABEL_SETTINGS_DISABLE_MOTD$1="Slå av kunngjøringer";var LABEL_SETTINGS_DISABLE_MOTD_DESC="Kunngjøringer brukes sparsomt til å vise viktig informasjon eller fellesskaparrangementer.";var LABEL_TRANSLATION_CREDIT_TITLE$1="Norsk oversettelse";var LABEL_MORE_SGDB_TITLE$1="Mer rundt SteamGridDB";var ACTION_SGDB_DISCORD$1="Bli med i Discord-serveren";var ACTION_SGDB_GITHUB="Åpen kildekode-prosjekter";var ACTION_SGDB_DONATE$1="Støtt oss på Patreon";var ACTION_SGDB_TRANSLATE$1="Hjelp med å oversette";var ACTION_SGDB_BOOP$1="Sjekk ut SGDBoop";var LABEL_RESTART_STEAM_TITLE$1="Start Steam på nytt?";var ACTION_RESTART_STEAM_LATER$1="Senere";var ACTION_RESTART_STEAM_NOW$1="Start på nytt nå";var MSG_RESTART_STEAM_DESC="Steam må startes på nytt for å iverksette endringene.";var LABEL_GAME_SEARCH_TITLE$1="Søk etter et spill...";var LABEL_FILTER_MODAL_TITLE$1="{assetType}-filter";var LABEL_FILTER_GAME$1="Spill";var LABEL_FILTER_DIMENSIONS$1="Størrelser";var LABEL_FILTER_STYLES$1="Stiler";var LABEL_FILTER_FILE_TYPES$1="Filtyper";var LABEL_FILTER_ANIMATION_TYPE_TITLE$1="Typer";var LABEL_FILTER_TYPE_ANIMATED="Animert";var LABEL_FILTER_TYPE_STATIC="Statisk";var LABEL_FILTER_TAGS_TITLE$1="Søkeord";var LABEL_FILTER_TAG_NSFW$1="Voksent innhold";var MSG_FILTER_TAG_NSFW_ENABLED="Se deg om før du fyrer løs.";var LABEL_FILTER_TAG_HUMOR="Humor";var LABEL_FILTER_TAG_EPILEPSY="Epilepsi";var LABEL_FILTER_TAG_UNTAGGED="Umerket";var ACTION_FILTER_RESET$1="Tilbakestill filtre";var LABEL_BEGGING_MODAL_TITLE$1="Takk for at du bruker SteamGridDB!";var LABEL_BEGGING_MODAL_DESC="Vurder gjerne å donere for å hjelpe oss med vedlikeholds- og serverkostnader!";var ACTION_HIDE_POS_GUIDES="Skjul hjelpeomriss";var ACTION_SHOW_OUTLINE="Vis hjelpeomriss";var ACTION_ADJUST_POS_SIZE$1="Juster størrelse";var ACTION_CHANGE_POS_LOGO_ANCHOR_POINT="Endre ankerpunkt";var LABEL_ASSET_CURRENT$1="Nåværende {assetType}";var ACTION_ASSET_CUSTOM_CLEAR$1="Fjern egendefinert grafikk";var ACTION_ASSET_BROWSE_LOCAL="Bla gjennom lokale filer";var ACTION_ASSET_APPLY_TRANSPARENT="Bruk usynlig grafikk";var LABEL_NOTES$1="Merknader";var LABEL_ANIMATED="Animert";var LABEL_NSFW$1="Voksent innhold";var LABEL_HUMOR="Humor";var LABEL_EPILEPSY="Epilepsi";var ACTION_OPEN_FILTER$1="Filter";var ACTION_OPEN_OFFICIAL_ASSETS$1="Offisiell grafikk";var ACTION_ASSET_APPLY="Bruk {assetType}";var MSG_GAME_SELECTED="Valgt {gameName}";var MSG_ASSETS_FILTERED="Visse grafikker kan være skjult på grunn av filter";var MSG_GAME_SELECTED_AND_ASSETS_FILTERED="Valgt {gameName} med filter";var TITLE_MOTD_HIDE$1="Skjule kunngjøring?";var LABEL_MOTD_THIS$1="Denne kunngjøringen";var LABEL_MOTD_ALL$1="Alle kunngjøringer";var MSG_ASSET_APPLY_SUCCESS="{assetType} har blitt tatt i bruk!";var MSG_ASSET_APPLY_ERROR="Det oppsto et problem med å ta i bruk denne grafikken.";var ACTION_OPEN_DETAILS$1="Detaljer";var no = {ASSET_TYPE_CAPSULE:ASSET_TYPE_CAPSULE$1,ASSET_TYPE_WIDECAPSULE:ASSET_TYPE_WIDECAPSULE$1,ASSET_TYPE_HERO:ASSET_TYPE_HERO$1,ASSET_TYPE_LOGO:ASSET_TYPE_LOGO$1,ASSET_TYPE_ICON:ASSET_TYPE_ICON$1,LABEL_TAB_CAPSULE:LABEL_TAB_CAPSULE$1,LABEL_TAB_WIDECAPSULE:LABEL_TAB_WIDECAPSULE$1,LABEL_TAB_HERO:LABEL_TAB_HERO$1,LABEL_TAB_LOGO:LABEL_TAB_LOGO$1,LABEL_TAB_ICON:LABEL_TAB_ICON$1,LABEL_TAB_MANAGE:LABEL_TAB_MANAGE$1,MSG_USAGE_INSTRUCTIONS:MSG_USAGE_INSTRUCTIONS$1,ACTION_CHANGE_ARTWORK:ACTION_CHANGE_ARTWORK$1,ACTION_SHOW_LINK_QR:ACTION_SHOW_LINK_QR$1,MSG_ASSET_TAB_SETTINGS_DESC:MSG_ASSET_TAB_SETTINGS_DESC,LABEL_USAGE_TITLE:LABEL_USAGE_TITLE$1,LABEL_SQUARE_CAPSULES:LABEL_SQUARE_CAPSULES$1,LABEL_SQUARE_CAPSULES_DESC:LABEL_SQUARE_CAPSULES_DESC,LABEL_UNIFORM_RECENT:LABEL_UNIFORM_RECENT,LABEL_UNIFORM_RECENT_DESC:LABEL_UNIFORM_RECENT_DESC,LABEL_CAPSULE_GLOW:LABEL_CAPSULE_GLOW$1,LABEL_CAPSULE_GLOW_DESC:LABEL_CAPSULE_GLOW_DESC,LABEL_CAPSULE_GLOW_OFF:LABEL_CAPSULE_GLOW_OFF$1,LABEL_SETTINGS_ASSET_TABS:LABEL_SETTINGS_ASSET_TABS,LABEL_SETTINGS_DISABLE_MOTD:LABEL_SETTINGS_DISABLE_MOTD$1,LABEL_SETTINGS_DISABLE_MOTD_DESC:LABEL_SETTINGS_DISABLE_MOTD_DESC,LABEL_TRANSLATION_CREDIT_TITLE:LABEL_TRANSLATION_CREDIT_TITLE$1,LABEL_MORE_SGDB_TITLE:LABEL_MORE_SGDB_TITLE$1,ACTION_SGDB_DISCORD:ACTION_SGDB_DISCORD$1,ACTION_SGDB_GITHUB:ACTION_SGDB_GITHUB,ACTION_SGDB_DONATE:ACTION_SGDB_DONATE$1,ACTION_SGDB_TRANSLATE:ACTION_SGDB_TRANSLATE$1,ACTION_SGDB_BOOP:ACTION_SGDB_BOOP$1,LABEL_RESTART_STEAM_TITLE:LABEL_RESTART_STEAM_TITLE$1,ACTION_RESTART_STEAM_LATER:ACTION_RESTART_STEAM_LATER$1,ACTION_RESTART_STEAM_NOW:ACTION_RESTART_STEAM_NOW$1,MSG_RESTART_STEAM_DESC:MSG_RESTART_STEAM_DESC,LABEL_GAME_SEARCH_TITLE:LABEL_GAME_SEARCH_TITLE$1,LABEL_FILTER_MODAL_TITLE:LABEL_FILTER_MODAL_TITLE$1,LABEL_FILTER_GAME:LABEL_FILTER_GAME$1,LABEL_FILTER_DIMENSIONS:LABEL_FILTER_DIMENSIONS$1,LABEL_FILTER_STYLES:LABEL_FILTER_STYLES$1,LABEL_FILTER_FILE_TYPES:LABEL_FILTER_FILE_TYPES$1,LABEL_FILTER_ANIMATION_TYPE_TITLE:LABEL_FILTER_ANIMATION_TYPE_TITLE$1,LABEL_FILTER_TYPE_ANIMATED:LABEL_FILTER_TYPE_ANIMATED,LABEL_FILTER_TYPE_STATIC:LABEL_FILTER_TYPE_STATIC,LABEL_FILTER_TAGS_TITLE:LABEL_FILTER_TAGS_TITLE$1,LABEL_FILTER_TAG_NSFW:LABEL_FILTER_TAG_NSFW$1,MSG_FILTER_TAG_NSFW_ENABLED:MSG_FILTER_TAG_NSFW_ENABLED,LABEL_FILTER_TAG_HUMOR:LABEL_FILTER_TAG_HUMOR,LABEL_FILTER_TAG_EPILEPSY:LABEL_FILTER_TAG_EPILEPSY,LABEL_FILTER_TAG_UNTAGGED:LABEL_FILTER_TAG_UNTAGGED,ACTION_FILTER_RESET:ACTION_FILTER_RESET$1,LABEL_BEGGING_MODAL_TITLE:LABEL_BEGGING_MODAL_TITLE$1,LABEL_BEGGING_MODAL_DESC:LABEL_BEGGING_MODAL_DESC,ACTION_HIDE_POS_GUIDES:ACTION_HIDE_POS_GUIDES,ACTION_SHOW_OUTLINE:ACTION_SHOW_OUTLINE,ACTION_ADJUST_POS_SIZE:ACTION_ADJUST_POS_SIZE$1,ACTION_CHANGE_POS_LOGO_ANCHOR_POINT:ACTION_CHANGE_POS_LOGO_ANCHOR_POINT,LABEL_ASSET_CURRENT:LABEL_ASSET_CURRENT$1,ACTION_ASSET_CUSTOM_CLEAR:ACTION_ASSET_CUSTOM_CLEAR$1,ACTION_ASSET_BROWSE_LOCAL:ACTION_ASSET_BROWSE_LOCAL,ACTION_ASSET_APPLY_TRANSPARENT:ACTION_ASSET_APPLY_TRANSPARENT,LABEL_NOTES:LABEL_NOTES$1,LABEL_ANIMATED:LABEL_ANIMATED,LABEL_NSFW:LABEL_NSFW$1,LABEL_HUMOR:LABEL_HUMOR,LABEL_EPILEPSY:LABEL_EPILEPSY,ACTION_OPEN_FILTER:ACTION_OPEN_FILTER$1,ACTION_OPEN_OFFICIAL_ASSETS:ACTION_OPEN_OFFICIAL_ASSETS$1,ACTION_ASSET_APPLY:ACTION_ASSET_APPLY,MSG_GAME_SELECTED:MSG_GAME_SELECTED,MSG_ASSETS_FILTERED:MSG_ASSETS_FILTERED,MSG_GAME_SELECTED_AND_ASSETS_FILTERED:MSG_GAME_SELECTED_AND_ASSETS_FILTERED,TITLE_MOTD_HIDE:TITLE_MOTD_HIDE$1,LABEL_MOTD_THIS:LABEL_MOTD_THIS$1,LABEL_MOTD_ALL:LABEL_MOTD_ALL$1,MSG_ASSET_APPLY_SUCCESS:MSG_ASSET_APPLY_SUCCESS,MSG_ASSET_APPLY_ERROR:MSG_ASSET_APPLY_ERROR,ACTION_OPEN_DETAILS:ACTION_OPEN_DETAILS$1};

var no$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    ACTION_ADJUST_POS_SIZE: ACTION_ADJUST_POS_SIZE$1,
    ACTION_ASSET_APPLY: ACTION_ASSET_APPLY,
    ACTION_ASSET_APPLY_TRANSPARENT: ACTION_ASSET_APPLY_TRANSPARENT,
    ACTION_ASSET_BROWSE_LOCAL: ACTION_ASSET_BROWSE_LOCAL,
    ACTION_ASSET_CUSTOM_CLEAR: ACTION_ASSET_CUSTOM_CLEAR$1,
    ACTION_CHANGE_ARTWORK: ACTION_CHANGE_ARTWORK$1,
    ACTION_CHANGE_POS_LOGO_ANCHOR_POINT: ACTION_CHANGE_POS_LOGO_ANCHOR_POINT,
    ACTION_FILTER_RESET: ACTION_FILTER_RESET$1,
    ACTION_HIDE_POS_GUIDES: ACTION_HIDE_POS_GUIDES,
    ACTION_OPEN_DETAILS: ACTION_OPEN_DETAILS$1,
    ACTION_OPEN_FILTER: ACTION_OPEN_FILTER$1,
    ACTION_OPEN_OFFICIAL_ASSETS: ACTION_OPEN_OFFICIAL_ASSETS$1,
    ACTION_RESTART_STEAM_LATER: ACTION_RESTART_STEAM_LATER$1,
    ACTION_RESTART_STEAM_NOW: ACTION_RESTART_STEAM_NOW$1,
    ACTION_SGDB_BOOP: ACTION_SGDB_BOOP$1,
    ACTION_SGDB_DISCORD: ACTION_SGDB_DISCORD$1,
    ACTION_SGDB_DONATE: ACTION_SGDB_DONATE$1,
    ACTION_SGDB_GITHUB: ACTION_SGDB_GITHUB,
    ACTION_SGDB_TRANSLATE: ACTION_SGDB_TRANSLATE$1,
    ACTION_SHOW_LINK_QR: ACTION_SHOW_LINK_QR$1,
    ACTION_SHOW_OUTLINE: ACTION_SHOW_OUTLINE,
    ASSET_TYPE_CAPSULE: ASSET_TYPE_CAPSULE$1,
    ASSET_TYPE_HERO: ASSET_TYPE_HERO$1,
    ASSET_TYPE_ICON: ASSET_TYPE_ICON$1,
    ASSET_TYPE_LOGO: ASSET_TYPE_LOGO$1,
    ASSET_TYPE_WIDECAPSULE: ASSET_TYPE_WIDECAPSULE$1,
    LABEL_ANIMATED: LABEL_ANIMATED,
    LABEL_ASSET_CURRENT: LABEL_ASSET_CURRENT$1,
    LABEL_BEGGING_MODAL_DESC: LABEL_BEGGING_MODAL_DESC,
    LABEL_BEGGING_MODAL_TITLE: LABEL_BEGGING_MODAL_TITLE$1,
    LABEL_CAPSULE_GLOW: LABEL_CAPSULE_GLOW$1,
    LABEL_CAPSULE_GLOW_DESC: LABEL_CAPSULE_GLOW_DESC,
    LABEL_CAPSULE_GLOW_OFF: LABEL_CAPSULE_GLOW_OFF$1,
    LABEL_EPILEPSY: LABEL_EPILEPSY,
    LABEL_FILTER_ANIMATION_TYPE_TITLE: LABEL_FILTER_ANIMATION_TYPE_TITLE$1,
    LABEL_FILTER_DIMENSIONS: LABEL_FILTER_DIMENSIONS$1,
    LABEL_FILTER_FILE_TYPES: LABEL_FILTER_FILE_TYPES$1,
    LABEL_FILTER_GAME: LABEL_FILTER_GAME$1,
    LABEL_FILTER_MODAL_TITLE: LABEL_FILTER_MODAL_TITLE$1,
    LABEL_FILTER_STYLES: LABEL_FILTER_STYLES$1,
    LABEL_FILTER_TAGS_TITLE: LABEL_FILTER_TAGS_TITLE$1,
    LABEL_FILTER_TAG_EPILEPSY: LABEL_FILTER_TAG_EPILEPSY,
    LABEL_FILTER_TAG_HUMOR: LABEL_FILTER_TAG_HUMOR,
    LABEL_FILTER_TAG_NSFW: LABEL_FILTER_TAG_NSFW$1,
    LABEL_FILTER_TAG_UNTAGGED: LABEL_FILTER_TAG_UNTAGGED,
    LABEL_FILTER_TYPE_ANIMATED: LABEL_FILTER_TYPE_ANIMATED,
    LABEL_FILTER_TYPE_STATIC: LABEL_FILTER_TYPE_STATIC,
    LABEL_GAME_SEARCH_TITLE: LABEL_GAME_SEARCH_TITLE$1,
    LABEL_HUMOR: LABEL_HUMOR,
    LABEL_MORE_SGDB_TITLE: LABEL_MORE_SGDB_TITLE$1,
    LABEL_MOTD_ALL: LABEL_MOTD_ALL$1,
    LABEL_MOTD_THIS: LABEL_MOTD_THIS$1,
    LABEL_NOTES: LABEL_NOTES$1,
    LABEL_NSFW: LABEL_NSFW$1,
    LABEL_RESTART_STEAM_TITLE: LABEL_RESTART_STEAM_TITLE$1,
    LABEL_SETTINGS_ASSET_TABS: LABEL_SETTINGS_ASSET_TABS,
    LABEL_SETTINGS_DISABLE_MOTD: LABEL_SETTINGS_DISABLE_MOTD$1,
    LABEL_SETTINGS_DISABLE_MOTD_DESC: LABEL_SETTINGS_DISABLE_MOTD_DESC,
    LABEL_SQUARE_CAPSULES: LABEL_SQUARE_CAPSULES$1,
    LABEL_SQUARE_CAPSULES_DESC: LABEL_SQUARE_CAPSULES_DESC,
    LABEL_TAB_CAPSULE: LABEL_TAB_CAPSULE$1,
    LABEL_TAB_HERO: LABEL_TAB_HERO$1,
    LABEL_TAB_ICON: LABEL_TAB_ICON$1,
    LABEL_TAB_LOGO: LABEL_TAB_LOGO$1,
    LABEL_TAB_MANAGE: LABEL_TAB_MANAGE$1,
    LABEL_TAB_WIDECAPSULE: LABEL_TAB_WIDECAPSULE$1,
    LABEL_TRANSLATION_CREDIT_TITLE: LABEL_TRANSLATION_CREDIT_TITLE$1,
    LABEL_UNIFORM_RECENT: LABEL_UNIFORM_RECENT,
    LABEL_UNIFORM_RECENT_DESC: LABEL_UNIFORM_RECENT_DESC,
    LABEL_USAGE_TITLE: LABEL_USAGE_TITLE$1,
    MSG_ASSETS_FILTERED: MSG_ASSETS_FILTERED,
    MSG_ASSET_APPLY_ERROR: MSG_ASSET_APPLY_ERROR,
    MSG_ASSET_APPLY_SUCCESS: MSG_ASSET_APPLY_SUCCESS,
    MSG_ASSET_TAB_SETTINGS_DESC: MSG_ASSET_TAB_SETTINGS_DESC,
    MSG_FILTER_TAG_NSFW_ENABLED: MSG_FILTER_TAG_NSFW_ENABLED,
    MSG_GAME_SELECTED: MSG_GAME_SELECTED,
    MSG_GAME_SELECTED_AND_ASSETS_FILTERED: MSG_GAME_SELECTED_AND_ASSETS_FILTERED,
    MSG_RESTART_STEAM_DESC: MSG_RESTART_STEAM_DESC,
    MSG_USAGE_INSTRUCTIONS: MSG_USAGE_INSTRUCTIONS$1,
    TITLE_MOTD_HIDE: TITLE_MOTD_HIDE$1,
    default: no
});

var ASSET_TYPE_CAPSULE="Kapszula";var ASSET_TYPE_WIDECAPSULE="Fejléckapszula";var ASSET_TYPE_HERO="Kiemelés";var ASSET_TYPE_LOGO="Logó";var ASSET_TYPE_ICON="Ikon";var LABEL_TAB_CAPSULE="Kapszula";var LABEL_TAB_WIDECAPSULE="Fejléckapszula";var LABEL_TAB_HERO="Kiemelés";var LABEL_TAB_LOGO="Logó";var LABEL_TAB_ICON="Ikon";var LABEL_TAB_MANAGE="Kezelés";var MSG_USAGE_INSTRUCTIONS="Válassz egy játékot";var ACTION_CHANGE_ARTWORK="Alkotás cserélése";var ACTION_SHOW_LINK_QR="QR-hivatkozás mutatása";var LABEL_USAGE_TITLE="Gyors útmutató";var LABEL_SQUARE_CAPSULES="Négyszögleteskapszulák";var LABEL_CAPSULE_GLOW="Kapszula izzása";var LABEL_CAPSULE_GLOW_OFF="Nincs";var LABEL_SETTINGS_DISABLE_MOTD="Bejelentések kikapcsolása";var LABEL_TRANSLATION_CREDIT_TITLE="Magyar fordítás";var LABEL_MORE_SGDB_TITLE="Több a SteamGridDB-től";var ACTION_SGDB_DISCORD="Csatlakozz a Discordhoz";var ACTION_SGDB_DONATE="Támogatás Patreonon";var ACTION_SGDB_TRANSLATE="Segíts a fordításban";var ACTION_SGDB_BOOP="Nézd az SGDBoop-ot";var LABEL_RESTART_STEAM_TITLE="Steam újraindítása?";var ACTION_RESTART_STEAM_LATER="Később";var ACTION_RESTART_STEAM_NOW="Újraindítás most";var LABEL_GAME_SEARCH_TITLE="Játék keresése";var LABEL_FILTER_MODAL_TITLE="{assetType}szűrő";var LABEL_FILTER_GAME="Játék";var LABEL_FILTER_DIMENSIONS="Méret";var LABEL_FILTER_STYLES="Stílusok";var LABEL_FILTER_FILE_TYPES="Fájltípusok";var LABEL_FILTER_ANIMATION_TYPE_TITLE="Típusok";var LABEL_FILTER_TAGS_TITLE="Címkék";var LABEL_FILTER_TAG_NSFW="Felnőtt tartalom";var ACTION_FILTER_RESET="Szűrők visszaállítása";var LABEL_BEGGING_MODAL_TITLE="Köszönjük, hogy használod a SteamGridDB-t!";var ACTION_ADJUST_POS_SIZE="Méret igazítása";var LABEL_ASSET_CURRENT="Aktuális {assetType}";var ACTION_ASSET_CUSTOM_CLEAR="Egyéni alkotás törlése";var LABEL_NOTES="Jegyzetek";var LABEL_NSFW="Felnőtt tartalom";var ACTION_OPEN_FILTER="Szűrő";var ACTION_OPEN_OFFICIAL_ASSETS="Hivatalos {assetType}";var TITLE_MOTD_HIDE="Bejelentés elrejtése?";var LABEL_MOTD_THIS="Ezt a bejelentést";var LABEL_MOTD_ALL="Minden bejelentést";var ACTION_OPEN_DETAILS="Részletek";var hu = {ASSET_TYPE_CAPSULE:ASSET_TYPE_CAPSULE,ASSET_TYPE_WIDECAPSULE:ASSET_TYPE_WIDECAPSULE,ASSET_TYPE_HERO:ASSET_TYPE_HERO,ASSET_TYPE_LOGO:ASSET_TYPE_LOGO,ASSET_TYPE_ICON:ASSET_TYPE_ICON,LABEL_TAB_CAPSULE:LABEL_TAB_CAPSULE,LABEL_TAB_WIDECAPSULE:LABEL_TAB_WIDECAPSULE,LABEL_TAB_HERO:LABEL_TAB_HERO,LABEL_TAB_LOGO:LABEL_TAB_LOGO,LABEL_TAB_ICON:LABEL_TAB_ICON,LABEL_TAB_MANAGE:LABEL_TAB_MANAGE,MSG_USAGE_INSTRUCTIONS:MSG_USAGE_INSTRUCTIONS,ACTION_CHANGE_ARTWORK:ACTION_CHANGE_ARTWORK,ACTION_SHOW_LINK_QR:ACTION_SHOW_LINK_QR,LABEL_USAGE_TITLE:LABEL_USAGE_TITLE,LABEL_SQUARE_CAPSULES:LABEL_SQUARE_CAPSULES,LABEL_CAPSULE_GLOW:LABEL_CAPSULE_GLOW,LABEL_CAPSULE_GLOW_OFF:LABEL_CAPSULE_GLOW_OFF,LABEL_SETTINGS_DISABLE_MOTD:LABEL_SETTINGS_DISABLE_MOTD,LABEL_TRANSLATION_CREDIT_TITLE:LABEL_TRANSLATION_CREDIT_TITLE,LABEL_MORE_SGDB_TITLE:LABEL_MORE_SGDB_TITLE,ACTION_SGDB_DISCORD:ACTION_SGDB_DISCORD,ACTION_SGDB_DONATE:ACTION_SGDB_DONATE,ACTION_SGDB_TRANSLATE:ACTION_SGDB_TRANSLATE,ACTION_SGDB_BOOP:ACTION_SGDB_BOOP,LABEL_RESTART_STEAM_TITLE:LABEL_RESTART_STEAM_TITLE,ACTION_RESTART_STEAM_LATER:ACTION_RESTART_STEAM_LATER,ACTION_RESTART_STEAM_NOW:ACTION_RESTART_STEAM_NOW,LABEL_GAME_SEARCH_TITLE:LABEL_GAME_SEARCH_TITLE,LABEL_FILTER_MODAL_TITLE:LABEL_FILTER_MODAL_TITLE,LABEL_FILTER_GAME:LABEL_FILTER_GAME,LABEL_FILTER_DIMENSIONS:LABEL_FILTER_DIMENSIONS,LABEL_FILTER_STYLES:LABEL_FILTER_STYLES,LABEL_FILTER_FILE_TYPES:LABEL_FILTER_FILE_TYPES,LABEL_FILTER_ANIMATION_TYPE_TITLE:LABEL_FILTER_ANIMATION_TYPE_TITLE,LABEL_FILTER_TAGS_TITLE:LABEL_FILTER_TAGS_TITLE,LABEL_FILTER_TAG_NSFW:LABEL_FILTER_TAG_NSFW,ACTION_FILTER_RESET:ACTION_FILTER_RESET,LABEL_BEGGING_MODAL_TITLE:LABEL_BEGGING_MODAL_TITLE,ACTION_ADJUST_POS_SIZE:ACTION_ADJUST_POS_SIZE,LABEL_ASSET_CURRENT:LABEL_ASSET_CURRENT,ACTION_ASSET_CUSTOM_CLEAR:ACTION_ASSET_CUSTOM_CLEAR,LABEL_NOTES:LABEL_NOTES,LABEL_NSFW:LABEL_NSFW,ACTION_OPEN_FILTER:ACTION_OPEN_FILTER,ACTION_OPEN_OFFICIAL_ASSETS:ACTION_OPEN_OFFICIAL_ASSETS,TITLE_MOTD_HIDE:TITLE_MOTD_HIDE,LABEL_MOTD_THIS:LABEL_MOTD_THIS,LABEL_MOTD_ALL:LABEL_MOTD_ALL,ACTION_OPEN_DETAILS:ACTION_OPEN_DETAILS};

var hu$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    ACTION_ADJUST_POS_SIZE: ACTION_ADJUST_POS_SIZE,
    ACTION_ASSET_CUSTOM_CLEAR: ACTION_ASSET_CUSTOM_CLEAR,
    ACTION_CHANGE_ARTWORK: ACTION_CHANGE_ARTWORK,
    ACTION_FILTER_RESET: ACTION_FILTER_RESET,
    ACTION_OPEN_DETAILS: ACTION_OPEN_DETAILS,
    ACTION_OPEN_FILTER: ACTION_OPEN_FILTER,
    ACTION_OPEN_OFFICIAL_ASSETS: ACTION_OPEN_OFFICIAL_ASSETS,
    ACTION_RESTART_STEAM_LATER: ACTION_RESTART_STEAM_LATER,
    ACTION_RESTART_STEAM_NOW: ACTION_RESTART_STEAM_NOW,
    ACTION_SGDB_BOOP: ACTION_SGDB_BOOP,
    ACTION_SGDB_DISCORD: ACTION_SGDB_DISCORD,
    ACTION_SGDB_DONATE: ACTION_SGDB_DONATE,
    ACTION_SGDB_TRANSLATE: ACTION_SGDB_TRANSLATE,
    ACTION_SHOW_LINK_QR: ACTION_SHOW_LINK_QR,
    ASSET_TYPE_CAPSULE: ASSET_TYPE_CAPSULE,
    ASSET_TYPE_HERO: ASSET_TYPE_HERO,
    ASSET_TYPE_ICON: ASSET_TYPE_ICON,
    ASSET_TYPE_LOGO: ASSET_TYPE_LOGO,
    ASSET_TYPE_WIDECAPSULE: ASSET_TYPE_WIDECAPSULE,
    LABEL_ASSET_CURRENT: LABEL_ASSET_CURRENT,
    LABEL_BEGGING_MODAL_TITLE: LABEL_BEGGING_MODAL_TITLE,
    LABEL_CAPSULE_GLOW: LABEL_CAPSULE_GLOW,
    LABEL_CAPSULE_GLOW_OFF: LABEL_CAPSULE_GLOW_OFF,
    LABEL_FILTER_ANIMATION_TYPE_TITLE: LABEL_FILTER_ANIMATION_TYPE_TITLE,
    LABEL_FILTER_DIMENSIONS: LABEL_FILTER_DIMENSIONS,
    LABEL_FILTER_FILE_TYPES: LABEL_FILTER_FILE_TYPES,
    LABEL_FILTER_GAME: LABEL_FILTER_GAME,
    LABEL_FILTER_MODAL_TITLE: LABEL_FILTER_MODAL_TITLE,
    LABEL_FILTER_STYLES: LABEL_FILTER_STYLES,
    LABEL_FILTER_TAGS_TITLE: LABEL_FILTER_TAGS_TITLE,
    LABEL_FILTER_TAG_NSFW: LABEL_FILTER_TAG_NSFW,
    LABEL_GAME_SEARCH_TITLE: LABEL_GAME_SEARCH_TITLE,
    LABEL_MORE_SGDB_TITLE: LABEL_MORE_SGDB_TITLE,
    LABEL_MOTD_ALL: LABEL_MOTD_ALL,
    LABEL_MOTD_THIS: LABEL_MOTD_THIS,
    LABEL_NOTES: LABEL_NOTES,
    LABEL_NSFW: LABEL_NSFW,
    LABEL_RESTART_STEAM_TITLE: LABEL_RESTART_STEAM_TITLE,
    LABEL_SETTINGS_DISABLE_MOTD: LABEL_SETTINGS_DISABLE_MOTD,
    LABEL_SQUARE_CAPSULES: LABEL_SQUARE_CAPSULES,
    LABEL_TAB_CAPSULE: LABEL_TAB_CAPSULE,
    LABEL_TAB_HERO: LABEL_TAB_HERO,
    LABEL_TAB_ICON: LABEL_TAB_ICON,
    LABEL_TAB_LOGO: LABEL_TAB_LOGO,
    LABEL_TAB_MANAGE: LABEL_TAB_MANAGE,
    LABEL_TAB_WIDECAPSULE: LABEL_TAB_WIDECAPSULE,
    LABEL_TRANSLATION_CREDIT_TITLE: LABEL_TRANSLATION_CREDIT_TITLE,
    LABEL_USAGE_TITLE: LABEL_USAGE_TITLE,
    MSG_USAGE_INSTRUCTIONS: MSG_USAGE_INSTRUCTIONS,
    TITLE_MOTD_HIDE: TITLE_MOTD_HIDE,
    default: hu
});

const simplifiedChinese = {
    name: '简体中文',
    strings: zhCn$1,
    credit: ['zhzy0077', 'XHXIAIEIN', 'simon3000'],
};
const LANGS$1 = {
    cs: {
        name: 'Čeština',
        strings: cs$1,
        credit: ['zenobit', 'theczechczech'],
    },
    da: {
        name: 'Dansk',
        strings: da$1,
        credit: ['Jakob Frank Mogensen'],
    },
    de: {
        name: 'Deutsch',
        strings: de$1,
        credit: ['Kurikuo', 'benutzer_artur7', 'Anja', 'FL0W', 'Remirax', 'LittleFreak', 'bignutty', 'Tom Taylor'],
    },
    fi: {
        name: 'Suomi',
        strings: fi$1,
        credit: ['Jage'],
    },
    el: {
        name: 'Ελληνικά',
        strings: el$1,
        credit: ['Emenesu'],
    },
    es: {
        name: 'Español-España',
        strings: es$1,
        credit: ['Andrea Laguillo', 'Kam', 'm0uch0'],
    },
    'es-419': {
        name: 'Español-Latinoamérica',
        strings: es419$1,
        credit: ['Kam', 'Knux03'],
    },
    fr: {
        name: 'Français',
        strings: fr$1,
        credit: ['Michael Jean', 'Xunkar'],
    },
    it: {
        name: 'Italiano',
        strings: it$1,
        credit: ['SpagottoB37', 'RodoMa92', 'federico-ntr'],
    },
    ja: {
        name: '日本語',
        strings: ja$1,
        credit: ['Nes'],
    },
    ko: {
        name: '한국어',
        strings: ko$1,
        credit: ['yor42', 'sua (sua_owo)'],
    },
    nl: {
        name: 'Nederlands',
        strings: nl$1,
        credit: ['Phanpy100 (Fanny)', 'Jannes Verlinde'],
    },
    pl: {
        name: 'Polski',
        strings: pl$1,
        credit: ['DRS', 'Michał Kwiatkowski', 'MAX0R', 'minttuNB', 'Szymon Kucharski'],
    },
    pt: {
        name: 'Português',
        strings: pt$1,
        credit: ['Kokasgui', 'Ev1lbl0w'],
    },
    'pt-br': {
        name: 'Português-Brasil',
        strings: ptBr$1,
        credit: ['Oregano', 'Thomas Eric'],
    },
    ro: {
        name: 'Română',
        strings: ro$1,
        credit: ['Munt'],
    },
    ru: {
        name: 'Русский',
        strings: ru$1,
        credit: ['fycher', 'LostHikking'],
    },
    sv: {
        name: 'Svenska',
        strings: sv$1,
        credit: ['Moneyman Dan', 'Super', 'Daniel Nylander'],
    },
    tr: {
        name: 'Türkçe',
        strings: tr$1,
        credit: ['Bilgehan Ceviz', 'Sib | Twig'],
    },
    uk: {
        name: 'Українська',
        strings: uk$1,
        credit: ['Veydzher', 'Kefir'],
    },
    'zh-cn': simplifiedChinese,
    'sc-sc': simplifiedChinese, // sc-sc is "SteamChina" i think?, it's mapped to zh-cn in the client so doing the same here.
    'zh-tw': {
        name: '正體中文',
        strings: zhTw$1,
        credit: ['mingyc'],
    },
    no: {
        name: 'Norsk',
        strings: no$1,
        credit: ['minttuNB'],
    },
    hu: {
        name: 'Magyar',
        strings: hu$1,
        credit: ['minttuNB'],
    },
    //  th: {
    //    name: 'ไทย',
    //    strings: th,
    //    credit: []
    //  },
    //  bg: {
    //    name: 'български език',
    //    strings: bg,
    //    credit: []
    //  },
    //  en: {
    //    name: 'English',
    //    strings: en,
    //    credit: []
    //  }
    //  vn: {
    //    name: 'Tiếng Việt',
    //    strings: vn,
    //    credit: []
    //  },
    //  id: {
    //    name: 'Bahasa Indonesia',
    //    strings: id,
    //    credit: []
    //  },
};
let cachedLang;
const getCurrentLanguage = () => {
    if (cachedLang)
        return cachedLang;
    const lang = window.LocalizationManager.m_rgLocalesToUse[0];
    cachedLang = lang;
    return lang;
};
const getCredits = (lang) => {
    return LANGS$1[getCurrentLanguage()]?.credit;
};
/**
 * Very basic translation cause theres like 20 strings and i don't need anything more complex.
 *
 * @param {string} key Locale key
 * @param {string} originalString Original text
 * @param {boolean} steamToken If true, uses the key to query Steams token store.
 *    Good for actions like "Back" or "Cancel". Won't be dumped with the rest of the strings.
 *
 * @example
 * t('TITLE_FILTER_MODAL', 'Asset Filters')
 * @example
 * // if you need variables use .replace()
 * t('ACTION_REMOVE_GAME', 'Delete {gameName}').replaceAll('{gameName}', gameName)
 * @example
 * // Original Steam string
 * t('Button_Back', 'Back', true);
 */
const trans_string = (key, originalString, steamToken = false) => {
    const lang = getCurrentLanguage();
    if (steamToken) {
        return window.LocalizationManager.m_mapTokens.get(key) ?? window.LocalizationManager.m_mapFallbackTokens.get(key) ?? originalString;
    }
    if (lang === 'en')
        return originalString;
    return LANGS$1[lang]?.strings?.[key] ?? originalString;
};

// THIS FILE IS AUTO GENERATED
function HiEyeSlash (props) {
  return GenIcon({"tag":"svg","attr":{"viewBox":"0 0 24 24","fill":"currentColor","aria-hidden":"true"},"child":[{"tag":"path","attr":{"d":"M3.53 2.47a.75.75 0 0 0-1.06 1.06l18 18a.75.75 0 1 0 1.06-1.06l-18-18ZM22.676 12.553a11.249 11.249 0 0 1-2.631 4.31l-3.099-3.099a5.25 5.25 0 0 0-6.71-6.71L7.759 4.577a11.217 11.217 0 0 1 4.242-.827c4.97 0 9.185 3.223 10.675 7.69.12.362.12.752 0 1.113Z"},"child":[]},{"tag":"path","attr":{"d":"M15.75 12c0 .18-.013.357-.037.53l-4.244-4.243A3.75 3.75 0 0 1 15.75 12ZM12.53 15.713l-4.243-4.244a3.75 3.75 0 0 0 4.244 4.243Z"},"child":[]},{"tag":"path","attr":{"d":"M6.75 12c0-.619.107-1.213.304-1.764l-3.1-3.1a11.25 11.25 0 0 0-2.63 4.31c-.12.362-.12.752 0 1.114 1.489 4.467 5.704 7.69 10.675 7.69 1.5 0 2.933-.294 4.242-.827l-2.477-2.477A5.25 5.25 0 0 1 6.75 12Z"},"child":[]}]})(props);
}function HiEye (props) {
  return GenIcon({"tag":"svg","attr":{"viewBox":"0 0 24 24","fill":"currentColor","aria-hidden":"true"},"child":[{"tag":"path","attr":{"d":"M12 15a3 3 0 1 0 0-6 3 3 0 0 0 0 6Z"},"child":[]},{"tag":"path","attr":{"fillRule":"evenodd","d":"M1.323 11.447C2.811 6.976 7.028 3.75 12.001 3.75c4.97 0 9.185 3.223 10.675 7.69.12.362.12.752 0 1.113-1.487 4.471-5.705 7.697-10.677 7.697-4.97 0-9.186-3.223-10.675-7.69a1.762 1.762 0 0 1 0-1.113ZM17.25 12a5.25 5.25 0 1 1-10.5 0 5.25 5.25 0 0 1 10.5 0Z","clipRule":"evenodd"},"child":[]}]})(props);
}function HiFolder (props) {
  return GenIcon({"tag":"svg","attr":{"viewBox":"0 0 24 24","fill":"currentColor","aria-hidden":"true"},"child":[{"tag":"path","attr":{"d":"M19.5 21a3 3 0 0 0 3-3v-4.5a3 3 0 0 0-3-3h-15a3 3 0 0 0-3 3V18a3 3 0 0 0 3 3h15ZM1.5 10.146V6a3 3 0 0 1 3-3h5.379a2.25 2.25 0 0 1 1.59.659l2.122 2.121c.14.141.331.22.53.22H19.5a3 3 0 0 1 3 3v1.146A4.483 4.483 0 0 0 19.5 9h-15a4.483 4.483 0 0 0-3 1.146Z"},"child":[]}]})(props);
}function HiHome (props) {
  return GenIcon({"tag":"svg","attr":{"viewBox":"0 0 24 24","fill":"currentColor","aria-hidden":"true"},"child":[{"tag":"path","attr":{"d":"M11.47 3.841a.75.75 0 0 1 1.06 0l8.69 8.69a.75.75 0 1 0 1.06-1.061l-8.689-8.69a2.25 2.25 0 0 0-3.182 0l-8.69 8.69a.75.75 0 1 0 1.061 1.06l8.69-8.689Z"},"child":[]},{"tag":"path","attr":{"d":"m12 5.432 8.159 8.159c.03.03.06.058.091.086v6.198c0 1.035-.84 1.875-1.875 1.875H15a.75.75 0 0 1-.75-.75v-4.5a.75.75 0 0 0-.75-.75h-3a.75.75 0 0 0-.75.75V21a.75.75 0 0 1-.75.75H5.625a1.875 1.875 0 0 1-1.875-1.875v-6.198a2.29 2.29 0 0 0 .091-.086L12 5.432Z"},"child":[]}]})(props);
}function HiQrCode (props) {
  return GenIcon({"tag":"svg","attr":{"viewBox":"0 0 24 24","fill":"currentColor","aria-hidden":"true"},"child":[{"tag":"path","attr":{"fillRule":"evenodd","d":"M3 4.875C3 3.839 3.84 3 4.875 3h4.5c1.036 0 1.875.84 1.875 1.875v4.5c0 1.036-.84 1.875-1.875 1.875h-4.5A1.875 1.875 0 0 1 3 9.375v-4.5ZM4.875 4.5a.375.375 0 0 0-.375.375v4.5c0 .207.168.375.375.375h4.5a.375.375 0 0 0 .375-.375v-4.5a.375.375 0 0 0-.375-.375h-4.5Zm7.875.375c0-1.036.84-1.875 1.875-1.875h4.5C20.16 3 21 3.84 21 4.875v4.5c0 1.036-.84 1.875-1.875 1.875h-4.5a1.875 1.875 0 0 1-1.875-1.875v-4.5Zm1.875-.375a.375.375 0 0 0-.375.375v4.5c0 .207.168.375.375.375h4.5a.375.375 0 0 0 .375-.375v-4.5a.375.375 0 0 0-.375-.375h-4.5ZM6 6.75A.75.75 0 0 1 6.75 6h.75a.75.75 0 0 1 .75.75v.75a.75.75 0 0 1-.75.75h-.75A.75.75 0 0 1 6 7.5v-.75Zm9.75 0A.75.75 0 0 1 16.5 6h.75a.75.75 0 0 1 .75.75v.75a.75.75 0 0 1-.75.75h-.75a.75.75 0 0 1-.75-.75v-.75ZM3 14.625c0-1.036.84-1.875 1.875-1.875h4.5c1.036 0 1.875.84 1.875 1.875v4.5c0 1.035-.84 1.875-1.875 1.875h-4.5A1.875 1.875 0 0 1 3 19.125v-4.5Zm1.875-.375a.375.375 0 0 0-.375.375v4.5c0 .207.168.375.375.375h4.5a.375.375 0 0 0 .375-.375v-4.5a.375.375 0 0 0-.375-.375h-4.5Zm7.875-.75a.75.75 0 0 1 .75-.75h.75a.75.75 0 0 1 .75.75v.75a.75.75 0 0 1-.75.75h-.75a.75.75 0 0 1-.75-.75v-.75Zm6 0a.75.75 0 0 1 .75-.75h.75a.75.75 0 0 1 .75.75v.75a.75.75 0 0 1-.75.75h-.75a.75.75 0 0 1-.75-.75v-.75ZM6 16.5a.75.75 0 0 1 .75-.75h.75a.75.75 0 0 1 .75.75v.75a.75.75 0 0 1-.75.75h-.75a.75.75 0 0 1-.75-.75v-.75Zm9.75 0a.75.75 0 0 1 .75-.75h.75a.75.75 0 0 1 .75.75v.75a.75.75 0 0 1-.75.75h-.75a.75.75 0 0 1-.75-.75v-.75Zm-3 3a.75.75 0 0 1 .75-.75h.75a.75.75 0 0 1 .75.75v.75a.75.75 0 0 1-.75.75h-.75a.75.75 0 0 1-.75-.75v-.75Zm6 0a.75.75 0 0 1 .75-.75h.75a.75.75 0 0 1 .75.75v.75a.75.75 0 0 1-.75.75h-.75a.75.75 0 0 1-.75-.75v-.75Z","clipRule":"evenodd"},"child":[]}]})(props);
}function HiTrash (props) {
  return GenIcon({"tag":"svg","attr":{"viewBox":"0 0 24 24","fill":"currentColor","aria-hidden":"true"},"child":[{"tag":"path","attr":{"fillRule":"evenodd","d":"M16.5 4.478v.227a48.816 48.816 0 0 1 3.878.512.75.75 0 1 1-.256 1.478l-.209-.035-1.005 13.07a3 3 0 0 1-2.991 2.77H8.084a3 3 0 0 1-2.991-2.77L4.087 6.66l-.209.035a.75.75 0 0 1-.256-1.478A48.567 48.567 0 0 1 7.5 4.705v-.227c0-1.564 1.213-2.9 2.816-2.951a52.662 52.662 0 0 1 3.369 0c1.603.051 2.815 1.387 2.815 2.951Zm-6.136-1.452a51.196 51.196 0 0 1 3.273 0C14.39 3.05 15 3.684 15 4.478v.113a49.488 49.488 0 0 0-6 0v-.113c0-.794.609-1.428 1.364-1.452Zm-.355 5.945a.75.75 0 1 0-1.5.058l.347 9a.75.75 0 1 0 1.499-.058l-.346-9Zm5.48.058a.75.75 0 1 0-1.498-.058l-.347 9a.75.75 0 0 0 1.5.058l.345-9Z","clipRule":"evenodd"},"child":[]}]})(props);
}function HiXMark (props) {
  return GenIcon({"tag":"svg","attr":{"viewBox":"0 0 24 24","fill":"currentColor","aria-hidden":"true"},"child":[{"tag":"path","attr":{"fillRule":"evenodd","d":"M5.47 5.47a.75.75 0 0 1 1.06 0L12 10.94l5.47-5.47a.75.75 0 1 1 1.06 1.06L13.06 12l5.47 5.47a.75.75 0 1 1-1.06 1.06L12 13.06l-5.47 5.47a.75.75 0 0 1-1.06-1.06L10.94 12 5.47 6.53a.75.75 0 0 1 0-1.06Z","clipRule":"evenodd"},"child":[]}]})(props);
}function HiOutlineChevronRight (props) {
  return GenIcon({"tag":"svg","attr":{"fill":"none","viewBox":"0 0 24 24","strokeWidth":"1.5","stroke":"currentColor","aria-hidden":"true"},"child":[{"tag":"path","attr":{"strokeLinecap":"round","strokeLinejoin":"round","d":"m8.25 4.5 7.5 7.5-7.5 7.5"},"child":[]}]})(props);
}

const ASSET_TYPE = {
    grid_p: 0,
    grid_l: 3,
    hero: 1,
    logo: 2,
    icon: 4,
};
const SGDB_ASSET_TYPE_READABLE = {
    grid_p: trans_string('ASSET_TYPE_CAPSULE', 'Capsule'),
    grid_l: trans_string('ASSET_TYPE_WIDECAPSULE', 'Wide Capsule'),
    hero: trans_string('ASSET_TYPE_HERO', 'Hero'),
    logo: trans_string('ASSET_TYPE_LOGO', 'Logo'),
    icon: trans_string('ASSET_TYPE_ICON', 'Icon'),
};
const gridStyles = {
    options: [
        { label: 'Alternate', value: 'alternate' },
        { label: 'White Logo', value: 'white_logo' },
        { label: 'No Logo', value: 'no_logo' },
        { label: 'Blurred', value: 'blurred' },
        { label: 'Minimal', value: 'material' },
    ],
    default: ['alternate', 'white_logo', 'no_logo', 'blurred', 'material'],
};
const STYLES = {
    grid_p: gridStyles,
    grid_l: gridStyles,
    hero: {
        options: [
            { label: 'Alternate', value: 'alternate' },
            { label: 'Blurred', value: 'blurred' },
            { label: 'Minimal', value: 'material' },
        ],
        default: ['alternate', 'blurred', 'material'],
    },
    logo: {
        options: [
            { label: 'Official', value: 'official' },
            { label: 'White', value: 'white' },
            { label: 'Black', value: 'black' },
            { label: 'Custom', value: 'custom' },
        ],
        default: ['official', 'white', 'black', 'custom'],
    },
    icon: {
        options: [
            { label: 'Official', value: 'official' },
            { label: 'Custom', value: 'custom' },
        ],
        default: ['official', 'custom'],
    },
};
const SGDB_MIME_MAP = {
    'image/png': 'PNG',
    'image/jpeg': 'JPEG',
    'image/webp': 'WebP',
    'image/vnd.microsoft.icon': 'ICO',
};
const allMimes = {
    options: [
        { label: 'PNG', value: 'image/png' },
        { label: 'JPEG', value: 'image/jpeg' },
        { label: 'WebP', value: 'image/webp' },
    ],
    default: ['image/png', 'image/jpeg', 'image/webp'],
};
const MIMES = {
    grid_p: allMimes,
    grid_l: allMimes,
    hero: allMimes,
    logo: {
        options: [
            { label: 'PNG', value: 'image/png' },
            { label: 'WebP', value: 'image/webp' },
        ],
        default: ['image/png', 'image/webp'],
    },
    icon: {
        options: [
            { label: 'PNG', value: 'image/png' },
            { label: 'ICO', value: 'image/vnd.microsoft.icon' },
        ],
        default: ['image/png', 'image/vnd.microsoft.icon'],
    },
};
const validIconSizes = [1024, 768, 512, 310, 256, 194, 192, 180, 160, 152, 150, 144, 128, 120, 114, 100, 96, 90, 80, 76, 72, 64, 60, 57, 56, 54, 48, 40, 35, 32, 28, 24, 20, 16, 14, 10, 8];
const DIMENSIONS = {
    grid_p: {
        options: ['600x900', '342x482', '660x930', '512x512', '1024x1024'].map((x) => ({ label: x.replace('x', '×'), value: x })),
        default: ['600x900', '342x482', '660x930'],
    },
    grid_l: {
        options: ['460x215', '920x430', '512x512', '1024x1024'].map((x) => ({ label: x.replace('x', '×'), value: x })),
        default: ['460x215', '920x430'],
    },
    hero: {
        options: ['1920x620', '3840x1240', '1600x650'].map((x) => ({ label: x.replace('x', '×'), value: x })),
        default: ['1920x620', '3840x1240', '1600x650'],
    },
    logo: {
        options: [],
        default: [],
    },
    icon: {
        options: validIconSizes.map((x) => ({ label: `${x}×${x}`, value: x })),
        default: validIconSizes,
    },
};
// Sometimes tabs needs different translation strings
const tabStrs = {
    grid_p: trans_string('LABEL_TAB_CAPSULE', 'Capsule'),
    grid_l: trans_string('LABEL_TAB_WIDECAPSULE', 'Wide Capsule'),
    hero: trans_string('LABEL_TAB_HERO', 'Hero'),
    logo: trans_string('LABEL_TAB_LOGO', 'Logo'),
    icon: trans_string('LABEL_TAB_ICON', 'Icon'),
    manage: trans_string('LABEL_TAB_MANAGE', 'Manage'),
};
// Default tab order
const DEFAULT_TABS = [
    ...Object.keys(tabStrs),
];

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

var justDebounce = debounce;

function debounce(fn, delay, atStart, guarantee) {
  var timeout;
  var args;
  var self;

  return function debounced() {
    self = this;
    args = Array.prototype.slice.call(arguments);

    if (timeout && (atStart || guarantee)) {
      return;
    } else if (!atStart) {
      clear();

      timeout = setTimeout(run, delay);
      return timeout;
    }

    timeout = setTimeout(clear, delay);
    fn.apply(self, args);

    function run() {
      clear();
      fn.apply(self, args);
    }

    function clear() {
      clearTimeout(timeout);
      timeout = null;
    }
  };
}

var debounce$1 = /*@__PURE__*/getDefaultExportFromCjs(justDebounce);

const SettingsContext = SP_REACT.createContext({});
const SettingsProvider = ({ children }) => {
    const [setting, setSetting] = SP_REACT.useState();
    const save = SP_REACT.useMemo(() => async (setting) => {
        await call('set_setting', setting.key, setting.value);
    }, []);
    const saveDb = SP_REACT.useMemo(() => debounce$1(async (key, value) => {
        setSetting({ key, value });
    }, 1500), []);
    const set = SP_REACT.useMemo(() => (key, value, immediate = false) => {
        if (immediate) {
            return setSetting({ key, value });
        }
        return saveDb(key, value);
    }, [saveDb]);
    const get = SP_REACT.useMemo(() => async (key, fallback) => {
        return await call('get_setting', key, fallback);
    }, []);
    SP_REACT.useEffect(() => {
        if (setting) {
            save(setting);
        }
    }, [save, setting]);
    return (window.SP_REACT.createElement(SettingsContext.Provider, { value: { set, get } }, children));
};
const useSettings = () => SP_REACT.useContext(SettingsContext);

const buttonStyle = {
    display: 'flex',
    justifyContent: 'center',
    alignItems: 'center',
    padding: '10px',
    maxWidth: '40px',
    minWidth: 'auto',
    marginLeft: '.5em',
};
const Interactables = ({ entry, defaultTab, hiddenTabs, onDefaultClick, onHideClick }) => {
    const [shakeHidden, setShakeHidden] = SP_REACT.useState(false);
    const isHidden = hiddenTabs?.includes(entry.data?.type);
    SP_REACT.useEffect(() => {
        if (shakeHidden) {
            const timeout = setTimeout(() => {
                setShakeHidden(false);
            }, 400); // animation plays for 200ms and repeats twice, so 400ms is enough
            return () => clearTimeout(timeout);
        }
        return undefined;
    }, [shakeHidden]);
    if (!entry.data)
        return null;
    return (window.SP_REACT.createElement(window.SP_REACT.Fragment, null,
        (defaultTab !== entry.data.type) ? (window.SP_REACT.createElement(DFL.DialogButton, { onOKButton: () => onDefaultClick(entry), style: buttonStyle },
            window.SP_REACT.createElement(HiHome, null))) : (window.SP_REACT.createElement("div", { style: buttonStyle },
            window.SP_REACT.createElement(HiHome, { fill: "#008ada" }))),
        window.SP_REACT.createElement(DFL.DialogButton, { onOKActionDescription: isHidden ? 'Show' : trans_string('Button_Hide', 'Hide', true), onOKButton: () => {
                if (!entry.data)
                    return;
                if (hiddenTabs &&
                    !isHidden &&
                    hiddenTabs.length === DEFAULT_TABS.length - 1) {
                    setShakeHidden(true);
                }
                else {
                    onHideClick(entry);
                }
            }, style: shakeHidden ? {
                ...buttonStyle,
                ...{ animation: '200ms sgdb-button-shake 2' },
            } : buttonStyle }, isHidden ? window.SP_REACT.createElement(HiEye, null) : window.SP_REACT.createElement(HiEyeSlash, null))));
};
const TabSorter = () => {
    const { set, get } = useSettings();
    const [defaultTab, setDefaultTab] = SP_REACT.useState(null);
    const [hiddenTabs, setHiddenTabs] = SP_REACT.useState(null);
    const [tabPositions, setTabPositions] = SP_REACT.useState(null);
    const fieldRef = SP_REACT.useRef(null);
    const once = SP_REACT.useRef(false);
    const tabEntries = SP_REACT.useMemo(() => {
        if (tabPositions === null || hiddenTabs === null)
            return [];
        return tabPositions.map((type, i) => ({
            label: (window.SP_REACT.createElement(DFL.Marquee, { style: {
                    maxWidth: '340px',
                    opacity: hiddenTabs.includes(type) ? .5 : 1,
                } }, tabStrs[type])),
            data: { type },
            position: i,
        }));
    }, [tabPositions, hiddenTabs]);
    const handleSave = (entries) => {
        const sortedTabs = entries.map((entry) => entry.data?.type);
        set('tabs_order', sortedTabs, true);
        setTabPositions(sortedTabs);
    };
    const handleHideClick = SP_REACT.useCallback((entry) => {
        setHiddenTabs((x) => {
            if (entry.data && x) {
                const v = [...x];
                if (v.includes(entry.data.type)) {
                    v.splice(v.indexOf(entry.data.type), 1);
                }
                else {
                    v.push(entry.data.type);
                }
                set('tabs_hidden', v, true);
                return v;
            }
            return null;
        });
    }, [set]);
    const handleDefaultClick = SP_REACT.useCallback((entry) => {
        if (entry.data) {
            set('tab_default', entry.data.type, true);
            setDefaultTab(entry.data.type);
        }
    }, [set]);
    SP_REACT.useEffect(() => {
        (async () => {
            const positions = await get('tabs_order', DEFAULT_TABS);
            const hidden = await get('tabs_hidden', []);
            let tabDefault = await get('tab_default', 'grid_p');
            const filtered = positions.filter((x) => !hidden.includes(x));
            setTabPositions(positions);
            setHiddenTabs(hidden);
            // Set first tab as default if default is hidden
            if (!filtered.includes(tabDefault)) {
                tabDefault = filtered[0];
            }
            setDefaultTab(tabDefault);
        })();
    }, [get]);
    SP_REACT.useEffect(() => {
        // hack to auto focus first element after render
        if (tabEntries.length > 0 && defaultTab && !once.current) {
            fieldRef.current?.querySelector('button')?.focus();
            once.current = true;
        }
    }, [tabEntries, defaultTab]);
    return (window.SP_REACT.createElement(window.SP_REACT.Fragment, null,
        window.SP_REACT.createElement("style", null, `
        @keyframes sgdb-button-shake {
          0% { transform: translateX(0) }
          25% { transform: translateX(3px) }
          50% { transform: translateX(-3px) }
          75% { transform: translateX(3px) }
          100% { transform: translateX(0) }
        }
      `),
        window.SP_REACT.createElement(DFL.Focusable, { ref: fieldRef },
            window.SP_REACT.createElement(DFL.ReorderableList, { animate: true, entries: tabEntries, onSave: handleSave, interactables: (props) => (window.SP_REACT.createElement(Interactables, { ...props, defaultTab: defaultTab, hiddenTabs: hiddenTabs, onDefaultClick: handleDefaultClick, onHideClick: handleHideClick })) }))));
};
TabSorter.displayName = 'TabSorter';

const libraryAssetImageClasses = DFL.findModule((mod) => typeof mod === 'object' && mod?.PortraitImage && mod?.Container && mod?.LandscapeImage);
const gamepadLibraryClasses = DFL.findModule((mod) => typeof mod === 'object' && mod?.GamepadLibrary);
const homeCarouselClasses = DFL.findModule((mod) => typeof mod === 'object' && mod?.Featured && mod?.LabelHeight && mod?.CarouselGameLabelWrapper);
const appportraitClasses = DFL.findModule((mod) => typeof mod === 'object' && mod?.AppPortraitBanner);
const appgridClasses = DFL.findModule((mod) => typeof mod === 'object' && mod?.LibraryImageBackgroundGlow);
// seems to have Marquee, info box, and subheader stuff
const miscInfoClasses = DFL.findClassModule((m) => m.ResetOnPause && m.Content && m.Playing && m.BackgroundAnimation && m.Container);

const addStyle = (id, css) => {
    // inject css if it isn't there already
    const existingStyleEl = DFL.findSP().window.document.getElementById(id);
    if (!existingStyleEl) {
        const styleEl = DFL.findSP().window.document.createElement('style');
        styleEl.id = id;
        styleEl.textContent = css;
        DFL.findSP().window.document.head.append(styleEl);
    }
};
const removeStyle = (id) => {
    const existingStyleEl = DFL.findSP().window.document.getElementById(id);
    existingStyleEl?.remove();
};
/**
  Updates the style if it exists, creates the style if not.
 */
const updateStyle = (id, css) => {
    const existingStyleEl = DFL.findSP().window.document.getElementById(id);
    if (existingStyleEl) {
        existingStyleEl.textContent = css;
    }
    else {
        addStyle(id, css);
    }
};
const removeStyles = (...ids) => {
    for (let i = 0; i < ids.length; i++) {
        const elId = ids[i];
        removeStyle(elId);
    }
};

function rerenderAfterPatchUpdate() {
    if (window.location.pathname.startsWith('/routes/library/home')) {
        DFL.Navigation.Navigate('/library/home');
        // ? We need to navigate back to not clog up the nav.
        DFL.Navigation.NavigateBack();
    }
    else if (window.location.pathname.startsWith('/routes/library')) {
        DFL.Navigation.Navigate('/library');
        // ? We need to navigate back to not clog up the nav.
        DFL.Navigation.NavigateBack();
    }
}

let patch$2;
/*
  Calculating the same way Steam does it
  175/262.5 is a hardcoded value in the library code
  Used as a fallback for first (?) render while afterPatch runs to get width
  Might break if user is changing asset container sizes via CSS, but only once
 */
const calculateDefaultCapsuleWidth = (newHeight) => {
    const originalWidth = 175;
    const originalHeight = 262.5;
    const ratio = originalWidth / originalHeight;
    return newHeight * ratio;
};
const addHomePatch = (mounting = false, square = false, matchFeatured = false, carouselLogo = false) => {
    if (square) {
        addStyle('sgdb-square-capsules-home', `
      /* only select home page */
      .${appportraitClasses.InRecentGames} .${libraryAssetImageClasses.Container}.${libraryAssetImageClasses.PortraitImage} {
        padding-top: 100% !important;
      }
    `);
    }
    else {
        removeStyle('sgdb-square-capsules-home');
    }
    if (carouselLogo) {
        addStyle('sgdb-carousel-logo', `
      .${homeCarouselClasses.CarouselGameLabelWrapper} {
        /* margin-top: -30px; */
      }
      /* allow drop-shadow to extend outside containers */
      .${homeCarouselClasses.CarouselGameLabelWrapper} .${miscInfoClasses.Container},
      .${homeCarouselClasses.CarouselGameLabelWrapper} > div > div { /* this is bleh */
        overflow: visible;
      }
      /* parent container of .sgdb-carousel-logo-container */
      .${homeCarouselClasses.CarouselGameLabelWrapper} .${miscInfoClasses.Content} {
        width: 100%; /* full width of capsule box so logo can be centered */
      }
      .sgdb-carousel-logo-container {
        width: inherit; /* inherit above */
        height: 39px; /* exact height of the replaced text box on unmodified steam css */
        filter: drop-shadow(0 1px 1px #000) drop-shadow(0 4px 6px rgba(255, 255, 255, .4));
        overflow: visible;
      }
      .sgdb-carousel-logo-img {
        height: 100%;
        width: 100%;
        object-fit: contain;
        object-position: center top;
      }
    `);
    }
    else {
        removeStyle('sgdb-carousel-logo');
    }
    patch$2 = routerHook.addPatch('/library/home', (props) => {
        DFL.afterPatch(props.children, 'type', (_, ret) => {
            let cache2 = null;
            DFL.wrapReactType(ret);
            DFL.afterPatch(ret.type, 'type', (_, ret2) => {
                if (cache2) {
                    ret2 = cache2;
                    return ret2;
                }
                let cache3 = null;
                const recents = DFL.findInReactTree(ret2, (x) => x?.props && ('autoFocus' in x.props) && ('showBackground' in x.props));
                DFL.wrapReactType(recents);
                DFL.afterPatch(recents.type, 'type', (_, ret3) => {
                    cache2 = ret2;
                    if (cache3) {
                        ret3 = cache3;
                        return ret3;
                    }
                    const p = DFL.findInReactTree(ret3, (x) => x?.props?.games && x?.props.onItemFocus);
                    DFL.afterPatch(p, 'type', (_, ret4) => {
                        // const cache6: any[] = []; // cache carousel items
                        cache3 = ret3;
                        DFL.wrapReactType(ret4);
                        DFL.afterPatch(ret4.type, 'type', (_, ret5) => {
                            const carouselProps = DFL.findInReactTree(ret5, (x) => x?.nItemHeight && x?.fnItemRenderer && x?.fnGetColumnWidth);
                            const itemHeight = carouselProps.nItemHeight;
                            /*
                              Instead of hacking around with CSS to make the image square, make the featured
                              item render the portrait component by changing the `bFeatured` flag to false.
              
                              To get the first item in recents, Valve checks if the index is 0:
                                `bFeatured: 0 === t,`
                              Can't get the index of the element from `fnItemRenderer`, so we just just check if the current
                              position of the item (`nLeft`) in the carousel is leftmost (0) or out of the screen (negative float)
                            */
                            DFL.afterPatch(carouselProps, 'fnItemRenderer', (_, ret6) => {
                                if (ret6.props.nLeft <= 0 && ('bFeatured' in ret6.props)) {
                                    ret6.props.bFeatured = !matchFeatured;
                                }
                                /*
                                  Experimental logo in carousel
                                */
                                /* if (carouselLogo && ret6.type.type && ret6.props?.appid) {
                                  if (cache6[ret6.props?.appid]) {
                                    ret6 = cache6[ret6.props?.appid];
                                    return ret6;
                                  }
                                  wrapReactType(ret6);
                                  afterPatch(ret6.type, 'type', (_: Record<string, unknown>[], ret7?: any) => {
                                    const c1 = findInReactTree(ret7, (x) => x?.props && x.props.className && x.props?.style?.width && x.props?.style?.height);
                                    const c2 = findInReactTree(balls, (x) => x?.props && ('bShowAsHovered' in x.props) && ('nCarouselWidth' in x.props));
                                    const app = c2.props.app;
                                    // outside carousel?
                                    c1.props.children.splice(1, 0, (
                                      <LibraryImage
                                        app={app}
                                        className="sgdb-carousel-logo-container"
                                        imageClassName="sgdb-carousel-logo-img"
                                        eAssetType={ASSET_TYPE.logo}
                                        allowCustomization={false}
                                        backgroundType="transparent"
                                        neverShowTitle={false}
                                        bShortDisplay
                                      />
                                    ));
                                    // replace the text inside the marquee
                                    wrapReactType(c2);
                                    afterPatch(c2.type, 'type', (_: Record<string, unknown>[], ret8?: any) => {
                                      if (ret8) {
                                        // console.log(ret8);
                                        ret8.props.children.props.children[0].props.message = (
                                          <LibraryImage
                                            app={app}
                                            className="sgdb-carousel-logo-container"
                                            imageClassName="sgdb-carousel-logo-img"
                                            eAssetType={ASSET_TYPE.logo}
                                            allowCustomization={false}
                                            backgroundType="transparent"
                                            neverShowTitle={false}
                                            bShortDisplay
                                          />
                                        );
                                      }
                                      return ret8;
                                    });
                                    return ret7;
                                  });
                                  cache6[ret6.props?.appid] = ret6;
                                }
                                */
                                return ret6;
                            });
                            /* Unminified version of `fnGetColumnWidth`:
                              if (index === 0 && showFeaturedItem) {
                                return (690 / 215) * nItemWidth;
                              } else if (games[index] === 0) { // not so sure about this
                                return 10;
                              } else {
                                return nItemWidth;
                              }
                            */
                            let siblingWidth = 0;
                            DFL.afterPatch(carouselProps, 'fnGetColumnWidth', ([index], colWidth) => {
                                if (index === 1) {
                                    siblingWidth = colWidth;
                                }
                                return colWidth;
                            });
                            DFL.replacePatch(carouselProps, 'fnGetColumnWidth', ([index]) => {
                                // Leave horizontal grid as wide
                                if (index === 0 && !matchFeatured)
                                    return DFL.callOriginal;
                                /* this is how valve does it -.-
                                  height: a - parseInt(or().LabelHeight)
                                */
                                const capsuleHeight = itemHeight - parseInt(homeCarouselClasses.LabelHeight);
                                if (square)
                                    return capsuleHeight;
                                return siblingWidth ? siblingWidth : calculateDefaultCapsuleWidth(capsuleHeight);
                            });
                            return ret5;
                        });
                        return ret4;
                    });
                    return ret3;
                });
                return ret2;
            });
            return ret;
        });
        return props;
    });
    // ? Always rerender bc onMount users land here too.
    // rerenderAfterPatchUpdate();
    if (!mounting)
        rerenderAfterPatchUpdate();
};
function removeHomePatch(unmounting = false) {
    if (patch$2) {
        DFL.findSP().window.document.getElementById('sgdb-square-capsules-home')?.remove();
        routerHook.removePatch('/library/home', patch$2);
        patch$2 = undefined;
        if (!unmounting)
            rerenderAfterPatchUpdate();
    }
}

let patch$1;
const patchGridProps = (props) => {
    const gridProps = DFL.findInTree(props, (x) => x?.childWidth, { walkable: ['props', 'children', 'childSections'] });
    if (gridProps) {
        gridProps.childHeight = gridProps.childWidth;
    }
};
const addSquareLibraryPatch = (mounting = false) => {
    patch$1 = routerHook.addPatch('/library', (props) => {
        // inject css if it isn't there already
        addStyle('sgdb-square-capsules-library', `
      /* only select covers within library page, otherwise it breaks covers on other pages */
      .${gamepadLibraryClasses.GamepadLibrary} .${libraryAssetImageClasses.Container}.${libraryAssetImageClasses.PortraitImage} {
        padding-top: 100% !important;
        height: 0 !important;
      }
    `);
        // lmao fuck is this
        DFL.afterPatch(props.children, 'type', (_, ret) => {
            // console.info('ret', ret);
            let cache = null;
            DFL.afterPatch(ret, 'type', (_, ret2) => {
                if (cache) {
                    ret2.type = cache;
                    return ret2;
                }
                DFL.wrapReactType(ret2);
                DFL.afterPatch(ret2.type, 'type', (_, ret3) => {
                    cache = ret2.type;
                    // console.info('ret3', ret3);
                    const { tabs, activeTab } = DFL.findInReactTree(ret3, (x) => x?.tabs && x?.activeTab);
                    const tab = tabs.find((x) => x.id == activeTab);
                    console.info('tab', tab);
                    if (tab.content.props?.collectionid === null) { // this is null if on the base collections page
                        return ret3;
                    }
                    if (tab.content.props.children || tab.content.props.collection || tab.content.type) { // All games, non-steam, collections
                        const collection = tab.content.props?.children || tab.content;
                        // console.info('collection', collection);
                        DFL.wrapReactType(collection.type);
                        DFL.afterPatch(collection, 'type', (_, ret4) => {
                            // console.info('ret4', ret4);
                            if (!ret4)
                                return ret4;
                            const p1 = DFL.findInReactTree(ret4, (x) => x?.type && x.props?.appOverviews);
                            console.log('p1', p1);
                            if (p1 && collection) {
                                DFL.afterPatch(p1, 'type', (_, ret5) => {
                                    // console.info('ret5', ret5);
                                    patchGridProps(ret5);
                                    return ret5;
                                });
                            }
                            else if (DFL.findInReactTree(ret4.props.children, (x) => x?.type && x.type.toString().includes('coverSize'))) {
                                // ignore collections page
                                // console.info('collections page');
                                return ret4;
                            }
                            else {
                                // console.info('ret4 sc', ret4);
                                console.info('ret4', ret4);
                                if (ret4.props.children[0].props?.collectionid) {
                                    // collections
                                    DFL.afterPatch(ret4.props.children[0], 'type', (_, ret5) => {
                                        // console.info('ret5 c', ret5);
                                        DFL.afterPatch(DFL.findInReactTree(ret5, (x) => x?.type && x.props?.collection?.id), 'type', (_, ret6) => {
                                            // console.info('ret6 c', ret6);
                                            DFL.afterPatch(DFL.findInReactTree(ret6, (x) => x?.type && x.props?.appOverviews), 'type', (_, ret7) => {
                                                // console.info('ret7 c', ret7);
                                                patchGridProps(ret7);
                                                return ret7;
                                            });
                                            return ret6;
                                        });
                                        return ret5;
                                    });
                                }
                                else {
                                    // non-steam shortcuts
                                    const p2 = DFL.findInReactTree(ret4, (x) => x?.type && x.props?.collection?.id === 'deck-desktop-apps');
                                    DFL.afterPatch(p2, 'type', (_, ret5) => {
                                        // console.info('ret5 s', ret5);
                                        DFL.afterPatch(DFL.findInReactTree(ret5, (x) => x?.type && x.props?.appOverviews), 'type', (_, ret6) => {
                                            // console.info('ret6 s', ret6);
                                            patchGridProps(ret6);
                                            return ret6;
                                        });
                                        return ret5;
                                    });
                                }
                            }
                            return ret4;
                        });
                    }
                    return ret3;
                });
                return ret2;
            });
            return ret;
        });
        return props;
    });
    if (!mounting)
        rerenderAfterPatchUpdate();
};
function removeSquareLibraryPatch(unmounting = false) {
    if (patch$1) {
        DFL.findSP().window.document.getElementById('sgdb-square-capsules-library')?.remove();
        routerHook.removePatch('/library', patch$1);
        patch$1 = undefined;
        if (!unmounting)
            rerenderAfterPatchUpdate();
    }
}

const addCapsuleGlowPatch = (glowAmount) => {
    if (!appgridClasses?.LibraryImageBackgroundGlow)
        return;
    updateStyle('sgdb-capsule-glow', `
    .${appportraitClasses.HoversEnabled}:hover > .${appgridClasses.LibraryImageBackgroundGlow},
    .${appportraitClasses.HoversEnabled}.gpfocuswithin > .${appgridClasses.LibraryImageBackgroundGlow},

    /* old steam */
    .${appportraitClasses.HoversEnabled}:hover + .${appgridClasses.LibraryImageBackgroundGlow},
    .${appportraitClasses.HoversEnabled}.gpfocuswithin + .${appgridClasses.LibraryImageBackgroundGlow} {
      opacity: ${glowAmount / 100} !important;
    }
  `);
};

/* eslint-disable vars-on-top, no-var, prefer-template */

var isRegExp = function (re) { 
  return re instanceof RegExp;
};
var escapeRegExp = function escapeRegExp(string) {
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g,
    reHasRegExpChar = RegExp(reRegExpChar.source);

  return (string && reHasRegExpChar.test(string))
    ? string.replace(reRegExpChar, '\\$&')
    : string;
};
var isString = function (value) {
  return typeof value === 'string';
};
var flatten = function (array) {
  var newArray = [];

  array.forEach(function (item) {
    if (Array.isArray(item)) {
      newArray = newArray.concat(item);
    } else {
      newArray.push(item);
    }
  });

  return newArray;
};

/**
 * Given a string, replace every substring that is matched by the `match` regex
 * with the result of calling `fn` on matched substring. The result will be an
 * array with all odd indexed elements containing the replacements. The primary
 * use case is similar to using String.prototype.replace except for React.
 *
 * React will happily render an array as children of a react element, which
 * makes this approach very useful for tasks like surrounding certain text
 * within a string with react elements.
 *
 * Example:
 * matchReplace(
 *   'Emphasize all phone numbers like 884-555-4443.',
 *   /([\d|-]+)/g,
 *   (number, i) => <strong key={i}>{number}</strong>
 * );
 * // => ['Emphasize all phone numbers like ', <strong>884-555-4443</strong>, '.'
 *
 * @param {string} str
 * @param {RegExp|str} match Must contain a matching group
 * @param {function} fn
 * @return {array}
 */
function replaceString(str, match, fn) {
  var curCharStart = 0;
  var curCharLen = 0;

  if (str === '') {
    return str;
  } else if (!str || !isString(str)) {
    throw new TypeError('First argument to react-string-replace#replaceString must be a string');
  }

  var re = match;

  if (!isRegExp(re)) {
    re = new RegExp('(' + escapeRegExp(re) + ')', 'gi');
  }

  var result = str.split(re);

  // Apply fn to all odd elements
  for (var i = 1, length = result.length; i < length; i += 2) {
    /** @see {@link https://github.com/iansinnott/react-string-replace/issues/74} */
    if (result[i] === undefined || result[i - 1] === undefined) {
      console.warn('reactStringReplace: Encountered undefined value during string replacement. Your RegExp may not be working the way you expect.');
      continue;
    }

    curCharLen = result[i].length;
    curCharStart += result[i - 1].length;
    result[i] = fn(result[i], i, curCharStart);
    curCharStart += curCharLen;
  }

  return result;
}

var reactStringReplace = function reactStringReplace(source, match, fn) {
  if (!Array.isArray(source)) source = [source];

  return flatten(source.map(function(x) {
    return isString(x) ? replaceString(x, match, fn) : x;
  }));
};

var reactStringReplace$1 = /*@__PURE__*/getDefaultExportFromCjs(reactStringReplace);

var HowToVideo = 'http://127.0.0.1:1337/plugins/SteamGridDB/assets/howto-24bc522f.webm';

var FooterGlyphType;
(function (FooterGlyphType) {
    FooterGlyphType[FooterGlyphType["Knockout"] = 0] = "Knockout";
    FooterGlyphType[FooterGlyphType["Light"] = 1] = "Light";
    FooterGlyphType[FooterGlyphType["Dark"] = 2] = "Dark";
})(FooterGlyphType || (FooterGlyphType = {}));
var FooterGlyphSize;
(function (FooterGlyphSize) {
    FooterGlyphSize[FooterGlyphSize["Small"] = 0] = "Small";
    FooterGlyphSize[FooterGlyphSize["Medium"] = 1] = "Medium";
    FooterGlyphSize[FooterGlyphSize["Large"] = 2] = "Large";
})(FooterGlyphSize || (FooterGlyphSize = {}));
const FooterGlyph = DFL.findModuleExport((e) => e?.toString && e.toString().includes('.Knockout') && e.toString().includes('.additionalClassName'));

const strInstructions = trans_string('MSG_USAGE_INSTRUCTIONS', 'Select a game {arrow} {optionsButton} {arrow} "{ACTION_CHANGE_ARTWORK}"')
    .replace('{ACTION_CHANGE_ARTWORK}', trans_string('ACTION_CHANGE_ARTWORK', 'Change Artwork...'));
const changeInstructions = reactStringReplace$1(reactStringReplace$1(strInstructions, '{arrow}', (_, i) => (window.SP_REACT.createElement(HiOutlineChevronRight, { key: i, strokeWidth: "4", style: { height: '0.65em' } }))), '{optionsButton}', (_, i) => (window.SP_REACT.createElement(FooterGlyph, { key: i, button: 11, type: 0, size: 0 })));
const GuideVideoField = (props) => {
    const [duration, setDuration] = SP_REACT.useState(0);
    const [progress, setProgress] = SP_REACT.useState(0);
    const handlePlay = (evt) => {
        const target = evt.target;
        setDuration(target.duration);
        setProgress(100);
    };
    const handleEnded = (evt) => {
        const target = evt.target;
        setDuration(0.4);
        setProgress(0);
        // replay after .5s
        setTimeout(() => {
            target.play();
        }, 500);
    };
    return (window.SP_REACT.createElement(DFL.Field, { padding: "none", childrenLayout: "below", childrenContainerWidth: "max", bottomSeparator: "none", description: window.SP_REACT.createElement("div", { style: {
                display: 'flex',
                alignItems: 'center',
                flexWrap: 'wrap',
            } }, changeInstructions), ...props },
        window.SP_REACT.createElement("video", { src: HowToVideo, style: { maxWidth: '100%' }, autoPlay: true, muted: true, loop: false, onPlay: handlePlay, onEnded: handleEnded }),
        window.SP_REACT.createElement(DFL.ProgressBar, { focusable: false, nProgress: progress, nTransitionSec: duration })));
};

var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};

// src/index.tsx


// src/third-party/qrcodegen/index.ts
/**
 * @license QR Code generator library (TypeScript)
 * Copyright (c) Project Nayuki.
 * SPDX-License-Identifier: MIT
 */
var qrcodegen;
((qrcodegen2) => {
  const _QrCode = class {
    constructor(version, errorCorrectionLevel, dataCodewords, msk) {
      this.version = version;
      this.errorCorrectionLevel = errorCorrectionLevel;
      this.modules = [];
      this.isFunction = [];
      if (version < _QrCode.MIN_VERSION || version > _QrCode.MAX_VERSION)
        throw new RangeError("Version value out of range");
      if (msk < -1 || msk > 7)
        throw new RangeError("Mask value out of range");
      this.size = version * 4 + 17;
      let row = [];
      for (let i = 0; i < this.size; i++)
        row.push(false);
      for (let i = 0; i < this.size; i++) {
        this.modules.push(row.slice());
        this.isFunction.push(row.slice());
      }
      this.drawFunctionPatterns();
      const allCodewords = this.addEccAndInterleave(dataCodewords);
      this.drawCodewords(allCodewords);
      if (msk == -1) {
        let minPenalty = 1e9;
        for (let i = 0; i < 8; i++) {
          this.applyMask(i);
          this.drawFormatBits(i);
          const penalty = this.getPenaltyScore();
          if (penalty < minPenalty) {
            msk = i;
            minPenalty = penalty;
          }
          this.applyMask(i);
        }
      }
      assert(0 <= msk && msk <= 7);
      this.mask = msk;
      this.applyMask(msk);
      this.drawFormatBits(msk);
      this.isFunction = [];
    }
    static encodeText(text, ecl) {
      const segs = qrcodegen2.QrSegment.makeSegments(text);
      return _QrCode.encodeSegments(segs, ecl);
    }
    static encodeBinary(data, ecl) {
      const seg = qrcodegen2.QrSegment.makeBytes(data);
      return _QrCode.encodeSegments([seg], ecl);
    }
    static encodeSegments(segs, ecl, minVersion = 1, maxVersion = 40, mask = -1, boostEcl = true) {
      if (!(_QrCode.MIN_VERSION <= minVersion && minVersion <= maxVersion && maxVersion <= _QrCode.MAX_VERSION) || mask < -1 || mask > 7)
        throw new RangeError("Invalid value");
      let version;
      let dataUsedBits;
      for (version = minVersion; ; version++) {
        const dataCapacityBits2 = _QrCode.getNumDataCodewords(version, ecl) * 8;
        const usedBits = QrSegment.getTotalBits(segs, version);
        if (usedBits <= dataCapacityBits2) {
          dataUsedBits = usedBits;
          break;
        }
        if (version >= maxVersion)
          throw new RangeError("Data too long");
      }
      for (const newEcl of [_QrCode.Ecc.MEDIUM, _QrCode.Ecc.QUARTILE, _QrCode.Ecc.HIGH]) {
        if (boostEcl && dataUsedBits <= _QrCode.getNumDataCodewords(version, newEcl) * 8)
          ecl = newEcl;
      }
      let bb = [];
      for (const seg of segs) {
        appendBits(seg.mode.modeBits, 4, bb);
        appendBits(seg.numChars, seg.mode.numCharCountBits(version), bb);
        for (const b of seg.getData())
          bb.push(b);
      }
      assert(bb.length == dataUsedBits);
      const dataCapacityBits = _QrCode.getNumDataCodewords(version, ecl) * 8;
      assert(bb.length <= dataCapacityBits);
      appendBits(0, Math.min(4, dataCapacityBits - bb.length), bb);
      appendBits(0, (8 - bb.length % 8) % 8, bb);
      assert(bb.length % 8 == 0);
      for (let padByte = 236; bb.length < dataCapacityBits; padByte ^= 236 ^ 17)
        appendBits(padByte, 8, bb);
      let dataCodewords = [];
      while (dataCodewords.length * 8 < bb.length)
        dataCodewords.push(0);
      bb.forEach((b, i) => dataCodewords[i >>> 3] |= b << 7 - (i & 7));
      return new _QrCode(version, ecl, dataCodewords, mask);
    }
    getModule(x, y) {
      return 0 <= x && x < this.size && 0 <= y && y < this.size && this.modules[y][x];
    }
    getModules() {
      return this.modules;
    }
    drawFunctionPatterns() {
      for (let i = 0; i < this.size; i++) {
        this.setFunctionModule(6, i, i % 2 == 0);
        this.setFunctionModule(i, 6, i % 2 == 0);
      }
      this.drawFinderPattern(3, 3);
      this.drawFinderPattern(this.size - 4, 3);
      this.drawFinderPattern(3, this.size - 4);
      const alignPatPos = this.getAlignmentPatternPositions();
      const numAlign = alignPatPos.length;
      for (let i = 0; i < numAlign; i++) {
        for (let j = 0; j < numAlign; j++) {
          if (!(i == 0 && j == 0 || i == 0 && j == numAlign - 1 || i == numAlign - 1 && j == 0))
            this.drawAlignmentPattern(alignPatPos[i], alignPatPos[j]);
        }
      }
      this.drawFormatBits(0);
      this.drawVersion();
    }
    drawFormatBits(mask) {
      const data = this.errorCorrectionLevel.formatBits << 3 | mask;
      let rem = data;
      for (let i = 0; i < 10; i++)
        rem = rem << 1 ^ (rem >>> 9) * 1335;
      const bits = (data << 10 | rem) ^ 21522;
      assert(bits >>> 15 == 0);
      for (let i = 0; i <= 5; i++)
        this.setFunctionModule(8, i, getBit(bits, i));
      this.setFunctionModule(8, 7, getBit(bits, 6));
      this.setFunctionModule(8, 8, getBit(bits, 7));
      this.setFunctionModule(7, 8, getBit(bits, 8));
      for (let i = 9; i < 15; i++)
        this.setFunctionModule(14 - i, 8, getBit(bits, i));
      for (let i = 0; i < 8; i++)
        this.setFunctionModule(this.size - 1 - i, 8, getBit(bits, i));
      for (let i = 8; i < 15; i++)
        this.setFunctionModule(8, this.size - 15 + i, getBit(bits, i));
      this.setFunctionModule(8, this.size - 8, true);
    }
    drawVersion() {
      if (this.version < 7)
        return;
      let rem = this.version;
      for (let i = 0; i < 12; i++)
        rem = rem << 1 ^ (rem >>> 11) * 7973;
      const bits = this.version << 12 | rem;
      assert(bits >>> 18 == 0);
      for (let i = 0; i < 18; i++) {
        const color = getBit(bits, i);
        const a = this.size - 11 + i % 3;
        const b = Math.floor(i / 3);
        this.setFunctionModule(a, b, color);
        this.setFunctionModule(b, a, color);
      }
    }
    drawFinderPattern(x, y) {
      for (let dy = -4; dy <= 4; dy++) {
        for (let dx = -4; dx <= 4; dx++) {
          const dist = Math.max(Math.abs(dx), Math.abs(dy));
          const xx = x + dx;
          const yy = y + dy;
          if (0 <= xx && xx < this.size && 0 <= yy && yy < this.size)
            this.setFunctionModule(xx, yy, dist != 2 && dist != 4);
        }
      }
    }
    drawAlignmentPattern(x, y) {
      for (let dy = -2; dy <= 2; dy++) {
        for (let dx = -2; dx <= 2; dx++)
          this.setFunctionModule(x + dx, y + dy, Math.max(Math.abs(dx), Math.abs(dy)) != 1);
      }
    }
    setFunctionModule(x, y, isDark) {
      this.modules[y][x] = isDark;
      this.isFunction[y][x] = true;
    }
    addEccAndInterleave(data) {
      const ver = this.version;
      const ecl = this.errorCorrectionLevel;
      if (data.length != _QrCode.getNumDataCodewords(ver, ecl))
        throw new RangeError("Invalid argument");
      const numBlocks = _QrCode.NUM_ERROR_CORRECTION_BLOCKS[ecl.ordinal][ver];
      const blockEccLen = _QrCode.ECC_CODEWORDS_PER_BLOCK[ecl.ordinal][ver];
      const rawCodewords = Math.floor(_QrCode.getNumRawDataModules(ver) / 8);
      const numShortBlocks = numBlocks - rawCodewords % numBlocks;
      const shortBlockLen = Math.floor(rawCodewords / numBlocks);
      let blocks = [];
      const rsDiv = _QrCode.reedSolomonComputeDivisor(blockEccLen);
      for (let i = 0, k = 0; i < numBlocks; i++) {
        let dat = data.slice(k, k + shortBlockLen - blockEccLen + (i < numShortBlocks ? 0 : 1));
        k += dat.length;
        const ecc = _QrCode.reedSolomonComputeRemainder(dat, rsDiv);
        if (i < numShortBlocks)
          dat.push(0);
        blocks.push(dat.concat(ecc));
      }
      let result = [];
      for (let i = 0; i < blocks[0].length; i++) {
        blocks.forEach((block, j) => {
          if (i != shortBlockLen - blockEccLen || j >= numShortBlocks)
            result.push(block[i]);
        });
      }
      assert(result.length == rawCodewords);
      return result;
    }
    drawCodewords(data) {
      if (data.length != Math.floor(_QrCode.getNumRawDataModules(this.version) / 8))
        throw new RangeError("Invalid argument");
      let i = 0;
      for (let right = this.size - 1; right >= 1; right -= 2) {
        if (right == 6)
          right = 5;
        for (let vert = 0; vert < this.size; vert++) {
          for (let j = 0; j < 2; j++) {
            const x = right - j;
            const upward = (right + 1 & 2) == 0;
            const y = upward ? this.size - 1 - vert : vert;
            if (!this.isFunction[y][x] && i < data.length * 8) {
              this.modules[y][x] = getBit(data[i >>> 3], 7 - (i & 7));
              i++;
            }
          }
        }
      }
      assert(i == data.length * 8);
    }
    applyMask(mask) {
      if (mask < 0 || mask > 7)
        throw new RangeError("Mask value out of range");
      for (let y = 0; y < this.size; y++) {
        for (let x = 0; x < this.size; x++) {
          let invert;
          switch (mask) {
            case 0:
              invert = (x + y) % 2 == 0;
              break;
            case 1:
              invert = y % 2 == 0;
              break;
            case 2:
              invert = x % 3 == 0;
              break;
            case 3:
              invert = (x + y) % 3 == 0;
              break;
            case 4:
              invert = (Math.floor(x / 3) + Math.floor(y / 2)) % 2 == 0;
              break;
            case 5:
              invert = x * y % 2 + x * y % 3 == 0;
              break;
            case 6:
              invert = (x * y % 2 + x * y % 3) % 2 == 0;
              break;
            case 7:
              invert = ((x + y) % 2 + x * y % 3) % 2 == 0;
              break;
            default:
              throw new Error("Unreachable");
          }
          if (!this.isFunction[y][x] && invert)
            this.modules[y][x] = !this.modules[y][x];
        }
      }
    }
    getPenaltyScore() {
      let result = 0;
      for (let y = 0; y < this.size; y++) {
        let runColor = false;
        let runX = 0;
        let runHistory = [0, 0, 0, 0, 0, 0, 0];
        for (let x = 0; x < this.size; x++) {
          if (this.modules[y][x] == runColor) {
            runX++;
            if (runX == 5)
              result += _QrCode.PENALTY_N1;
            else if (runX > 5)
              result++;
          } else {
            this.finderPenaltyAddHistory(runX, runHistory);
            if (!runColor)
              result += this.finderPenaltyCountPatterns(runHistory) * _QrCode.PENALTY_N3;
            runColor = this.modules[y][x];
            runX = 1;
          }
        }
        result += this.finderPenaltyTerminateAndCount(runColor, runX, runHistory) * _QrCode.PENALTY_N3;
      }
      for (let x = 0; x < this.size; x++) {
        let runColor = false;
        let runY = 0;
        let runHistory = [0, 0, 0, 0, 0, 0, 0];
        for (let y = 0; y < this.size; y++) {
          if (this.modules[y][x] == runColor) {
            runY++;
            if (runY == 5)
              result += _QrCode.PENALTY_N1;
            else if (runY > 5)
              result++;
          } else {
            this.finderPenaltyAddHistory(runY, runHistory);
            if (!runColor)
              result += this.finderPenaltyCountPatterns(runHistory) * _QrCode.PENALTY_N3;
            runColor = this.modules[y][x];
            runY = 1;
          }
        }
        result += this.finderPenaltyTerminateAndCount(runColor, runY, runHistory) * _QrCode.PENALTY_N3;
      }
      for (let y = 0; y < this.size - 1; y++) {
        for (let x = 0; x < this.size - 1; x++) {
          const color = this.modules[y][x];
          if (color == this.modules[y][x + 1] && color == this.modules[y + 1][x] && color == this.modules[y + 1][x + 1])
            result += _QrCode.PENALTY_N2;
        }
      }
      let dark = 0;
      for (const row of this.modules)
        dark = row.reduce((sum, color) => sum + (color ? 1 : 0), dark);
      const total = this.size * this.size;
      const k = Math.ceil(Math.abs(dark * 20 - total * 10) / total) - 1;
      assert(0 <= k && k <= 9);
      result += k * _QrCode.PENALTY_N4;
      assert(0 <= result && result <= 2568888);
      return result;
    }
    getAlignmentPatternPositions() {
      if (this.version == 1)
        return [];
      else {
        const numAlign = Math.floor(this.version / 7) + 2;
        const step = this.version == 32 ? 26 : Math.ceil((this.version * 4 + 4) / (numAlign * 2 - 2)) * 2;
        let result = [6];
        for (let pos = this.size - 7; result.length < numAlign; pos -= step)
          result.splice(1, 0, pos);
        return result;
      }
    }
    static getNumRawDataModules(ver) {
      if (ver < _QrCode.MIN_VERSION || ver > _QrCode.MAX_VERSION)
        throw new RangeError("Version number out of range");
      let result = (16 * ver + 128) * ver + 64;
      if (ver >= 2) {
        const numAlign = Math.floor(ver / 7) + 2;
        result -= (25 * numAlign - 10) * numAlign - 55;
        if (ver >= 7)
          result -= 36;
      }
      assert(208 <= result && result <= 29648);
      return result;
    }
    static getNumDataCodewords(ver, ecl) {
      return Math.floor(_QrCode.getNumRawDataModules(ver) / 8) - _QrCode.ECC_CODEWORDS_PER_BLOCK[ecl.ordinal][ver] * _QrCode.NUM_ERROR_CORRECTION_BLOCKS[ecl.ordinal][ver];
    }
    static reedSolomonComputeDivisor(degree) {
      if (degree < 1 || degree > 255)
        throw new RangeError("Degree out of range");
      let result = [];
      for (let i = 0; i < degree - 1; i++)
        result.push(0);
      result.push(1);
      let root = 1;
      for (let i = 0; i < degree; i++) {
        for (let j = 0; j < result.length; j++) {
          result[j] = _QrCode.reedSolomonMultiply(result[j], root);
          if (j + 1 < result.length)
            result[j] ^= result[j + 1];
        }
        root = _QrCode.reedSolomonMultiply(root, 2);
      }
      return result;
    }
    static reedSolomonComputeRemainder(data, divisor) {
      let result = divisor.map((_) => 0);
      for (const b of data) {
        const factor = b ^ result.shift();
        result.push(0);
        divisor.forEach((coef, i) => result[i] ^= _QrCode.reedSolomonMultiply(coef, factor));
      }
      return result;
    }
    static reedSolomonMultiply(x, y) {
      if (x >>> 8 != 0 || y >>> 8 != 0)
        throw new RangeError("Byte out of range");
      let z = 0;
      for (let i = 7; i >= 0; i--) {
        z = z << 1 ^ (z >>> 7) * 285;
        z ^= (y >>> i & 1) * x;
      }
      assert(z >>> 8 == 0);
      return z;
    }
    finderPenaltyCountPatterns(runHistory) {
      const n = runHistory[1];
      assert(n <= this.size * 3);
      const core = n > 0 && runHistory[2] == n && runHistory[3] == n * 3 && runHistory[4] == n && runHistory[5] == n;
      return (core && runHistory[0] >= n * 4 && runHistory[6] >= n ? 1 : 0) + (core && runHistory[6] >= n * 4 && runHistory[0] >= n ? 1 : 0);
    }
    finderPenaltyTerminateAndCount(currentRunColor, currentRunLength, runHistory) {
      if (currentRunColor) {
        this.finderPenaltyAddHistory(currentRunLength, runHistory);
        currentRunLength = 0;
      }
      currentRunLength += this.size;
      this.finderPenaltyAddHistory(currentRunLength, runHistory);
      return this.finderPenaltyCountPatterns(runHistory);
    }
    finderPenaltyAddHistory(currentRunLength, runHistory) {
      if (runHistory[0] == 0)
        currentRunLength += this.size;
      runHistory.pop();
      runHistory.unshift(currentRunLength);
    }
  };
  let QrCode = _QrCode;
  QrCode.MIN_VERSION = 1;
  QrCode.MAX_VERSION = 40;
  QrCode.PENALTY_N1 = 3;
  QrCode.PENALTY_N2 = 3;
  QrCode.PENALTY_N3 = 40;
  QrCode.PENALTY_N4 = 10;
  QrCode.ECC_CODEWORDS_PER_BLOCK = [
    [-1, 7, 10, 15, 20, 26, 18, 20, 24, 30, 18, 20, 24, 26, 30, 22, 24, 28, 30, 28, 28, 28, 28, 30, 30, 26, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30],
    [-1, 10, 16, 26, 18, 24, 16, 18, 22, 22, 26, 30, 22, 22, 24, 24, 28, 28, 26, 26, 26, 26, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28],
    [-1, 13, 22, 18, 26, 18, 24, 18, 22, 20, 24, 28, 26, 24, 20, 30, 24, 28, 28, 26, 30, 28, 30, 30, 30, 30, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30],
    [-1, 17, 28, 22, 16, 22, 28, 26, 26, 24, 28, 24, 28, 22, 24, 24, 30, 28, 28, 26, 28, 30, 24, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30]
  ];
  QrCode.NUM_ERROR_CORRECTION_BLOCKS = [
    [-1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 4, 4, 4, 4, 4, 6, 6, 6, 6, 7, 8, 8, 9, 9, 10, 12, 12, 12, 13, 14, 15, 16, 17, 18, 19, 19, 20, 21, 22, 24, 25],
    [-1, 1, 1, 1, 2, 2, 4, 4, 4, 5, 5, 5, 8, 9, 9, 10, 10, 11, 13, 14, 16, 17, 17, 18, 20, 21, 23, 25, 26, 28, 29, 31, 33, 35, 37, 38, 40, 43, 45, 47, 49],
    [-1, 1, 1, 2, 2, 4, 4, 6, 6, 8, 8, 8, 10, 12, 16, 12, 17, 16, 18, 21, 20, 23, 23, 25, 27, 29, 34, 34, 35, 38, 40, 43, 45, 48, 51, 53, 56, 59, 62, 65, 68],
    [-1, 1, 1, 2, 4, 4, 4, 5, 6, 8, 8, 11, 11, 16, 16, 18, 16, 19, 21, 25, 25, 25, 34, 30, 32, 35, 37, 40, 42, 45, 48, 51, 54, 57, 60, 63, 66, 70, 74, 77, 81]
  ];
  qrcodegen2.QrCode = QrCode;
  function appendBits(val, len, bb) {
    if (len < 0 || len > 31 || val >>> len != 0)
      throw new RangeError("Value out of range");
    for (let i = len - 1; i >= 0; i--)
      bb.push(val >>> i & 1);
  }
  function getBit(x, i) {
    return (x >>> i & 1) != 0;
  }
  function assert(cond) {
    if (!cond)
      throw new Error("Assertion error");
  }
  const _QrSegment = class {
    constructor(mode, numChars, bitData) {
      this.mode = mode;
      this.numChars = numChars;
      this.bitData = bitData;
      if (numChars < 0)
        throw new RangeError("Invalid argument");
      this.bitData = bitData.slice();
    }
    static makeBytes(data) {
      let bb = [];
      for (const b of data)
        appendBits(b, 8, bb);
      return new _QrSegment(_QrSegment.Mode.BYTE, data.length, bb);
    }
    static makeNumeric(digits) {
      if (!_QrSegment.isNumeric(digits))
        throw new RangeError("String contains non-numeric characters");
      let bb = [];
      for (let i = 0; i < digits.length; ) {
        const n = Math.min(digits.length - i, 3);
        appendBits(parseInt(digits.substr(i, n), 10), n * 3 + 1, bb);
        i += n;
      }
      return new _QrSegment(_QrSegment.Mode.NUMERIC, digits.length, bb);
    }
    static makeAlphanumeric(text) {
      if (!_QrSegment.isAlphanumeric(text))
        throw new RangeError("String contains unencodable characters in alphanumeric mode");
      let bb = [];
      let i;
      for (i = 0; i + 2 <= text.length; i += 2) {
        let temp = _QrSegment.ALPHANUMERIC_CHARSET.indexOf(text.charAt(i)) * 45;
        temp += _QrSegment.ALPHANUMERIC_CHARSET.indexOf(text.charAt(i + 1));
        appendBits(temp, 11, bb);
      }
      if (i < text.length)
        appendBits(_QrSegment.ALPHANUMERIC_CHARSET.indexOf(text.charAt(i)), 6, bb);
      return new _QrSegment(_QrSegment.Mode.ALPHANUMERIC, text.length, bb);
    }
    static makeSegments(text) {
      if (text == "")
        return [];
      else if (_QrSegment.isNumeric(text))
        return [_QrSegment.makeNumeric(text)];
      else if (_QrSegment.isAlphanumeric(text))
        return [_QrSegment.makeAlphanumeric(text)];
      else
        return [_QrSegment.makeBytes(_QrSegment.toUtf8ByteArray(text))];
    }
    static makeEci(assignVal) {
      let bb = [];
      if (assignVal < 0)
        throw new RangeError("ECI assignment value out of range");
      else if (assignVal < 1 << 7)
        appendBits(assignVal, 8, bb);
      else if (assignVal < 1 << 14) {
        appendBits(2, 2, bb);
        appendBits(assignVal, 14, bb);
      } else if (assignVal < 1e6) {
        appendBits(6, 3, bb);
        appendBits(assignVal, 21, bb);
      } else
        throw new RangeError("ECI assignment value out of range");
      return new _QrSegment(_QrSegment.Mode.ECI, 0, bb);
    }
    static isNumeric(text) {
      return _QrSegment.NUMERIC_REGEX.test(text);
    }
    static isAlphanumeric(text) {
      return _QrSegment.ALPHANUMERIC_REGEX.test(text);
    }
    getData() {
      return this.bitData.slice();
    }
    static getTotalBits(segs, version) {
      let result = 0;
      for (const seg of segs) {
        const ccbits = seg.mode.numCharCountBits(version);
        if (seg.numChars >= 1 << ccbits)
          return Infinity;
        result += 4 + ccbits + seg.bitData.length;
      }
      return result;
    }
    static toUtf8ByteArray(str) {
      str = encodeURI(str);
      let result = [];
      for (let i = 0; i < str.length; i++) {
        if (str.charAt(i) != "%")
          result.push(str.charCodeAt(i));
        else {
          result.push(parseInt(str.substr(i + 1, 2), 16));
          i += 2;
        }
      }
      return result;
    }
  };
  let QrSegment = _QrSegment;
  QrSegment.NUMERIC_REGEX = /^[0-9]*$/;
  QrSegment.ALPHANUMERIC_REGEX = /^[A-Z0-9 $%*+.\/:-]*$/;
  QrSegment.ALPHANUMERIC_CHARSET = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:";
  qrcodegen2.QrSegment = QrSegment;
})(qrcodegen || (qrcodegen = {}));
((qrcodegen2) => {
  ((QrCode2) => {
    const _Ecc = class {
      constructor(ordinal, formatBits) {
        this.ordinal = ordinal;
        this.formatBits = formatBits;
      }
    };
    let Ecc = _Ecc;
    Ecc.LOW = new _Ecc(0, 1);
    Ecc.MEDIUM = new _Ecc(1, 0);
    Ecc.QUARTILE = new _Ecc(2, 3);
    Ecc.HIGH = new _Ecc(3, 2);
    QrCode2.Ecc = Ecc;
  })(qrcodegen2.QrCode || (qrcodegen2.QrCode = {}));
})(qrcodegen || (qrcodegen = {}));
((qrcodegen2) => {
  ((QrSegment2) => {
    const _Mode = class {
      constructor(modeBits, numBitsCharCount) {
        this.modeBits = modeBits;
        this.numBitsCharCount = numBitsCharCount;
      }
      numCharCountBits(ver) {
        return this.numBitsCharCount[Math.floor((ver + 7) / 17)];
      }
    };
    let Mode = _Mode;
    Mode.NUMERIC = new _Mode(1, [10, 12, 14]);
    Mode.ALPHANUMERIC = new _Mode(2, [9, 11, 13]);
    Mode.BYTE = new _Mode(4, [8, 16, 16]);
    Mode.KANJI = new _Mode(8, [8, 10, 12]);
    Mode.ECI = new _Mode(7, [0, 0, 0]);
    QrSegment2.Mode = Mode;
  })(qrcodegen2.QrSegment || (qrcodegen2.QrSegment = {}));
})(qrcodegen || (qrcodegen = {}));
var qrcodegen_default = qrcodegen;

// src/index.tsx
/**
 * @license qrcode.react
 * Copyright (c) Paul O'Shannessy
 * SPDX-License-Identifier: ISC
 */
var ERROR_LEVEL_MAP = {
  L: qrcodegen_default.QrCode.Ecc.LOW,
  M: qrcodegen_default.QrCode.Ecc.MEDIUM,
  Q: qrcodegen_default.QrCode.Ecc.QUARTILE,
  H: qrcodegen_default.QrCode.Ecc.HIGH
};
var DEFAULT_SIZE = 128;
var DEFAULT_LEVEL = "L";
var DEFAULT_BGCOLOR = "#FFFFFF";
var DEFAULT_FGCOLOR = "#000000";
var DEFAULT_INCLUDEMARGIN = false;
var MARGIN_SIZE = 4;
var DEFAULT_IMG_SCALE = 0.1;
function generatePath(modules, margin = 0) {
  const ops = [];
  modules.forEach(function(row, y) {
    let start = null;
    row.forEach(function(cell, x) {
      if (!cell && start !== null) {
        ops.push(`M${start + margin} ${y + margin}h${x - start}v1H${start + margin}z`);
        start = null;
        return;
      }
      if (x === row.length - 1) {
        if (!cell) {
          return;
        }
        if (start === null) {
          ops.push(`M${x + margin},${y + margin} h1v1H${x + margin}z`);
        } else {
          ops.push(`M${start + margin},${y + margin} h${x + 1 - start}v1H${start + margin}z`);
        }
        return;
      }
      if (cell && start === null) {
        start = x;
      }
    });
  });
  return ops.join("");
}
function excavateModules(modules, excavation) {
  return modules.slice().map((row, y) => {
    if (y < excavation.y || y >= excavation.y + excavation.h) {
      return row;
    }
    return row.map((cell, x) => {
      if (x < excavation.x || x >= excavation.x + excavation.w) {
        return cell;
      }
      return false;
    });
  });
}
function getImageSettings(cells, size, includeMargin, imageSettings) {
  if (imageSettings == null) {
    return null;
  }
  const margin = includeMargin ? MARGIN_SIZE : 0;
  const numCells = cells.length + margin * 2;
  const defaultSize = Math.floor(size * DEFAULT_IMG_SCALE);
  const scale = numCells / size;
  const w = (imageSettings.width || defaultSize) * scale;
  const h = (imageSettings.height || defaultSize) * scale;
  const x = imageSettings.x == null ? cells.length / 2 - w / 2 : imageSettings.x * scale;
  const y = imageSettings.y == null ? cells.length / 2 - h / 2 : imageSettings.y * scale;
  let excavation = null;
  if (imageSettings.excavate) {
    let floorX = Math.floor(x);
    let floorY = Math.floor(y);
    let ceilW = Math.ceil(w + x - floorX);
    let ceilH = Math.ceil(h + y - floorY);
    excavation = { x: floorX, y: floorY, w: ceilW, h: ceilH };
  }
  return { x, y, h, w, excavation };
}
(function() {
  try {
    new Path2D().addPath(new Path2D());
  } catch (e) {
    return false;
  }
  return true;
})();
function QRCodeSVG(props) {
  const _a = props, {
    value,
    size = DEFAULT_SIZE,
    level = DEFAULT_LEVEL,
    bgColor = DEFAULT_BGCOLOR,
    fgColor = DEFAULT_FGCOLOR,
    includeMargin = DEFAULT_INCLUDEMARGIN,
    imageSettings
  } = _a, otherProps = __objRest(_a, [
    "value",
    "size",
    "level",
    "bgColor",
    "fgColor",
    "includeMargin",
    "imageSettings"
  ]);
  let cells = qrcodegen_default.QrCode.encodeText(value, ERROR_LEVEL_MAP[level]).getModules();
  const margin = includeMargin ? MARGIN_SIZE : 0;
  const numCells = cells.length + margin * 2;
  const calculatedImageSettings = getImageSettings(cells, size, includeMargin, imageSettings);
  let image = null;
  if (imageSettings != null && calculatedImageSettings != null) {
    if (calculatedImageSettings.excavation != null) {
      cells = excavateModules(cells, calculatedImageSettings.excavation);
    }
    image = /* @__PURE__ */ SP_REACT.createElement("image", {
      xlinkHref: imageSettings.src,
      height: calculatedImageSettings.h,
      width: calculatedImageSettings.w,
      x: calculatedImageSettings.x + margin,
      y: calculatedImageSettings.y + margin,
      preserveAspectRatio: "none"
    });
  }
  const fgPath = generatePath(cells, margin);
  return /* @__PURE__ */ SP_REACT.createElement("svg", __spreadValues({
    height: size,
    width: size,
    viewBox: `0 0 ${numCells} ${numCells}`
  }, otherProps), /* @__PURE__ */ SP_REACT.createElement("path", {
    fill: bgColor,
    d: `M0,0 h${numCells}v${numCells}H0z`,
    shapeRendering: "crispEdges"
  }), /* @__PURE__ */ SP_REACT.createElement("path", {
    fill: fgColor,
    d: fgPath,
    shapeRendering: "crispEdges"
  }), image);
}

const showQrModal = (url) => {
    DFL.showModal(window.SP_REACT.createElement(DFL.ModalRoot, null,
        window.SP_REACT.createElement(QRCodeSVG, { style: { margin: '0 auto 1.5em auto' }, value: url, includeMargin: true, size: 256 }),
        window.SP_REACT.createElement("span", { style: { textAlign: 'center', wordBreak: 'break-word' } }, url)), window);
};

const navLink = (url) => {
    DFL.Navigation.CloseSideMenus();
    DFL.Navigation.NavigateToExternalWeb(url);
};
/**
 * Panel row with a button next to an icon.
 */
const PanelSocialButton = ({ icon, children, url }) => (window.SP_REACT.createElement(DFL.PanelSectionRow, null,
    window.SP_REACT.createElement(DFL.Field, { bottomSeparator: "none", icon: null, label: null, childrenLayout: undefined, inlineWrap: "keep-inline", padding: "none", spacingBetweenLabelAndChild: "none", childrenContainerWidth: "max" },
        window.SP_REACT.createElement(DFL.Focusable, { style: { display: 'flex' } },
            window.SP_REACT.createElement("div", { style: {
                    display: 'flex',
                    fontSize: '1.5em',
                    justifyContent: 'center',
                    alignItems: 'center',
                    marginRight: '.5em',
                } }, icon),
            window.SP_REACT.createElement(DFL.DialogButton, { onClick: () => navLink(url), onSecondaryButton: () => showQrModal(url), onSecondaryActionDescription: trans_string('ACTION_SHOW_LINK_QR', 'Show Link QR'), style: {
                    padding: '10px',
                    fontSize: '14px',
                } }, children),
            window.SP_REACT.createElement(DFL.DialogButton, { onOKActionDescription: trans_string('ACTION_SHOW_LINK_QR', 'Show Link QR'), onClick: () => showQrModal(url), style: {
                    display: 'flex',
                    justifyContent: 'center',
                    alignItems: 'center',
                    padding: '10px',
                    maxWidth: '40px',
                    minWidth: 'auto',
                    marginLeft: '.5em',
                } },
                window.SP_REACT.createElement(HiQrCode, null))))));

const tabSettingsDesc = trans_string('MSG_ASSET_TAB_SETTINGS_DESC', 'Reorder or hide unused tabs, and set the default tab that opens when using "{ACTION_CHANGE_ARTWORK}"').replace('{ACTION_CHANGE_ARTWORK}', trans_string('ACTION_CHANGE_ARTWORK', 'Change Artwork...'));
const squareGridSizes = DIMENSIONS.grid_p.options.filter((x) => {
    const [w, h] = x.value.split('x');
    return w === h;
}).map((x) => x.value);
// Set square/uniform featured game using logic written at 3am
const setPatches = (squares, uniformFeatured) => {
    if (!uniformFeatured && !squares) {
        removeHomePatch();
    }
    else if (squares || uniformFeatured) {
        // Remove the home patch then patch it again
        removeHomePatch();
        addHomePatch(false, squares, uniformFeatured);
        if (squares) {
            addSquareLibraryPatch();
        }
    }
    if (!squares) {
        removeSquareLibraryPatch();
    }
};
const QuickAccessSettings = () => {
    const { get, set } = useSettings();
    const [useCount, setUseCount] = SP_REACT.useState(null);
    const [squares, setSquares] = SP_REACT.useState(false);
    const [uniformFeatured, setUniformFeatured] = SP_REACT.useState(false);
    const [motdToggle, setMotdToggle] = SP_REACT.useState(false);
    const [capsuleGlowAmount, setCapsuleGlowAmount] = SP_REACT.useState(100);
    SP_REACT.useState('70');
    const handleMotdToggle = SP_REACT.useCallback(async (val) => {
        set('motd_hidden_global', val, true);
        setMotdToggle(val);
    }, [set]);
    const handleSquareToggle = SP_REACT.useCallback(async (checked) => {
        set('squares', checked, true);
        setSquares(checked);
        setPatches(checked, uniformFeatured);
        const currentFilters = await get('filters_grid_p', {});
        if (checked) {
            // only enable square
            currentFilters['dimensions'] = squareGridSizes;
        }
        else {
            // set to default
            currentFilters['dimensions'] = DIMENSIONS.grid_p.default;
        }
        set('filters_grid_p', currentFilters, true);
    }, [get, set, uniformFeatured]);
    const handleUniformFeaturedToggle = SP_REACT.useCallback(async (checked) => {
        set('uniform_featured', checked, true);
        setUniformFeatured(checked);
        setPatches(squares, checked);
    }, [set, squares]);
    const handleCapsuleGlowChange = SP_REACT.useCallback(async (val) => {
        set('capsule_glow_amount', val, true);
        addCapsuleGlowPatch(val);
        setCapsuleGlowAmount(val);
    }, [set]);
    SP_REACT.useCallback(async (val) => {
        set('plugin_use_count', val, false);
        setUseCount(val);
    }, [set]);
    SP_REACT.useEffect(() => {
        (async () => {
            setUseCount(await get('plugin_use_count', 0));
            setSquares(await get('squares', false));
            setUniformFeatured(await get('uniform_featured', false));
            setCapsuleGlowAmount(await get('capsule_glow_amount', 100));
            setMotdToggle(await get('motd_hidden_global', false));
        })();
    }, [get]);
    if (useCount === null)
        return null;
    return (window.SP_REACT.createElement(window.SP_REACT.Fragment, null,
        "production" === 'development',
        (useCount <= 5) && ( // Hide tutorial if plugin has been used more than 5 times
        window.SP_REACT.createElement(DFL.PanelSection, { title: trans_string('LABEL_USAGE_TITLE', 'Lost? Here\'s a Quick Guide') },
            window.SP_REACT.createElement(DFL.PanelSectionRow, null,
                window.SP_REACT.createElement(GuideVideoField, { bottomSeparator: "standard", highlightOnFocus: true, focusable: true, onActivate: () => {
                        DFL.showModal(window.SP_REACT.createElement(DFL.ModalRoot, null,
                            window.SP_REACT.createElement(DFL.DialogBody, { style: { padding: '0 3.5em' } },
                                window.SP_REACT.createElement(GuideVideoField, null))));
                    } })))),
        window.SP_REACT.createElement(DFL.PanelSection, { title: trans_string('Settings', 'Settings', true) },
            window.SP_REACT.createElement(DFL.PanelSectionRow, null,
                window.SP_REACT.createElement(DFL.ToggleField, { label: trans_string('LABEL_SQUARE_CAPSULES', 'Square Capsules'), description: trans_string('LABEL_SQUARE_CAPSULES_DESC', 'Use square capsules instead of portrait ones. Square filters will be automatically selected.'), checked: squares, onChange: handleSquareToggle })),
            window.SP_REACT.createElement(DFL.PanelSectionRow, null,
                window.SP_REACT.createElement(DFL.ToggleField, { label: trans_string('LABEL_UNIFORM_RECENT', 'Matching Recents Capsule'), description: trans_string('LABEL_UNIFORM_RECENT_DESC', 'Make the most recently played game on the home screen match the rest of the capsules.'), checked: uniformFeatured, onChange: handleUniformFeaturedToggle })),
            appgridClasses?.LibraryImageBackgroundGlow && (window.SP_REACT.createElement(DFL.PanelSectionRow, null,
                window.SP_REACT.createElement(DFL.SliderField, { label: trans_string('LABEL_CAPSULE_GLOW', 'Capsule Glow'), description: trans_string('LABEL_CAPSULE_GLOW_DESC', 'Adjust capsule glow intensity in the library.'), notchCount: 2, notchLabels: [
                        {
                            notchIndex: 0,
                            label: trans_string('LABEL_CAPSULE_GLOW_OFF', 'None'),
                        },
                    ], notchTicksVisible: false, onChange: handleCapsuleGlowChange, value: capsuleGlowAmount, min: 0, max: 100, step: 1, resetValue: 100 }))),
            window.SP_REACT.createElement(DFL.PanelSectionRow, null,
                window.SP_REACT.createElement(DFL.Field, { childrenLayout: "below", description: tabSettingsDesc },
                    window.SP_REACT.createElement(DFL.DialogButton, { onClick: () => {
                            DFL.showModal((window.SP_REACT.createElement(DFL.ModalRoot, null,
                                window.SP_REACT.createElement(SettingsProvider, null,
                                    window.SP_REACT.createElement(DFL.DialogHeader, null, trans_string('LABEL_SETTINGS_ASSET_TABS', 'Asset Tab Settings')),
                                    window.SP_REACT.createElement(DFL.DialogBodyText, null, tabSettingsDesc),
                                    window.SP_REACT.createElement(DFL.DialogBody, null,
                                        window.SP_REACT.createElement(TabSorter, null))))));
                        } }, trans_string('LABEL_SETTINGS_ASSET_TABS', 'Asset Tab Settings')))),
            window.SP_REACT.createElement(DFL.PanelSectionRow, null,
                window.SP_REACT.createElement(DFL.ToggleField, { label: trans_string('LABEL_SETTINGS_DISABLE_MOTD', 'Disable Announcements'), description: trans_string('LABEL_SETTINGS_DISABLE_MOTD_DESC', 'Announcements are used sparingly to display important information or community events.'), checked: motdToggle, onChange: handleMotdToggle }))),
        getCredits() && (window.SP_REACT.createElement(DFL.PanelSection, { title: trans_string('LABEL_TRANSLATION_CREDIT_TITLE', 'English Translation') },
            window.SP_REACT.createElement("div", { style: {
                    display: 'flex',
                    flexDirection: 'column',
                    gap: '.25em',
                } }, getCredits().map((person) => window.SP_REACT.createElement("span", { key: person }, person))))),
        window.SP_REACT.createElement(DFL.PanelSection, { title: trans_string('LABEL_MORE_SGDB_TITLE', 'More SteamGridDB Stuff') },
            window.SP_REACT.createElement(PanelSocialButton, { icon: window.SP_REACT.createElement(SiDiscord, { fill: "#5865F2" }), url: "https://discord.gg/bnSVJrz" }, trans_string('ACTION_SGDB_DISCORD', 'Join the Discord')),
            window.SP_REACT.createElement(PanelSocialButton, { icon: window.SP_REACT.createElement(SiGithub, null), url: "https://github.com/SteamGridDB/" }, trans_string('ACTION_SGDB_GITHUB', 'Open Source Projects')),
            window.SP_REACT.createElement(PanelSocialButton, { icon: window.SP_REACT.createElement(SiPatreon, { fill: "#FF424D" }), url: "https://www.patreon.com/steamgriddb" }, trans_string('ACTION_SGDB_DONATE', 'Support us on Patreon')),
            window.SP_REACT.createElement(PanelSocialButton, { icon: window.SP_REACT.createElement(SiKofi, { fill: "#FF5E5B" }), url: "https://ko-fi.com/steamgriddb" }, "Ko-fi"),
            window.SP_REACT.createElement(PanelSocialButton, { icon: window.SP_REACT.createElement(SiCrowdin, { fill: "#fff" }), url: "https://crowdin.com/project/decky-steamgriddb" }, trans_string('ACTION_SGDB_TRANSLATE', 'Help Translate')),
            window.SP_REACT.createElement(PanelSocialButton, { icon: window.SP_REACT.createElement(BoopIcon, { fill: "#4e9ac6" }), url: "https://www.steamgriddb.com/boop" }, trans_string('ACTION_SGDB_BOOP', 'Check out SGDBoop')),
            window.SP_REACT.createElement(PanelSocialButton, { icon: window.SP_REACT.createElement(SiBluesky, { fill: "#0285FF" }), url: "https://bsky.app/profile/steamgriddb.com" }, "Bluesky"),
            window.SP_REACT.createElement(PanelSocialButton, { icon: window.SP_REACT.createElement(SiMastodon, { fill: "#6364FF" }), url: "https://mastodon.gamedev.place/@SteamGridDB" }, "Mastodon"),
            window.SP_REACT.createElement(PanelSocialButton, { icon: window.SP_REACT.createElement(TwitterIcon, { fill: "#1DA1F2" }), url: "https://twitter.com/SteamGridDB" }, "lol"))));
};

// this will be blurry unless you're on 1x UI scale cause the quick access menu icons arent being scaled pixel perfect :(
const MenuIcon = (props) => (window.SP_REACT.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", xmlSpace: "preserve", viewBox: "0 0 16 16", stroke: "transparent", fill: "currentColor", height: "1em", width: "1em", ...props },
    window.SP_REACT.createElement("path", { d: "M0,3L0,11L1,11L1,4L12,4L12,3L0,3Z" }),
    window.SP_REACT.createElement("path", { d: "M14,5L2,5L2,12L3,12L3,6L14,6L14,5Z" }),
    window.SP_REACT.createElement("rect", { x: "4", y: "7", width: "12", height: "6" })));

class e extends Error{constructor(t){super(null!=t?`Timed out after waiting for ${t} ms`:"Timed out"),Object.setPrototypeOf(this,e.prototype);}}const t=(e,t)=>new Promise(((o,n)=>{try{e.schedule(o,t);}catch(e){n(e);}})),o={schedule:(e,t)=>{let o;const n=e=>{null!=e&&clearTimeout(e),o=void 0;};return o=setTimeout((()=>{n(o),e();}),t),{cancel:()=>n(o)}}},c=Number.POSITIVE_INFINITY,l=(n,r,l)=>{var s,u;const i=null!==(s="number"==typeof r?r:null==r?void 0:r.timeout)&&void 0!==s?s:5e3,a=null!==(u="number"==typeof r?l:null==r?void 0:r.intervalBetweenAttempts)&&void 0!==u?u:50;let m=!1;const d=()=>new Promise(((e,r)=>{const c=()=>{m||new Promise(((e,t)=>{try{e(n());}catch(e){t(e);}})).then((n=>{n?e(n):t(o,a).then(c).catch(r);})).catch(r);};c();})),h=i!==c?()=>t(o,i).then((()=>{throw m=!0,new e(i)})):void 0;return null!=h?Promise.race([d(),h()]):d()};

const getAppOverview = async (appId) => {
    try {
        return await l(() => {
            return window.appStore.GetAppOverviewByAppID(appId) ?? null;
        }, { timeout: 5000, intervalBetweenAttempts: 200 });
    }
    catch (err) {
        return null;
    }
};

/**
 * Tries to retrieve the app details from Steam.
 *
 * @param appId id to get details for.
 * @returns AppDetails if succeeded or null otherwise.
 */
async function getAppDetails(appId) {
    return await new Promise((resolve) => {
        let timeoutId = undefined;
        try {
            const { unregister } = SteamClient.Apps.RegisterForAppDetails(appId, (details) => {
                clearTimeout(timeoutId);
                unregister();
                resolve(details);
            });
            timeoutId = setTimeout(() => {
                unregister();
                resolve(null);
            }, 300);
        }
        catch (error) {
            clearTimeout(timeoutId);
            resolve(null);
        }
    });
}

const restartSteam = () => {
    SteamClient.User.StartRestart(false);
};
const showRestartConfirm = () => {
    DFL.showModal(window.SP_REACT.createElement(DFL.ConfirmModal, { strTitle: trans_string('LABEL_RESTART_STEAM_TITLE', 'Restart Steam?'), strCancelButtonText: trans_string('ACTION_RESTART_STEAM_LATER', 'Later'), strOKButtonText: trans_string('ACTION_RESTART_STEAM_NOW', 'Restart Now'), strDescription: trans_string('MSG_RESTART_STEAM_DESC', 'Steam needs to be restarted for the changes to take effect.'), onOK: restartSteam }));
};

var getCurrentSteamUserId = (steam64 = false) => {
    if (steam64)
        return window.App.m_CurrentUser.strSteamID;
    return BigInt.asUintN(32, BigInt(window.App.m_CurrentUser.strSteamID)).toString();
};

/*
  special key only for use with this decky plugin
  attempting to use this in your own projects will
  cause you to be automatically banned and blacklisted
*/
const SGDB_API_KEY = '6465636b796c6f616465723432303639';
const SGDB_API_BASE = 'https://www.steamgriddb.com/api/v2';
const getAmbiguousAssetType = (assetType) => typeof assetType === 'number' ? assetType : ASSET_TYPE[assetType];
const getApiParams = (assetType, filters, page) => {
    let adult = 'false';
    let humor = 'any';
    let epilepsy = 'any';
    let oneoftag = '';
    if (filters?.untagged === true) {
        if (filters?.humor === false) {
            humor = 'false';
        }
        if (filters?.adult === false) {
            adult = 'false';
        }
        if (filters?.adult === true) {
            adult = 'any';
        }
        if (filters?.epilepsy === false) {
            epilepsy = 'false';
        }
    }
    else {
        const selectedTags = [];
        if (filters?.humor === true) {
            humor = 'any';
            selectedTags.push('humor');
        }
        if (filters?.adult === true) {
            adult = 'any';
            selectedTags.push('nsfw');
        }
        if (filters?.epilepsy === true) {
            epilepsy = 'any';
            selectedTags.push('epilepsy');
        }
        oneoftag = selectedTags.join(',');
    }
    return new URLSearchParams({
        page: page.toString(),
        styles: filters?.styles ?? STYLES[assetType].default.join(','),
        dimensions: filters?.dimensions ?? DIMENSIONS[assetType].default.join(','),
        mimes: filters?.mimes ?? MIMES[assetType].default.join(','),
        nsfw: adult,
        humor,
        epilepsy,
        oneoftag,
        types: [filters?._static && 'static', filters?.animated && 'animated'].filter(Boolean).join(','),
    }).toString();
};
const SGDBContext = SP_REACT.createContext({});
const SGDBProvider = ({ children }) => {
    const [appId, setAppId] = SP_REACT.useState(0);
    const [appOverview, setAppOverview] = SP_REACT.useState(null);
    const clearAsset = SP_REACT.useCallback(async (assetType) => {
        assetType = getAmbiguousAssetType(assetType);
        if (assetType === ASSET_TYPE.icon) {
            if (appOverview?.BIsShortcut()) {
                const res = await call('set_shortcut_icon', appId, getCurrentSteamUserId(), null // null removes the icon
                );
                if (res !== 'icon_is_same_path')
                    showRestartConfirm();
            }
            else {
                if (appOverview) {
                    // Redownload the icon from Steam
                    await call('set_steam_icon_from_url', appId, window.appStore.GetIconURLForApp(appOverview));
                }
            }
        }
        else {
            await SteamClient.Apps.ClearCustomArtworkForApp(appId, assetType);
            // ClearCustomArtworkForApp() resolves instantly instead of after clearing, so we need to wait a bit.
            await new Promise((resolve) => setTimeout(resolve, 500));
        }
    }, [appId, appOverview]);
    const changeAsset = SP_REACT.useCallback(async (data, assetType) => {
        assetType = getAmbiguousAssetType(assetType);
        try {
            await clearAsset(assetType);
            await SteamClient.Apps.SetCustomArtworkForApp(appId, data, 'png', assetType);
        }
        catch (error) {
        }
    }, [appId, clearAsset]);
    const apiRequest = SP_REACT.useCallback((url, signal) => {
        return new Promise((resolve, reject) => {
            if (signal?.aborted)
                return reject(new DOMException('Aborted', 'AbortError'));
            const abortHandler = () => {
                reject(new DOMException('Aborted', 'AbortError'));
            };
            signal?.addEventListener('abort', abortHandler);
            fetchNoCors(`${SGDB_API_BASE}${url}`, {
                method: 'GET',
                headers: {
                    Accept: 'application/json',
                    Authorization: `Bearer ${SGDB_API_KEY}`,
                },
            }).then((res) => {
                if (res.status !== 200 && res.status >= 500) {
                    return reject(new Error('SGDB API request failed'));
                }
                try {
                    res.json().then((assetRes) => {
                        if (!assetRes.success) {
                            const apiErr = new Error(assetRes.errors.join(', '));
                            apiErr.status = res.status;
                            return reject(apiErr);
                        }
                        return resolve(assetRes.data);
                    });
                }
                catch (err) {
                    return reject(new Error(err.message));
                }
            }).finally(() => {
                signal?.removeEventListener('abort', abortHandler);
            });
        });
    }, []);
    const getImageAsB64 = SP_REACT.useCallback(async (location, path = false) => {
        try {
            return await call(path ? 'read_file_as_base64' : 'download_as_base64', location);
        }
        catch (error) {
            return null;
        }
    }, []);
    const changeAssetFromUrl = SP_REACT.useCallback(async (url, assetType, path = false) => {
        assetType = getAmbiguousAssetType(assetType);
        if (assetType === ASSET_TYPE.icon) {
            if (appOverview?.BIsShortcut()) {
                const res = await call(path ? 'set_shortcut_icon_from_path' : 'set_shortcut_icon_from_url', appId, getCurrentSteamUserId(), url);
                if (res === 'icon_is_same_path') {
                    // If the path is already the same as the current icon, we can force an icon re-read by setting the name to itself
                    SteamClient.Apps.SetShortcutName(appOverview.appid, appOverview.display_name);
                }
                else if (res === true) {
                    // shortcuts.vdf was modified, can't figure out how to make Steam re-read it so just ask user to reboot
                    showRestartConfirm();
                }
            }
            else {
                // Change default Steam icon by poisoning the cache like Boop does it
                await call(path ? 'set_steam_icon_from_path' : 'set_steam_icon_from_url', appId, url);
            }
        }
        else {
            const data = await getImageAsB64(url, path);
            if (!data) {
                throw new Error('Failed to retrieve asset');
            }
            await changeAsset(data, assetType);
        }
    }, [appId, appOverview, changeAsset, getImageAsB64]);
    const searchGames = SP_REACT.useCallback(async (term) => {
        try {
            // encodeURIComponent twice to preserve some symbols
            // api is equpped to handle various types of inputs so this is fine
            const res = await apiRequest(`/search/autocomplete/${encodeURIComponent(encodeURIComponent(term))}`);
            return res;
        }
        catch (err) {
            toaster.toast({
                title: 'SteamGridDB API Error',
                body: err.message,
                icon: window.SP_REACT.createElement(MenuIcon, { fill: "#f3171e" }),
            });
            return [];
        }
    }, [apiRequest]);
    const searchAssets = SP_REACT.useCallback(async (assetType, { gameId, filters = null, page = 0, signal }) => {
        let type = '';
        switch (assetType) {
            case 'grid_p':
            case 'grid_l':
                type = 'grids';
                break;
            case 'hero':
                type = 'heroes';
                break;
            case 'icon':
                type = 'icons';
                break;
            case 'logo':
                type = 'logos';
                break;
        }
        const qs = getApiParams(assetType, filters, page);
        return await apiRequest(`/${type}/${gameId ? 'game' : 'steam'}/${gameId ?? appId}?${qs}`, signal);
    }, [apiRequest, appId]);
    const getSgdbGame = SP_REACT.useCallback(async (game) => {
        try {
            const gameRes = await apiRequest(`/games/id/${game.id}?platformdata=steam`);
            return gameRes;
        }
        catch (err) {
            toaster.toast({
                title: 'SteamGridDB API Error',
                body: err.message,
                icon: window.SP_REACT.createElement(MenuIcon, { fill: "#f3171e" }),
            });
            return [];
        }
    }, [apiRequest]);
    SP_REACT.useEffect(() => {
        if (appId) {
            (async () => {
                // Get details before overview or some games will be null.
                await getAppDetails(appId);
                const overview = await getAppOverview(appId);
                setAppOverview(overview);
            })();
        }
    }, [appId]);
    const value = SP_REACT.useMemo(() => ({
        appId,
        appOverview,
        setAppId,
        searchAssets,
        searchGames,
        getSgdbGame,
        changeAsset,
        changeAssetFromUrl,
        clearAsset,
    }), [appId, appOverview, searchAssets, searchGames, getSgdbGame, changeAsset, changeAssetFromUrl, clearAsset]);
    return (window.SP_REACT.createElement(SGDBContext.Provider, { value: value }, children));
};
const useSGDB = () => SP_REACT.useContext(SGDBContext);

/* global Map:readonly, Set:readonly, ArrayBuffer:readonly */

var hasElementType = typeof Element !== 'undefined';
var hasMap = typeof Map === 'function';
var hasSet = typeof Set === 'function';
var hasArrayBuffer = typeof ArrayBuffer === 'function' && !!ArrayBuffer.isView;

// Note: We **don't** need `envHasBigInt64Array` in fde es6/index.js

function equal(a, b) {
  // START: fast-deep-equal es6/index.js 3.1.3
  if (a === b) return true;

  if (a && b && typeof a == 'object' && typeof b == 'object') {
    if (a.constructor !== b.constructor) return false;

    var length, i, keys;
    if (Array.isArray(a)) {
      length = a.length;
      if (length != b.length) return false;
      for (i = length; i-- !== 0;)
        if (!equal(a[i], b[i])) return false;
      return true;
    }

    // START: Modifications:
    // 1. Extra `has<Type> &&` helpers in initial condition allow es6 code
    //    to co-exist with es5.
    // 2. Replace `for of` with es5 compliant iteration using `for`.
    //    Basically, take:
    //
    //    ```js
    //    for (i of a.entries())
    //      if (!b.has(i[0])) return false;
    //    ```
    //
    //    ... and convert to:
    //
    //    ```js
    //    it = a.entries();
    //    while (!(i = it.next()).done)
    //      if (!b.has(i.value[0])) return false;
    //    ```
    //
    //    **Note**: `i` access switches to `i.value`.
    var it;
    if (hasMap && (a instanceof Map) && (b instanceof Map)) {
      if (a.size !== b.size) return false;
      it = a.entries();
      while (!(i = it.next()).done)
        if (!b.has(i.value[0])) return false;
      it = a.entries();
      while (!(i = it.next()).done)
        if (!equal(i.value[1], b.get(i.value[0]))) return false;
      return true;
    }

    if (hasSet && (a instanceof Set) && (b instanceof Set)) {
      if (a.size !== b.size) return false;
      it = a.entries();
      while (!(i = it.next()).done)
        if (!b.has(i.value[0])) return false;
      return true;
    }
    // END: Modifications

    if (hasArrayBuffer && ArrayBuffer.isView(a) && ArrayBuffer.isView(b)) {
      length = a.length;
      if (length != b.length) return false;
      for (i = length; i-- !== 0;)
        if (a[i] !== b[i]) return false;
      return true;
    }

    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
    // START: Modifications:
    // Apply guards for `Object.create(null)` handling. See:
    // - https://github.com/FormidableLabs/react-fast-compare/issues/64
    // - https://github.com/epoberezkin/fast-deep-equal/issues/49
    if (a.valueOf !== Object.prototype.valueOf && typeof a.valueOf === 'function' && typeof b.valueOf === 'function') return a.valueOf() === b.valueOf();
    if (a.toString !== Object.prototype.toString && typeof a.toString === 'function' && typeof b.toString === 'function') return a.toString() === b.toString();
    // END: Modifications

    keys = Object.keys(a);
    length = keys.length;
    if (length !== Object.keys(b).length) return false;

    for (i = length; i-- !== 0;)
      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;
    // END: fast-deep-equal

    // START: react-fast-compare
    // custom handling for DOM elements
    if (hasElementType && a instanceof Element) return false;

    // custom handling for React/Preact
    for (i = length; i-- !== 0;) {
      if ((keys[i] === '_owner' || keys[i] === '__v' || keys[i] === '__o') && a.$$typeof) {
        // React-specific: avoid traversing React elements' _owner
        // Preact-specific: avoid traversing Preact elements' __v and __o
        //    __v = $_original / $_vnode
        //    __o = $_owner
        // These properties contain circular references and are not needed when
        // comparing the actual elements (and not their owners)
        // .$$typeof and ._store on just reasonable markers of elements

        continue;
      }

      // all other properties should be traversed as usual
      if (!equal(a[keys[i]], b[keys[i]])) return false;
    }
    // END: react-fast-compare

    // START: fast-deep-equal
    return true;
  }

  return a !== a && b !== b;
}
// end fast-deep-equal

var reactFastCompare = function isEqual(a, b) {
  try {
    return equal(a, b);
  } catch (error) {
    if (((error.message || '').match(/stack|recursion/i))) {
      // warn on circular references, don't crash
      // browsers give this different errors name and messages:
      // chrome/safari: "RangeError", "Maximum call stack size exceeded"
      // firefox: "InternalError", too much recursion"
      // edge: "Error", "Out of stack space"
      console.warn('react-fast-compare cannot handle circular refs');
      return false;
    }
    // some other error. we should definitely know about these
    throw error;
  }
};

var isEqual = /*@__PURE__*/getDefaultExportFromCjs(reactFastCompare);

const Chevron = ({ direction, ...rest }) => {
    let d;
    switch (direction) {
        case 'up':
            d = 'M17.98 10.23L3.20996 25H32.75L17.98 10.23Z';
            break;
        case 'down':
            d = 'M17.98 26.54L3.20996 11.77H32.75L17.98 26.54Z';
            break;
        case 'left':
            d = 'M9.82497 18.385L24.595 3.61499L24.595 33.155L9.82497 18.385Z';
            break;
        case 'right':
            d = 'M26.135 18.385L11.365 33.155L11.365 3.61503L26.135 18.385Z';
            break;
    }
    return (window.SP_REACT.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 36 36", fill: "none", ...rest },
        window.SP_REACT.createElement("path", { d: d, fill: "currentColor" })));
};

const DropdownMultiselectItem = ({ value, onSelect, checked: defaultChecked, ...rest }) => {
    const [checked, setChecked] = SP_REACT.useState(defaultChecked);
    SP_REACT.useEffect(() => {
        onSelect?.(checked, value);
    }, [checked, onSelect, value]);
    return (window.SP_REACT.createElement(DFL.MenuItem, { bInteractableItem: true, onClick: () => setChecked((x) => !x) },
        window.SP_REACT.createElement(DFL.DialogCheckbox, { style: { marginBottom: 0, padding: 0 }, className: "decky_DropdownMultiselectItem_DialogCheckbox", bottomSeparator: "none", ...rest, onClick: () => setChecked((x) => !x), onChange: (checked) => setChecked(checked), controlled: true, checked: checked })));
};
const DropdownMultiselect = ({ label, items, selected, onSelect, }) => {
    const [itemsSelected, setItemsSelected] = SP_REACT.useState(selected);
    const handleItemSelect = SP_REACT.useCallback((checked, value) => {
        setItemsSelected((x) => (checked ?
            [...x.filter((y) => y !== value), value] :
            x.filter((y) => y !== value)));
    }, []);
    SP_REACT.useEffect(() => {
        onSelect(itemsSelected);
    }, [itemsSelected, onSelect]);
    return (window.SP_REACT.createElement(DFL.DialogButton, { style: {
            display: 'flex',
            alignItems: 'center',
            maxWidth: '100%',
        }, onClick: (evt) => {
            evt.preventDefault();
            DFL.showContextMenu(window.SP_REACT.createElement(DFL.Menu, { label: label, cancelText: trans_string('Button_Back', 'Back', true) },
                window.SP_REACT.createElement("style", null, `
              /*
                Hacks:
                  Allow clicking through so cursor hits contextMenuItem instead
                  Inherit color from ".basiccontextmenu"
              */
              .decky_DropdownMultiselectItem_DialogCheckbox {
                pointer-events: none;
              }
              .decky_DropdownMultiselectItem_DialogCheckbox > .DialogToggle_Label {
                color: inherit;
              }
              `),
                items.map((x) => (window.SP_REACT.createElement(DropdownMultiselectItem, { key: x.value, label: x.label, value: x.value, checked: itemsSelected.includes(x.value), onSelect: handleItemSelect })))), evt.currentTarget ?? window);
        } },
        window.SP_REACT.createElement(DFL.Marquee, null, selected.length > 0 ?
            selected.map((x) => items[items.findIndex((v) => v.value === x)].label).join(', ') :
            '…'),
        window.SP_REACT.createElement("div", { style: { flexGrow: 1, minWidth: '1ch' } }),
        window.SP_REACT.createElement(Chevron, { style: { height: '1em', flex: '0 0 1em' }, direction: "down" })));
};

const compareFilterWithDefaults = (assetType, filters) => {
    if (!filters)
        return false;
    // simply cannot be fucked to do this in a better way
    return ((filters?.styles ? !isEqual([...filters.styles].sort(), [...STYLES[assetType].default].sort()) : false) ||
        (filters?.dimensions ? !isEqual([...filters.dimensions].sort(), [...DIMENSIONS[assetType].default].sort()) : false) ||
        (filters?.mimes ? !isEqual([...filters.mimes].sort(), [...MIMES[assetType].default].sort()) : false) ||
        filters?.animated !== true ||
        filters?._static !== true ||
        filters?.humor !== true ||
        filters?.epilepsy !== true ||
        filters?.untagged !== true);
};

const FlashpointIcon = (props) => (window.SP_REACT.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", xmlSpace: "preserve", viewBox: "0 0 477 448", stroke: "transparent", fill: "currentColor", height: "1em", width: "1em", ...props },
    window.SP_REACT.createElement("path", { d: "M139.19 366.067l337.498-104.006-451.406-262.053 351.057 259.302-213.405 62.468z" }),
    window.SP_REACT.createElement("path", { d: "M0 17.563l159.080 197.89-114.814 232.561 75.495-23.266c30.089-69.179 60.177-138.354 90.265-207.532l3.925 54.457 93.498-24.157z" })));

const EshopIcon = (props) => (window.SP_REACT.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", xmlSpace: "preserve", viewBox: "0 0 11 14", stroke: "transparent", fill: "currentColor", height: "1em", width: "1em", ...props },
    window.SP_REACT.createElement("path", { d: "M9.901 1.281c-0.006-0.009-0.017-0.015-0.028-0.015s-0.022 0.006-0.028 0.015l-0 0-1.814 2.508c-0.003 0.004-0.005 0.010-0.005 0.016 0 0.016 0.013 0.028 0.028 0.028 0.004 0 0.008-0.001 0.011-0.002l-0 0 2.683-1.545c0.011-0.007 0.018-0.019 0.018-0.033 0-0.010-0.003-0.018-0.009-0.025l0 0zM7.736 9.492c-0.123 1.192-1.116 2.186-2.517 2.186-0.685 0-1.46-0.283-1.86-0.78l4.941-2.869c1.059-0.613 1.549-1.146 1.091-1.937-0.708-1.12-2.495-2.303-4.425-2.303-2.734 0-4.966 2.422-4.966 5.105 0 2.884 2.527 5.107 5.303 5.107 2.563 0 4.851-1.84 4.977-4.508zM5.137 5.985c0.686 0 1.227 0.245 1.725 0.71l-4.445 2.562c-0.030-0.152-0.047-0.327-0.047-0.505 0-1.528 1.239-2.766 2.766-2.766v0zM7.222 3.244l1.648-2.618c0.003-0.005 0.005-0.011 0.005-0.018 0-0.016-0.010-0.029-0.024-0.035l-0-0-1.201-0.439c-0.004-0.001-0.008-0.002-0.012-0.002-0.018 0-0.033 0.014-0.035 0.032l-0 0-0.426 3.067c-0 0.001-0 0.002-0 0.004 0 0.012 0.008 0.022 0.018 0.026l0 0c0.002 0.001 0.005 0.001 0.007 0.001 0.010 0 0.018-0.007 0.021-0.016l0-0zM6.188 3.153c0.012-0.003 0.021-0.013 0.022-0.026v-0l0.223-3.088c-0.001-0.022-0.018-0.040-0.040-0.040-0.002 0-0.003 0-0.005 0l0-0-1.261 0.179c-0.019 0.001-0.034 0.016-0.034 0.036 0 0.005 0.001 0.010 0.003 0.015l-0-0 1.062 2.904c0.004 0.012 0.014 0.020 0.027 0.020 0.001 0 0.002-0 0.003-0l-0 0z" })));

const GogIcon = (props) => (window.SP_REACT.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", xmlSpace: "preserve", viewBox: "0 0 14 14", stroke: "transparent", fill: "currentColor", height: "1em", width: "1em", ...props },
    window.SP_REACT.createElement("path", { d: "M12.764 13.382h-11.529c-0.682 0-1.235-0.553-1.235-1.235v0-10.293c0-0.682 0.553-1.235 1.235-1.235v0h11.529c0.682 0 1.235 0.553 1.235 1.235v0 10.293c0 0.682-0.553 1.235-1.235 1.235v0zM1.647 10.706c0 0.341 0.276 0.618 0.618 0.618v0h2.265v-0.824h-1.853c-0.114 0-0.206-0.092-0.206-0.206v0-1.235c0-0.114 0.092-0.206 0.206-0.206v0h1.853v-0.824h-2.265c-0.341 0-0.618 0.276-0.618 0.618v0zM4.941 3.294c0-0.341-0.276-0.618-0.618-0.618v0h-2.059c-0.341 0-0.618 0.276-0.618 0.618v0 2.059c0 0.341 0.276 0.618 0.618 0.618v0h1.441v-0.824h-1.029c-0.114 0-0.206-0.092-0.206-0.206v0-1.235c0-0.114 0.092-0.206 0.206-0.206v0h1.235c0.114 0 0.206 0.092 0.206 0.206v0 2.47c0 0.114-0.092 0.206-0.206 0.206v0h-2.265v0.824h2.676c0.341 0 0.618-0.276 0.618-0.618v0zM4.941 8.647v2.059c0 0.341 0.276 0.618 0.618 0.618v0h2.059c0.341 0 0.618-0.276 0.618-0.618v0-2.059c0-0.341-0.276-0.618-0.618-0.618v0h-2.059c-0.341 0-0.618 0.276-0.618 0.618v0zM8.647 3.294c0-0.341-0.276-0.618-0.618-0.618v0h-2.059c-0.341 0-0.618 0.276-0.618 0.618v0 2.059c0 0.341 0.276 0.618 0.618 0.618v0h2.059c0.341 0 0.618-0.276 0.618-0.618v0zM12.353 3.294c0-0.341-0.276-0.618-0.618-0.618v0h-2.059c-0.341 0-0.618 0.276-0.618 0.618v0 2.059c0 0.341 0.276 0.618 0.618 0.618v0h1.441v-0.824h-1.029c-0.114 0-0.206-0.092-0.206-0.206v0-1.235c0-0.114 0.092-0.206 0.206-0.206v0h1.235c0.114 0 0.206 0.092 0.206 0.206v0 2.47c0 0.114-0.092 0.206-0.206 0.206v0h-2.265v0.824h2.676c0.341 0 0.618-0.276 0.618-0.618v0zM12.353 8.029h-3.088c-0.341 0-0.618 0.276-0.618 0.618v0 2.676h0.824v-2.265c0-0.114 0.092-0.206 0.206-0.206v0h0.412v2.47h0.824v-2.47h0.618v2.47h0.824zM7.618 5.147h-1.235c-0.114 0-0.206-0.092-0.206-0.206v0-1.235c0-0.114 0.092-0.206 0.206-0.206v0h1.235c0.114 0 0.206 0.092 0.206 0.206v0 1.235c0 0.114-0.092 0.206-0.206 0.206v0zM5.971 8.853h1.235c0.114 0 0.206 0.092 0.206 0.206v0 1.235c0 0.114-0.092 0.206-0.206 0.206v0h-1.235c-0.114 0-0.206-0.092-0.206-0.206v0-1.235c0-0.114 0.092-0.206 0.206-0.206v0z" })));

// @todo: find a better way to get this
const SearchIcon = Object.values(DFL.IconsModule).find((mod) => mod?.toString().includes('M27.5 24C29.4972 21.1283 30.3471'));
const utcYear = (date) => new Date(date * 1000).toLocaleString('en-US', { year: 'numeric', timeZone: 'UTC' });
const platformTypeMap = {
    steam: SiSteam,
    egs: SiEpicgames,
    origin: SiOrigin,
    uplay: SiUbisoft,
    gog: GogIcon,
    bnet: SiBattledotnet,
    flashpoint: FlashpointIcon,
    eshop: EshopIcon,
};
const GameLabel = ({ game }) => (window.SP_REACT.createElement("span", { className: "gamelabel" },
    window.SP_REACT.createElement(DFL.Marquee, null, game.name),
    game.release_date && window.SP_REACT.createElement("span", { className: "release-date" },
        "(",
        utcYear(game.release_date),
        ")"),
    (game.types.length > 0) && (window.SP_REACT.createElement("span", { className: "platform-types" }, game.types.map((x) => {
        const PlatformLogo = platformTypeMap[x];
        return window.SP_REACT.createElement(PlatformLogo, { key: x });
    })))));
const SearchTextField = (props) => {
    const fieldRef = SP_REACT.useRef();
    const focusableRef = SP_REACT.useRef();
    const focusTextField = () => {
        const input = fieldRef.current?.m_elInput;
        input?.focus();
        input?.click();
    };
    // Activate <Focusable /> when pressing back on text box
    SP_REACT.useEffect(() => {
        if (!fieldRef.current)
            return;
        const onCancel = (evt) => {
            evt.stopPropagation(); // stop bubbling or else modal will close
            focusableRef.current?.focus();
        };
        const input = fieldRef.current?.m_elInput;
        input.addEventListener('vgp_oncancel', onCancel);
        input.addEventListener('vgp_onok', onCancel);
        return () => {
            input.removeEventListener('vgp_oncancel', onCancel);
            input.removeEventListener('vgp_onok', onCancel);
        };
    }, [fieldRef]);
    return (window.SP_REACT.createElement(DFL.Field, { bottomSeparator: "thick", icon: window.SP_REACT.createElement(SearchIcon, null), label: trans_string('LABEL_GAME_SEARCH_TITLE', 'Search for a Game...'), childrenLayout: "below" },
        window.SP_REACT.createElement(DFL.Focusable, { ref: focusableRef, onActivate: focusTextField, noFocusRing: true },
            window.SP_REACT.createElement(DFL.TextField
            // @ts-ignore: ref hack to get underlying <input>
            , { 
                // @ts-ignore: ref hack to get underlying <input>
                ref: fieldRef, focusOnMount: false, spellcheck: "false", ...props }))));
};
const GameSelectionModal = ({ closeModal, onSelect, searchGames, defaultTerm }) => {
    const [value, setValue] = SP_REACT.useState(defaultTerm);
    const [games, setGames] = SP_REACT.useState([]);
    const [loading, setLoading] = SP_REACT.useState(false);
    const handleGameSelect = (game) => {
        onSelect?.(game);
        closeModal?.();
    };
    const handleSearch = SP_REACT.useMemo(() => debounce$1(async (term) => {
        if (!term) {
            setLoading(false);
            return;
        }
        const resp = await searchGames(term);
        setGames(resp);
        setLoading(false);
    }, 600), [searchGames]);
    SP_REACT.useEffect(() => {
        setLoading(true);
        handleSearch(value);
    }, [handleSearch, value]);
    return (window.SP_REACT.createElement(DFL.ModalRoot, { className: "sgdb-modal sgdb-modal-gameselect", closeModal: closeModal },
        window.SP_REACT.createElement(DFL.DialogBody, null,
            window.SP_REACT.createElement(DFL.DialogControlsSection, null,
                window.SP_REACT.createElement(SearchTextField, { value: value, onChange: (evt) => {
                        setValue(evt.target.value);
                    } }),
                loading && (window.SP_REACT.createElement("div", { className: "spinner" },
                    window.SP_REACT.createElement(DFL.Spinner, null))),
                !loading && games.map((game) => (window.SP_REACT.createElement(DFL.Field, { key: game.id, bottomSeparator: "none", icon: null, label: null, childrenLayout: "below", inlineWrap: "keep-inline", spacingBetweenLabelAndChild: "none", childrenContainerWidth: "max" },
                    window.SP_REACT.createElement(DFL.DialogButton, { onClick: () => handleGameSelect(game) },
                        window.SP_REACT.createElement(GameLabel, { game: game })))))))));
};

const FiltersModal = ({ closeModal, assetType, isNonsteam, onSave, defaultFilters, defaultSelectedGame, defaultSearchTerm, searchGames, }) => {
    const [styles, setStyles] = SP_REACT.useState(defaultFilters?.styles ?? STYLES[assetType].default);
    const [mimes, setMimes] = SP_REACT.useState(defaultFilters?.mimes ?? MIMES[assetType].default);
    const [dimensions, setDimensions] = SP_REACT.useState(defaultFilters?.dimensions ?? DIMENSIONS[assetType].default);
    const [animated, setAnimated] = SP_REACT.useState(defaultFilters?.animated ?? true);
    const [_static, setStatic] = SP_REACT.useState(defaultFilters?._static ?? true);
    const [adult, setAdult] = SP_REACT.useState(defaultFilters?.adult ?? false);
    const [humor, setHumor] = SP_REACT.useState(defaultFilters?.humor ?? true);
    const [epilepsy, setEpilepsy] = SP_REACT.useState(defaultFilters?.epilepsy ?? true);
    const [untagged, setUntagged] = SP_REACT.useState(defaultFilters?.untagged ?? true);
    const filters = SP_REACT.useMemo(() => ({
        styles, dimensions, mimes, animated, _static, adult, humor, epilepsy, untagged,
    }), [styles, dimensions, mimes, animated, _static, adult, humor, epilepsy, untagged]);
    const [selectedGame, setSelectedGame] = SP_REACT.useState(defaultSelectedGame);
    /* Controls if the adult content desc shows, only want it to show when it gets toggled and not just when `adult` is true. */
    const [adultActivated, setAdultActivated] = SP_REACT.useState(false);
    const handleStyleSelect = SP_REACT.useCallback((items) => {
        setStyles(items);
    }, []);
    const handleMimeSelect = SP_REACT.useCallback((items) => {
        setMimes(items);
    }, []);
    const handleDimensionsSelect = SP_REACT.useCallback((items) => {
        setDimensions(items);
    }, []);
    const handleClose = () => {
        onSave(assetType, filters, selectedGame);
        closeModal?.();
    };
    const resetFilters = () => {
        setStyles(STYLES[assetType].default);
        setMimes(MIMES[assetType].default);
        setDimensions(DIMENSIONS[assetType].default);
        setAnimated(true);
        setStatic(true);
        setHumor(true);
        setEpilepsy(true);
        setUntagged(true);
    };
    return (window.SP_REACT.createElement(DFL.ModalRoot, { className: "sgdb-modal sgdb-modal-filters", closeModal: handleClose },
        window.SP_REACT.createElement(DFL.DialogHeader, null, trans_string('LABEL_FILTER_MODAL_TITLE', '{assetType} Filter').replace('{assetType}', SGDB_ASSET_TYPE_READABLE[assetType])),
        window.SP_REACT.createElement(DFL.DialogBody, null,
            window.SP_REACT.createElement(DFL.DialogControlsSection, null,
                window.SP_REACT.createElement(DFL.Field, { label: trans_string('LABEL_FILTER_GAME', 'Game') },
                    window.SP_REACT.createElement(DFL.Focusable, { className: "game-filter-content" },
                        window.SP_REACT.createElement(DFL.DialogButton, { className: "custom-game-value", onClick: () => {
                                DFL.showModal(window.SP_REACT.createElement(GameSelectionModal, { defaultTerm: selectedGame?.name || defaultSearchTerm, searchGames: searchGames, onSelect: (game) => {
                                        setSelectedGame(game);
                                    } }));
                            } },
                            window.SP_REACT.createElement(DFL.Marquee, null, selectedGame?.name || trans_string('LABEL_GAME_SEARCH_TITLE', 'Search for a Game...'))),
                        (selectedGame && !isNonsteam) && (window.SP_REACT.createElement(DFL.DialogButton, { className: "clear-custom-game", onClick: () => setSelectedGame(undefined) },
                            window.SP_REACT.createElement(HiXMark, { strokeWidth: 1.5 }))))),
                (DIMENSIONS[assetType].options.length > 0) && (window.SP_REACT.createElement(DFL.Field, { label: trans_string('LABEL_FILTER_DIMENSIONS', 'Dimensions') },
                    window.SP_REACT.createElement(DropdownMultiselect, { label: trans_string('LABEL_FILTER_DIMENSIONS', 'Dimensions'), items: DIMENSIONS[assetType].options, selected: dimensions, onSelect: handleDimensionsSelect }))),
                window.SP_REACT.createElement(DFL.Field, { label: trans_string('LABEL_FILTER_STYLES', 'Styles') },
                    window.SP_REACT.createElement(DropdownMultiselect, { label: trans_string('LABEL_FILTER_STYLES', 'Styles'), items: STYLES[assetType].options, selected: styles, onSelect: handleStyleSelect })),
                window.SP_REACT.createElement(DFL.Field, { label: trans_string('LABEL_FILTER_FILE_TYPES', 'File Types') },
                    window.SP_REACT.createElement(DropdownMultiselect, { label: trans_string('LABEL_FILTER_FILE_TYPES', 'File Types'), items: MIMES[assetType].options, selected: mimes, onSelect: handleMimeSelect }))),
            window.SP_REACT.createElement(DFL.DialogControlsSection, null,
                window.SP_REACT.createElement(DFL.DialogControlsSectionHeader, null, trans_string('LABEL_FILTER_ANIMATION_TYPE_TITLE', 'Types')),
                window.SP_REACT.createElement(DFL.ToggleField, { label: trans_string('LABEL_FILTER_TYPE_ANIMATED', 'Animated'), checked: animated, onChange: (checked) => {
                        if (!_static && !checked) {
                            setStatic(true);
                            setAnimated(false);
                        }
                        else {
                            setAnimated(checked);
                        }
                    } }),
                window.SP_REACT.createElement(DFL.ToggleField, { label: trans_string('LABEL_FILTER_TYPE_STATIC', 'Static'), checked: _static, onChange: (checked) => {
                        if (!animated && !checked) {
                            setAnimated(true);
                            setStatic(false);
                        }
                        else {
                            setStatic(checked);
                        }
                    } })),
            window.SP_REACT.createElement(DFL.DialogControlsSection, null,
                window.SP_REACT.createElement(DFL.DialogControlsSectionHeader, null, trans_string('LABEL_FILTER_TAGS_TITLE', 'Tags')),
                window.SP_REACT.createElement(DFL.ToggleField, { label: trans_string('LABEL_FILTER_TAG_NSFW', 'Adult Content'), description: adultActivated ? trans_string('MSG_FILTER_TAG_NSFW_ENABLED', 'Might wanna do a quick shoulder check.') : undefined, checked: adult, onChange: (checked) => {
                        setAdult(checked);
                        setAdultActivated(checked);
                    } }),
                window.SP_REACT.createElement(DFL.ToggleField, { label: trans_string('LABEL_FILTER_TAG_HUMOR', 'Humor'), checked: humor, onChange: setHumor }),
                window.SP_REACT.createElement(DFL.ToggleField, { label: trans_string('LABEL_FILTER_TAG_EPILEPSY', 'Epilepsy'), checked: epilepsy, onChange: setEpilepsy }),
                window.SP_REACT.createElement(DFL.ToggleField, { label: trans_string('LABEL_FILTER_TAG_UNTAGGED', 'Untagged'), checked: untagged, onChange: setUntagged }))),
        compareFilterWithDefaults(assetType, filters) && (window.SP_REACT.createElement(DFL.DialogFooter, null,
            window.SP_REACT.createElement(DFL.DialogButton, { onClick: resetFilters }, trans_string('ACTION_FILTER_RESET', 'Reset Filters'))))));
};

const SearchContext = SP_REACT.createContext({});
let abortCont = null;
const AssetSearchContext = ({ children }) => {
    const { set, get } = useSettings();
    const { appId, searchAssets, searchGames, getSgdbGame, appOverview } = useSGDB();
    const [assets, setAssets] = SP_REACT.useState([]);
    const [currentFilters, setCurrentFilters] = SP_REACT.useState();
    const [isFilterActive, setIsFilterActive] = SP_REACT.useState(false);
    const [loading, setLoading] = SP_REACT.useState(false);
    const [selectedGame, setSelectedGame] = SP_REACT.useState();
    const [externalSgdbData, setExternalSgdbData] = SP_REACT.useState(null);
    const [moreLoading, setMoreLoading] = SP_REACT.useState(false);
    const [endReached, setEndReached] = SP_REACT.useState(false);
    const [page, setPage] = SP_REACT.useState(0);
    const showGameSelection = SP_REACT.useCallback(() => {
        DFL.showModal(window.SP_REACT.createElement(GameSelectionModal, { defaultTerm: appOverview.display_name, searchGames: searchGames, onSelect: (game) => {
                setSelectedGame(game);
                set(`nonsteam_${appId}`, game);
            } }));
    }, [appId, appOverview.display_name, searchGames, set]);
    const searchAndSetAssets = SP_REACT.useMemo(() => debounce$1(async (assetType, page, filters, onSuccess) => {
        if (appOverview?.BIsModOrShortcut() && !selectedGame)
            return;
        if (abortCont)
            abortCont?.abort();
        abortCont = new AbortController();
        try {
            setCurrentFilters(filters);
            setIsFilterActive(compareFilterWithDefaults(assetType, filters));
            const resp = await searchAssets(assetType, {
                gameId: selectedGame?.id,
                page,
                filters,
                signal: abortCont.signal,
            });
            setAssets(resp);
            setEndReached(false);
            setPage(page + 1); // set to next page so correct page is requested when loadMore() is used
            onSuccess?.();
        }
        catch (err) {
            if (err.name === 'AbortError') ;
            else if (err?.status === 404) {
                showGameSelection();
            }
            else {
                toaster.toast({
                    title: 'SteamGridDB API Error',
                    body: err.message,
                    icon: window.SP_REACT.createElement(MenuIcon, { fill: "#f3171e" }),
                });
                if (selectedGame) {
                    set(`nonsteam_${appId}`, false);
                }
            }
        }
    }, 500), [appId, appOverview, searchAssets, showGameSelection, selectedGame, set]);
    const loadMore = SP_REACT.useMemo(() => debounce$1(async (assetType, onSuccess) => {
        if (appOverview?.BIsModOrShortcut() && !selectedGame)
            return;
        if (abortCont)
            abortCont?.abort();
        abortCont = new AbortController();
        if (assets.length === 0)
            return;
        try {
            setMoreLoading(true);
            const resp = await searchAssets(assetType, {
                page,
                gameId: selectedGame?.id,
                filters: currentFilters,
                signal: abortCont.signal,
            });
            setAssets((assets) => [...assets, ...resp]);
            setMoreLoading(false);
            if (resp.length > 0) {
                setPage((x) => x + 1);
            }
            if (resp.length === 0) {
                setEndReached(true);
            }
            onSuccess?.(resp);
        }
        catch (err) {
            if (err.name === 'AbortError') ;
            else {
                toaster.toast({
                    title: 'SteamGridDB API Error',
                    body: err.message,
                    icon: window.SP_REACT.createElement(MenuIcon, { fill: "#f3171e" }),
                });
            }
        }
    }, 500), [appOverview, assets.length, currentFilters, page, searchAssets, selectedGame]);
    const handleFiltersSave = SP_REACT.useCallback(async (assetType, filters, game) => {
        const filtersChanged = !isEqual(filters, currentFilters);
        const gameChanged = game?.id !== selectedGame?.id;
        if (filtersChanged) {
            setLoading(true);
            searchAndSetAssets(assetType, 0, filters, () => {
                setLoading(false);
            });
            set(`filters_${assetType}`, filters, true);
            setCurrentFilters(filters);
        }
        if (gameChanged) {
            setSelectedGame(game ?? false);
            // save selected game to reuse for this shortcut
            set(`nonsteam_${appId}`, game ?? false);
        }
        if (filtersChanged || gameChanged) {
            setMoreLoading(false);
        }
        setIsFilterActive(compareFilterWithDefaults(assetType, filters));
    }, [currentFilters, selectedGame, searchAndSetAssets, set, appId]);
    const openFilters = SP_REACT.useCallback(async (assetType) => {
        const defaultFilters = await get(`filters_${assetType}`, null);
        DFL.showModal((window.SP_REACT.createElement(FiltersModal, { assetType: assetType, onSave: handleFiltersSave, defaultFilters: defaultFilters, defaultSelectedGame: selectedGame, defaultSearchTerm: selectedGame?.name || appOverview.display_name, isNonsteam: appOverview.BIsModOrShortcut(), searchGames: searchGames })), window);
    }, [appOverview, get, handleFiltersSave, searchGames, selectedGame]);
    SP_REACT.useEffect(() => {
        if (!appOverview)
            return;
        (async () => {
            setLoading(true);
            const game = await get(`nonsteam_${appId}`, false);
            if (game) {
                setSelectedGame(game);
            }
            else {
                if (appOverview.BIsModOrShortcut()) {
                    const gameRes = await searchGames(appOverview.display_name);
                    if (gameRes.length) {
                        setSelectedGame(gameRes[0]);
                    }
                    else {
                        showGameSelection();
                    }
                }
            }
            setLoading(false);
        })();
    }, [appOverview, appId, get, searchGames, set, showGameSelection]);
    SP_REACT.useEffect(() => {
        if (!selectedGame)
            return;
        (async () => {
            const sgdbGame = await getSgdbGame(selectedGame);
            setExternalSgdbData(sgdbGame.external_platform_data);
        })();
    }, [getSgdbGame, selectedGame]);
    const value = SP_REACT.useMemo(() => ({
        loading,
        assets,
        searchAndSetAssets,
        loadMore,
        selectedGame,
        externalSgdbData,
        openFilters,
        isFilterActive,
        moreLoading,
        endReached,
    }), [loading, assets, searchAndSetAssets, loadMore, selectedGame, externalSgdbData, openFilters, isFilterActive, moreLoading, endReached]);
    return (window.SP_REACT.createElement(SearchContext.Provider, { value: value }, children));
};
const useAssetSearch = () => SP_REACT.useContext(SearchContext);

var style = ".sgdb-modal-details-wrapper {\n  display: flex;\n  gap: 1em;\n}\n.sgdb-modal-details-wrapper.wide {\n  flex-direction: column;\n}\n.sgdb-modal-details-wrapper.wide > .asset-box-wrap {\n  max-width: 100%;\n  margin: 0 auto;\n}\n.sgdb-modal-details-wrapper.wide > .asset-box-wrap .image-wrap {\n  margin-top: 0;\n}\n.sgdb-modal-details-wrapper.wide .notes {\n  max-width: 100%;\n}\n.sgdb-modal-details .asset-box-wrap {\n  display: flex;\n  align-items: center;\n  flex-wrap: wrap;\n  position: relative;\n}\n.sgdb-modal-details .asset-box-wrap .image-wrap {\n  background: url(\"/images/defaultappimage.png\") center center;\n  background-size: cover;\n  position: relative;\n  width: 100%;\n  margin-top: auto;\n  outline-style: solid;\n  outline-color: transparent;\n  outline-width: 2px;\n  transition: outline-color ease-in-out 200ms;\n  /* aspect-ratio: 2/3; CEF version doesn't support this, gotta do it the painful way */\n}\n.sgdb-modal-details .asset-box-wrap .image-wrap.gpfocus, .sgdb-modal-details .asset-box-wrap .image-wrap:hover {\n  z-index: 10005;\n}\n.sgdb-modal-details .asset-box-wrap .image-wrap.type-logo {\n  padding-bottom: 0 !important;\n  height: 185px;\n}\n.sgdb-modal-details .asset-box-wrap .image-wrap.type-logo > .thumb {\n  padding: 0.5em;\n}\n.sgdb-modal-details .asset-box-wrap .image-wrap.type-hero > .thumb img.blur-bg,\n.sgdb-modal-details .asset-box-wrap .image-wrap.type-hero > .thumb video.blur-bg {\n  transform: scale(1);\n}\n.sgdb-modal-details .asset-box-wrap .image-wrap.type-logo > .thumb, .sgdb-modal-details .asset-box-wrap .image-wrap.type-icon > .thumb {\n  background: url(\"/images/defaultappimage.png\") center center;\n  background-size: cover;\n}\n.sgdb-modal-details .asset-box-wrap .image-wrap.type-logo > .thumb img,\n.sgdb-modal-details .asset-box-wrap .image-wrap.type-logo > .thumb video, .sgdb-modal-details .asset-box-wrap .image-wrap.type-icon > .thumb img,\n.sgdb-modal-details .asset-box-wrap .image-wrap.type-icon > .thumb video {\n  position: static;\n  width: auto;\n}\n.sgdb-modal-details .asset-box-wrap .image-wrap.type-logo > .thumb img.blur-bg,\n.sgdb-modal-details .asset-box-wrap .image-wrap.type-logo > .thumb video.blur-bg, .sgdb-modal-details .asset-box-wrap .image-wrap.type-icon > .thumb img.blur-bg,\n.sgdb-modal-details .asset-box-wrap .image-wrap.type-icon > .thumb video.blur-bg {\n  display: none;\n}\n.sgdb-modal-details .asset-box-wrap .image-wrap .preload-spinner {\n  position: absolute;\n  height: 2em;\n  opacity: 1;\n  transition: opacity 200ms linear;\n}\n.sgdb-modal-details .asset-box-wrap .image-wrap .preload-spinner[data-loaded=true] {\n  opacity: 0;\n}\n.sgdb-modal-details .asset-box-wrap .image-wrap > .thumb {\n  position: absolute;\n  left: 0;\n  right: 0;\n  top: 0;\n  bottom: 0;\n}\n.sgdb-modal-details .asset-box-wrap .image-wrap > .thumb img,\n.sgdb-modal-details .asset-box-wrap .image-wrap > .thumb video {\n  position: absolute;\n  left: 0;\n  right: 0;\n  top: 0;\n  bottom: 0;\n  max-height: 100%;\n  max-width: 100%;\n  width: 100%;\n  height: auto;\n  margin: 0 auto;\n  z-index: 1;\n  opacity: 0;\n  transition: opacity 200ms linear;\n}\n.sgdb-modal-details .asset-box-wrap .image-wrap > .thumb img[data-loaded=true],\n.sgdb-modal-details .asset-box-wrap .image-wrap > .thumb video[data-loaded=true] {\n  opacity: 1;\n}\n.sgdb-modal-details .asset-box-wrap .image-wrap > .thumb img.blur-bg,\n.sgdb-modal-details .asset-box-wrap .image-wrap > .thumb video.blur-bg {\n  filter: saturate(2) blur(20px);\n  transform: scale(1.25);\n  opacity: 0;\n  z-index: -2;\n}\n.sgdb-modal-details .asset-box-wrap .dload-overlay {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  position: absolute;\n  left: 0;\n  right: 0;\n  top: 0;\n  bottom: 0;\n  opacity: 0;\n  z-index: -3;\n  background: rgba(0, 0, 0, 0.85);\n  transition: opacity ease 100ms, z-index 0s 100ms;\n}\n.sgdb-modal-details .asset-box-wrap .dload-overlay.downloading {\n  opacity: 1;\n  z-index: 2;\n  transition: opacity ease 100ms;\n}\n.sgdb-modal-details .asset-box-wrap .dload-overlay > img {\n  width: 100%;\n  max-height: 50%;\n  max-width: 4em;\n}\n.sgdb-modal-details .asset-box-wrap .author {\n  display: flex;\n  align-items: center;\n  gap: 0.5em;\n  font-size: 0.65em;\n  padding-top: 0.15em;\n  margin-top: auto;\n  overflow: hidden;\n  z-index: 10006;\n  text-shadow: 0px 1px 1px #000;\n}\n.sgdb-modal-details .asset-box-wrap .author > span {\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n}\n.sgdb-modal-details .asset-box-wrap .author img {\n  width: 1em;\n  height: 1em;\n}\n.sgdb-modal-details .asset-box-wrap .chips {\n  margin: 0;\n  padding: 0;\n  list-style: none;\n  display: flex;\n  flex-direction: column;\n  position: absolute;\n  right: -0.5em;\n  top: 0;\n  font-size: 0.5em;\n  font-weight: bold;\n  text-transform: uppercase;\n  z-index: -1;\n}\n.sgdb-modal-details .asset-box-wrap .chips .chip {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  background: var(--chip-color);\n  color: var(--chip-text-color);\n  padding: 0.3em 0.8em;\n  min-height: 2em;\n  gap: 0.3em;\n  border-radius: 0 5px 5px 0;\n  transition: transform cubic-bezier(0.33, 1, 0.68, 1) 300ms;\n  will-change: transform;\n}\n.sgdb-modal-details .asset-box-wrap .chips .chip:nth-child(1n) {\n  transition-delay: 120ms;\n}\n.sgdb-modal-details .asset-box-wrap .chips .chip:nth-child(2n) {\n  transition-delay: 240ms;\n}\n.sgdb-modal-details .asset-box-wrap .chips .chip:nth-child(3n) {\n  transition-delay: 360ms;\n}\n.sgdb-modal-details .asset-box-wrap .chips .chip:nth-child(4n) {\n  transition-delay: 480ms;\n}\n.sgdb-modal-details .asset-box-wrap .chips .chip:nth-child(5n) {\n  transition-delay: 600ms;\n}\n.sgdb-modal-details .asset-box-wrap .chips.chips-left {\n  right: auto;\n  left: -0.5em;\n}\n.sgdb-modal-details .asset-box-wrap .chips.chips-left .chip {\n  border-radius: 5px 0 0 5px;\n}\n.sgdb-modal-details .asset-box-wrap .image-wrap:hover {\n  cursor: pointer;\n  outline-color: rgba(255, 255, 255, 0.5);\n}\n.sgdb-modal-details .asset-box-wrap .image-wrap.gpfocus.type-hero > .thumb img.blur-bg,\n.sgdb-modal-details .asset-box-wrap .image-wrap.gpfocus.type-hero > .thumb video.blur-bg,\n.sgdb-modal-details .asset-box-wrap .image-wrap:hover.type-hero > .thumb img.blur-bg,\n.sgdb-modal-details .asset-box-wrap .image-wrap:hover.type-hero > .thumb video.blur-bg {\n  opacity: 0.65;\n}\n.sgdb-modal-details .asset-box-wrap .image-wrap.gpfocus .chips > .chip,\n.sgdb-modal-details .asset-box-wrap .image-wrap:hover .chips > .chip {\n  transform: translateX(calc(100% - 0.5em - 1px));\n  box-shadow: 1px 2px 3px rgba(0, 0, 0, 0.25);\n}\n.sgdb-modal-details .asset-box-wrap .image-wrap.gpfocus .chips.chips-left > .chip,\n.sgdb-modal-details .asset-box-wrap .image-wrap:hover .chips.chips-left > .chip {\n  transform: translateX(calc(-100% + 0.5em + 1px));\n  box-shadow: -2px 2px 3px rgba(0, 0, 0, 0.25);\n}\n.sgdb-modal-details .asset-box-wrap .image-wrap.gpfocus > .thumb img.blur-bg,\n.sgdb-modal-details .asset-box-wrap .image-wrap.gpfocus > .thumb video.blur-bg,\n.sgdb-modal-details .asset-box-wrap .image-wrap:hover > .thumb img.blur-bg,\n.sgdb-modal-details .asset-box-wrap .image-wrap:hover > .thumb video.blur-bg {\n  opacity: 0.4;\n}\n.sgdb-modal-details .asset-box-wrap {\n  width: 100%;\n  max-width: 46%;\n}\n.sgdb-modal-details .info {\n  display: flex;\n  flex-direction: column;\n  flex: 1;\n}\n.sgdb-modal-details .meta {\n  text-transform: capitalize;\n  opacity: 0.5;\n  font-size: 0.8em;\n  text-align: right;\n}\n.sgdb-modal-details .author {\n  display: flex;\n  align-items: center;\n  outline-style: solid;\n  outline-color: transparent;\n  outline-width: 2px;\n  transition: outline-color ease-in-out 200ms;\n  margin-top: 1em;\n  gap: 0.5em;\n  font-weight: bold;\n}\n.sgdb-modal-details .author:hover {\n  cursor: pointer;\n  outline-color: rgba(255, 255, 255, 0.5);\n}\n.sgdb-modal-details .author > img {\n  width: 32px;\n  height: 32px;\n}\n.sgdb-modal-details .notes {\n  max-width: 300px;\n  word-break: break-word;\n}\n\n.sgdb-modal-filters .game-filter-content {\n  display: flex;\n  flex-direction: row;\n  gap: 10px;\n}\n.sgdb-modal-filters .game-filter-content > .custom-game-value {\n  width: 280px;\n  max-width: 100%;\n}\n.sgdb-modal-filters .game-filter-content > .clear-custom-game {\n  padding: 10px;\n  max-width: 40px;\n  line-height: 10px !important;\n  min-width: auto;\n}\n\n.sgdb-modal-gameselect .gamelabel {\n  display: flex;\n  width: 100%;\n  gap: 0.2em;\n  font-weight: bold;\n}\n.sgdb-modal-gameselect .gamelabel .release-date {\n  font-weight: normal;\n  opacity: 0.5;\n}\n.sgdb-modal-gameselect .gamelabel .platform-types {\n  display: flex;\n  align-items: center;\n  gap: 0.2em;\n  margin-left: auto;\n}\n.sgdb-modal-gameselect .spinner {\n  width: 2em;\n  margin: 0 auto;\n  margin-top: 2em;\n}\n\n.sgdb-modal-logo-position .logo-positioner {\n  display: flex;\n  position: relative;\n  margin-top: calc(var(--basicui-header-height, 40px) + 1em);\n  width: 100%;\n  overflow: hidden;\n  align-items: center;\n  z-index: 1;\n}\n.sgdb-modal-logo-position .logo-positioner.is-mouse-resizing .logo-wrap-pos {\n  transition: none;\n}\n.sgdb-modal-logo-position .logo-positioner.is-mouse-resizing .logo-positioner-logo {\n  transition: none;\n}\n.sgdb-modal-logo-position .logo-positioner.is-mouse-resizing .logo-positioner-logo-img {\n  transition: none;\n}\n.sgdb-modal-logo-position .logo-positioner.spinnyboi {\n  height: var(--header-height, calc(80px + 20vw));\n}\n.sgdb-modal-logo-position .logo-positioner.spinnyboi > img {\n  margin: 0 auto;\n  width: 5em;\n  opacity: 0;\n  animation: 150ms linear 400ms 1 sgdb-fadeIn forwards;\n}\n.sgdb-modal-logo-position .logo-positioner.logo-border .logo-wrap .logo-anchor-guide,\n.sgdb-modal-logo-position .logo-positioner.logo-border .logo-wrap .guide-middlecontainer {\n  display: block;\n}\n.sgdb-modal-logo-position .logo-positioner.logo-border .logo-wrap .logo-positioner-logo {\n  outline: 3px #008ada solid;\n  pointer-events: all;\n}\n.sgdb-modal-logo-position .logo-positioner.pos-UpperLeft .logo-positioner-logo-img {\n  object-position: top left;\n}\n.sgdb-modal-logo-position .logo-positioner.pos-UpperLeft .logo-anchor-guide.guide-upperleft {\n  border-color: transparent;\n}\n.sgdb-modal-logo-position .logo-positioner.pos-BottomLeft .logo-positioner-logo-img {\n  object-position: bottom left;\n}\n.sgdb-modal-logo-position .logo-positioner.pos-BottomLeft .logo-anchor-guide.guide-bottomleft {\n  border-color: transparent;\n}\n.sgdb-modal-logo-position .logo-positioner.pos-UpperCenter .logo-positioner-logo-img {\n  object-position: top center;\n}\n.sgdb-modal-logo-position .logo-positioner.pos-UpperCenter .logo-anchor-guide.guide-top {\n  border-top-color: transparent;\n}\n.sgdb-modal-logo-position .logo-positioner.pos-CenterCenter .logo-positioner-logo-img {\n  object-position: center;\n}\n.sgdb-modal-logo-position .logo-positioner.pos-CenterCenter .logo-anchor-guide.guide-mid {\n  border-color: transparent;\n}\n.sgdb-modal-logo-position .logo-positioner.pos-BottomCenter .logo-positioner-logo-img {\n  object-position: bottom center;\n}\n.sgdb-modal-logo-position .logo-positioner.pos-BottomCenter .logo-anchor-guide.guide-bottom {\n  border-bottom-color: transparent;\n}\n.sgdb-modal-logo-position .logo-positioner .logo-outer-region {\n  position: absolute;\n  width: auto;\n  height: auto;\n  top: 16px;\n  bottom: 16px;\n  left: 26px;\n  right: 26px;\n}\n.sgdb-modal-logo-position .logo-positioner .logo-wrap {\n  position: absolute;\n  height: 100%;\n  top: 0;\n  width: 100%;\n}\n.sgdb-modal-logo-position .logo-positioner .logo-wrap .logo-anchor-guide,\n.sgdb-modal-logo-position .logo-positioner .logo-wrap .guide-middlecontainer {\n  display: none;\n  position: absolute;\n  z-index: 1;\n  box-sizing: border-box;\n}\n.sgdb-modal-logo-position .logo-positioner .logo-wrap .logo-anchor-guide {\n  border-color: #008ada;\n  border-width: 3px;\n  width: 12px;\n  height: 12px;\n  border-radius: 3px;\n  transition: border-color linear 200ms;\n  opacity: 0.65;\n  pointer-events: all;\n}\n.sgdb-modal-logo-position .logo-positioner .logo-wrap .logo-anchor-guide:hover {\n  cursor: pointer;\n  opacity: 1;\n}\n.sgdb-modal-logo-position .logo-positioner .logo-wrap .guide-upperleft {\n  border-left-style: solid;\n  border-top-style: solid;\n  top: 0;\n  left: 0;\n}\n.sgdb-modal-logo-position .logo-positioner .logo-wrap .guide-bottomleft {\n  border-left-style: solid;\n  border-bottom-style: solid;\n  bottom: 0;\n  left: 0;\n}\n.sgdb-modal-logo-position .logo-positioner .logo-wrap .guide-middlecontainer {\n  width: 15px;\n  height: 100%;\n  left: 50%;\n  top: 0;\n  transform: translateX(-50%);\n  pointer-events: none;\n  z-index: 3;\n}\n.sgdb-modal-logo-position .logo-positioner .logo-wrap .guide-middlecontainer .guide-top {\n  border-top-style: solid;\n  top: 0;\n}\n.sgdb-modal-logo-position .logo-positioner .logo-wrap .guide-middlecontainer .guide-mid {\n  border-width: 3px;\n  width: 15px;\n  height: 15px;\n  top: 50%;\n  border-style: solid;\n  transform: translateY(-50%);\n}\n.sgdb-modal-logo-position .logo-positioner .logo-wrap .guide-middlecontainer .guide-bottom {\n  border-bottom-style: solid;\n  bottom: 0;\n}\n.sgdb-modal-logo-position .logo-positioner .logo-wrap-pos {\n  position: relative;\n  width: 100%;\n  height: 100%;\n  transform: translate(var(--logo-left), var(--logo-top));\n  transition: transform ease 250ms;\n  pointer-events: none;\n  z-index: 2;\n}\n.sgdb-modal-logo-position .logo-positioner .logo-positioner-logo {\n  display: flex;\n  align-items: flex-start;\n  position: relative;\n  z-index: 1;\n  width: var(--logo-width);\n  height: var(--logo-height);\n  transition: width ease 100ms, height ease 100ms;\n  cursor: move;\n}\n.sgdb-modal-logo-position .logo-positioner .logo-positioner-logo-img {\n  width: 100%;\n  height: 100%;\n  object-fit: contain;\n  transition: object-position ease 250ms;\n}\n.sgdb-modal-logo-position .logo-positioner-hero {\n  width: 100%;\n}\n.sgdb-modal-logo-position .logo-positioner-instructions {\n  display: flex;\n  justify-content: center;\n  flex-wrap: wrap;\n  list-style: none;\n  gap: 2em;\n}\n.sgdb-modal-logo-position .logo-positioner-instructions li {\n  display: flex;\n  align-items: center;\n  cursor: pointer;\n  gap: 0.75em;\n}\n.sgdb-modal-logo-position .logo-positioner-instructions svg {\n  width: 32px;\n  height: 32px;\n}\n\n.sgdb-modal-official-assets .official-steam-asset {\n  margin: 0 auto;\n}\n.sgdb-modal-official-assets .official-steam-asset.grid_l {\n  max-width: 60%;\n}\n.MediumWindow .sgdb-modal-official-assets .official-steam-asset.grid_p {\n  max-width: 39%;\n}\n\n.WideWindow .sgdb-modal-official-assets .official-steam-asset.grid_p {\n  max-width: 55%;\n}\n\n.sgdb-modal-official-assets .official-steam-asset.hero, .sgdb-modal-official-assets .official-steam-asset.logo {\n  max-width: 100%;\n}\n.sgdb-modal-official-assets .asset-box-wrap {\n  display: flex;\n  align-items: center;\n  flex-wrap: wrap;\n  position: relative;\n}\n.sgdb-modal-official-assets .asset-box-wrap .image-wrap {\n  background: url(\"/images/defaultappimage.png\") center center;\n  background-size: cover;\n  position: relative;\n  width: 100%;\n  margin-top: auto;\n  outline-style: solid;\n  outline-color: transparent;\n  outline-width: 2px;\n  transition: outline-color ease-in-out 200ms;\n  /* aspect-ratio: 2/3; CEF version doesn't support this, gotta do it the painful way */\n}\n.sgdb-modal-official-assets .asset-box-wrap .image-wrap.gpfocus, .sgdb-modal-official-assets .asset-box-wrap .image-wrap:hover {\n  z-index: 10005;\n}\n.sgdb-modal-official-assets .asset-box-wrap .image-wrap.type-logo {\n  padding-bottom: 0 !important;\n  height: 185px;\n}\n.sgdb-modal-official-assets .asset-box-wrap .image-wrap.type-logo > .thumb {\n  padding: 0.5em;\n}\n.sgdb-modal-official-assets .asset-box-wrap .image-wrap.type-hero > .thumb img.blur-bg,\n.sgdb-modal-official-assets .asset-box-wrap .image-wrap.type-hero > .thumb video.blur-bg {\n  transform: scale(1);\n}\n.sgdb-modal-official-assets .asset-box-wrap .image-wrap.type-logo > .thumb, .sgdb-modal-official-assets .asset-box-wrap .image-wrap.type-icon > .thumb {\n  background: url(\"/images/defaultappimage.png\") center center;\n  background-size: cover;\n}\n.sgdb-modal-official-assets .asset-box-wrap .image-wrap.type-logo > .thumb img,\n.sgdb-modal-official-assets .asset-box-wrap .image-wrap.type-logo > .thumb video, .sgdb-modal-official-assets .asset-box-wrap .image-wrap.type-icon > .thumb img,\n.sgdb-modal-official-assets .asset-box-wrap .image-wrap.type-icon > .thumb video {\n  position: static;\n  width: auto;\n}\n.sgdb-modal-official-assets .asset-box-wrap .image-wrap.type-logo > .thumb img.blur-bg,\n.sgdb-modal-official-assets .asset-box-wrap .image-wrap.type-logo > .thumb video.blur-bg, .sgdb-modal-official-assets .asset-box-wrap .image-wrap.type-icon > .thumb img.blur-bg,\n.sgdb-modal-official-assets .asset-box-wrap .image-wrap.type-icon > .thumb video.blur-bg {\n  display: none;\n}\n.sgdb-modal-official-assets .asset-box-wrap .image-wrap .preload-spinner {\n  position: absolute;\n  height: 2em;\n  opacity: 1;\n  transition: opacity 200ms linear;\n}\n.sgdb-modal-official-assets .asset-box-wrap .image-wrap .preload-spinner[data-loaded=true] {\n  opacity: 0;\n}\n.sgdb-modal-official-assets .asset-box-wrap .image-wrap > .thumb {\n  position: absolute;\n  left: 0;\n  right: 0;\n  top: 0;\n  bottom: 0;\n}\n.sgdb-modal-official-assets .asset-box-wrap .image-wrap > .thumb img,\n.sgdb-modal-official-assets .asset-box-wrap .image-wrap > .thumb video {\n  position: absolute;\n  left: 0;\n  right: 0;\n  top: 0;\n  bottom: 0;\n  max-height: 100%;\n  max-width: 100%;\n  width: 100%;\n  height: auto;\n  margin: 0 auto;\n  z-index: 1;\n  opacity: 0;\n  transition: opacity 200ms linear;\n}\n.sgdb-modal-official-assets .asset-box-wrap .image-wrap > .thumb img[data-loaded=true],\n.sgdb-modal-official-assets .asset-box-wrap .image-wrap > .thumb video[data-loaded=true] {\n  opacity: 1;\n}\n.sgdb-modal-official-assets .asset-box-wrap .image-wrap > .thumb img.blur-bg,\n.sgdb-modal-official-assets .asset-box-wrap .image-wrap > .thumb video.blur-bg {\n  filter: saturate(2) blur(20px);\n  transform: scale(1.25);\n  opacity: 0;\n  z-index: -2;\n}\n.sgdb-modal-official-assets .asset-box-wrap .dload-overlay {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  position: absolute;\n  left: 0;\n  right: 0;\n  top: 0;\n  bottom: 0;\n  opacity: 0;\n  z-index: -3;\n  background: rgba(0, 0, 0, 0.85);\n  transition: opacity ease 100ms, z-index 0s 100ms;\n}\n.sgdb-modal-official-assets .asset-box-wrap .dload-overlay.downloading {\n  opacity: 1;\n  z-index: 2;\n  transition: opacity ease 100ms;\n}\n.sgdb-modal-official-assets .asset-box-wrap .dload-overlay > img {\n  width: 100%;\n  max-height: 50%;\n  max-width: 4em;\n}\n.sgdb-modal-official-assets .asset-box-wrap .author {\n  display: flex;\n  align-items: center;\n  gap: 0.5em;\n  font-size: 0.65em;\n  padding-top: 0.15em;\n  margin-top: auto;\n  overflow: hidden;\n  z-index: 10006;\n  text-shadow: 0px 1px 1px #000;\n}\n.sgdb-modal-official-assets .asset-box-wrap .author > span {\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n}\n.sgdb-modal-official-assets .asset-box-wrap .author img {\n  width: 1em;\n  height: 1em;\n}\n.sgdb-modal-official-assets .asset-box-wrap .chips {\n  margin: 0;\n  padding: 0;\n  list-style: none;\n  display: flex;\n  flex-direction: column;\n  position: absolute;\n  right: -0.5em;\n  top: 0;\n  font-size: 0.5em;\n  font-weight: bold;\n  text-transform: uppercase;\n  z-index: -1;\n}\n.sgdb-modal-official-assets .asset-box-wrap .chips .chip {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  background: var(--chip-color);\n  color: var(--chip-text-color);\n  padding: 0.3em 0.8em;\n  min-height: 2em;\n  gap: 0.3em;\n  border-radius: 0 5px 5px 0;\n  transition: transform cubic-bezier(0.33, 1, 0.68, 1) 300ms;\n  will-change: transform;\n}\n.sgdb-modal-official-assets .asset-box-wrap .chips .chip:nth-child(1n) {\n  transition-delay: 120ms;\n}\n.sgdb-modal-official-assets .asset-box-wrap .chips .chip:nth-child(2n) {\n  transition-delay: 240ms;\n}\n.sgdb-modal-official-assets .asset-box-wrap .chips .chip:nth-child(3n) {\n  transition-delay: 360ms;\n}\n.sgdb-modal-official-assets .asset-box-wrap .chips .chip:nth-child(4n) {\n  transition-delay: 480ms;\n}\n.sgdb-modal-official-assets .asset-box-wrap .chips .chip:nth-child(5n) {\n  transition-delay: 600ms;\n}\n.sgdb-modal-official-assets .asset-box-wrap .chips.chips-left {\n  right: auto;\n  left: -0.5em;\n}\n.sgdb-modal-official-assets .asset-box-wrap .chips.chips-left .chip {\n  border-radius: 5px 0 0 5px;\n}\n.sgdb-modal-official-assets .asset-box-wrap .image-wrap:hover {\n  cursor: pointer;\n  outline-color: rgba(255, 255, 255, 0.5);\n}\n.sgdb-modal-official-assets .asset-box-wrap .image-wrap.gpfocus.type-hero > .thumb img.blur-bg,\n.sgdb-modal-official-assets .asset-box-wrap .image-wrap.gpfocus.type-hero > .thumb video.blur-bg,\n.sgdb-modal-official-assets .asset-box-wrap .image-wrap:hover.type-hero > .thumb img.blur-bg,\n.sgdb-modal-official-assets .asset-box-wrap .image-wrap:hover.type-hero > .thumb video.blur-bg {\n  opacity: 0.65;\n}\n.sgdb-modal-official-assets .asset-box-wrap .image-wrap.gpfocus .chips > .chip,\n.sgdb-modal-official-assets .asset-box-wrap .image-wrap:hover .chips > .chip {\n  transform: translateX(calc(100% - 0.5em - 1px));\n  box-shadow: 1px 2px 3px rgba(0, 0, 0, 0.25);\n}\n.sgdb-modal-official-assets .asset-box-wrap .image-wrap.gpfocus .chips.chips-left > .chip,\n.sgdb-modal-official-assets .asset-box-wrap .image-wrap:hover .chips.chips-left > .chip {\n  transform: translateX(calc(-100% + 0.5em + 1px));\n  box-shadow: -2px 2px 3px rgba(0, 0, 0, 0.25);\n}\n.sgdb-modal-official-assets .asset-box-wrap .image-wrap.gpfocus > .thumb img.blur-bg,\n.sgdb-modal-official-assets .asset-box-wrap .image-wrap.gpfocus > .thumb video.blur-bg,\n.sgdb-modal-official-assets .asset-box-wrap .image-wrap:hover > .thumb img.blur-bg,\n.sgdb-modal-official-assets .asset-box-wrap .image-wrap:hover > .thumb video.blur-bg {\n  opacity: 0.4;\n}\n\n#sgdb-wrap {\n  --asset-size: 120px;\n  margin-top: var(--basicui-header-height, 40px);\n  height: calc(100% - var(--basicui-header-height, 40px));\n  background: var(--gpSystemDarkestGrey, #0E141B);\n}\n#sgdb-wrap div[class*=gamepadtabbedpage_TabHeaderRowWrapper][class*=gamepadtabbedpage_Floating],\n#sgdb-wrap div[class*=gamepadtabbedpage_TabHeaderRowWrapper] {\n  background: #1B2838;\n}\n#sgdb-wrap .motd-wrap {\n  display: flex;\n  gap: 0.5em;\n  margin-top: 1em;\n}\n#sgdb-wrap .motd-wrap .motd {\n  flex: 1;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  position: relative;\n  background-size: cover;\n  background-repeat: no-repeat;\n  background-color: #05070a;\n  height: 40px;\n  overflow: hidden;\n  outline-style: solid;\n  outline-color: transparent;\n  outline-width: 2px;\n  transition: outline-color ease-in-out 200ms;\n  transition: outline-color ease-in-out 200ms, transform ease-out 200ms;\n}\n#sgdb-wrap .motd-wrap .motd:hover {\n  transform: scale(1.01);\n  cursor: pointer;\n  outline-color: rgba(255, 255, 255, 0.5);\n}\n#sgdb-wrap .motd-wrap .motd-video-bg {\n  position: absolute;\n  width: 100%;\n  z-index: 0;\n}\n#sgdb-wrap .motd-wrap .motd-inner {\n  display: grid;\n  height: 100%;\n  grid-template-columns: 1fr 100%;\n  grid-template-rows: 100%;\n  column-gap: 1em;\n  align-items: center;\n  z-index: 1;\n}\n#sgdb-wrap .motd-wrap .motd-inner > img {\n  height: 100%;\n  grid-row: 1;\n}\n#sgdb-wrap .motd-wrap .motd-inner .motd-text {\n  display: flex;\n  flex-direction: column;\n}\n#sgdb-wrap .motd-wrap .motd-inner .motd-text .motd-title {\n  font-size: 15px;\n  line-height: 15px;\n  font-weight: 500;\n}\n#sgdb-wrap .motd-wrap .motd-inner .motd-text .motd-subtitle {\n  font-size: 11px;\n  line-height: 11px;\n}\n#sgdb-wrap .motd-wrap .motd-hide {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  padding: 0;\n  width: 40px;\n  min-width: 40px;\n}\n#sgdb-wrap .tabcontents-wrap {\n  display: flex;\n  height: 100%;\n  width: 100%;\n  flex-direction: column;\n}\n#sgdb-wrap .spinnyboi {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  width: 100%;\n  position: fixed;\n  height: 100vh;\n  top: 0;\n  flex: 1;\n  left: 0;\n  right: 0;\n  z-index: 10008;\n  background: #0E141B;\n  transition: opacity ease-out 250ms, z-index 0s;\n  will-change: opacity;\n}\n#sgdb-wrap .spinnyboi > img {\n  transform: scale(0.75);\n  transition: transform ease-out 300ms;\n  will-change: transform;\n  margin-top: calc(var(--basicui-header-height) * -1);\n}\n#sgdb-wrap .spinnyboi.loaded {\n  z-index: -1;\n  opacity: 0;\n  transition-delay: 0ms, 300ms;\n}\n#sgdb-wrap .spinnyboi.loaded > img {\n  transform: scale(0.6);\n}\n#sgdb-wrap .sgdb-asset-toolbar {\n  display: flex;\n  width: 100%;\n  gap: var(--gpSpace-Gap, 0.6em);\n}\n#sgdb-wrap .sgdb-asset-toolbar .filter-buttons {\n  align-items: center;\n  display: flex;\n  gap: 0.5em;\n}\n#sgdb-wrap .sgdb-asset-toolbar .filter-buttons > button {\n  min-width: auto;\n  flex: 1;\n  white-space: nowrap;\n}\n#sgdb-wrap .sgdb-asset-toolbar .size-slider {\n  flex: 1;\n  padding: 0.5em 1em;\n  justify-content: center;\n}\n#sgdb-wrap #images-container {\n  display: grid;\n  padding-top: 1em;\n  padding-bottom: var(--gamepadui-current-footer-height);\n  justify-content: space-evenly;\n  grid-auto-flow: dense;\n  row-gap: 1em;\n  column-gap: 0.65em;\n  grid-template-columns: repeat(auto-fill, minmax(min(var(--asset-size), 100%), var(--asset-size)));\n}\n#sgdb-wrap #images-container .asset-box-wrap {\n  display: flex;\n  align-items: center;\n  flex-wrap: wrap;\n  position: relative;\n}\n#sgdb-wrap #images-container .asset-box-wrap .image-wrap {\n  background: url(\"/images/defaultappimage.png\") center center;\n  background-size: cover;\n  position: relative;\n  width: 100%;\n  margin-top: auto;\n  outline-style: solid;\n  outline-color: transparent;\n  outline-width: 2px;\n  transition: outline-color ease-in-out 200ms;\n  /* aspect-ratio: 2/3; CEF version doesn't support this, gotta do it the painful way */\n}\n#sgdb-wrap #images-container .asset-box-wrap .image-wrap.gpfocus, #sgdb-wrap #images-container .asset-box-wrap .image-wrap:hover {\n  z-index: 10005;\n}\n#sgdb-wrap #images-container .asset-box-wrap .image-wrap.type-logo {\n  padding-bottom: 0 !important;\n  height: 185px;\n}\n#sgdb-wrap #images-container .asset-box-wrap .image-wrap.type-logo > .thumb {\n  padding: 0.5em;\n}\n#sgdb-wrap #images-container .asset-box-wrap .image-wrap.type-hero > .thumb img.blur-bg,\n#sgdb-wrap #images-container .asset-box-wrap .image-wrap.type-hero > .thumb video.blur-bg {\n  transform: scale(1);\n}\n#sgdb-wrap #images-container .asset-box-wrap .image-wrap.type-logo > .thumb, #sgdb-wrap #images-container .asset-box-wrap .image-wrap.type-icon > .thumb {\n  background: url(\"/images/defaultappimage.png\") center center;\n  background-size: cover;\n}\n#sgdb-wrap #images-container .asset-box-wrap .image-wrap.type-logo > .thumb img,\n#sgdb-wrap #images-container .asset-box-wrap .image-wrap.type-logo > .thumb video, #sgdb-wrap #images-container .asset-box-wrap .image-wrap.type-icon > .thumb img,\n#sgdb-wrap #images-container .asset-box-wrap .image-wrap.type-icon > .thumb video {\n  position: static;\n  width: auto;\n}\n#sgdb-wrap #images-container .asset-box-wrap .image-wrap.type-logo > .thumb img.blur-bg,\n#sgdb-wrap #images-container .asset-box-wrap .image-wrap.type-logo > .thumb video.blur-bg, #sgdb-wrap #images-container .asset-box-wrap .image-wrap.type-icon > .thumb img.blur-bg,\n#sgdb-wrap #images-container .asset-box-wrap .image-wrap.type-icon > .thumb video.blur-bg {\n  display: none;\n}\n#sgdb-wrap #images-container .asset-box-wrap .image-wrap .preload-spinner {\n  position: absolute;\n  height: 2em;\n  opacity: 1;\n  transition: opacity 200ms linear;\n}\n#sgdb-wrap #images-container .asset-box-wrap .image-wrap .preload-spinner[data-loaded=true] {\n  opacity: 0;\n}\n#sgdb-wrap #images-container .asset-box-wrap .image-wrap > .thumb {\n  position: absolute;\n  left: 0;\n  right: 0;\n  top: 0;\n  bottom: 0;\n}\n#sgdb-wrap #images-container .asset-box-wrap .image-wrap > .thumb img,\n#sgdb-wrap #images-container .asset-box-wrap .image-wrap > .thumb video {\n  position: absolute;\n  left: 0;\n  right: 0;\n  top: 0;\n  bottom: 0;\n  max-height: 100%;\n  max-width: 100%;\n  width: 100%;\n  height: auto;\n  margin: 0 auto;\n  z-index: 1;\n  opacity: 0;\n  transition: opacity 200ms linear;\n}\n#sgdb-wrap #images-container .asset-box-wrap .image-wrap > .thumb img[data-loaded=true],\n#sgdb-wrap #images-container .asset-box-wrap .image-wrap > .thumb video[data-loaded=true] {\n  opacity: 1;\n}\n#sgdb-wrap #images-container .asset-box-wrap .image-wrap > .thumb img.blur-bg,\n#sgdb-wrap #images-container .asset-box-wrap .image-wrap > .thumb video.blur-bg {\n  filter: saturate(2) blur(20px);\n  transform: scale(1.25);\n  opacity: 0;\n  z-index: -2;\n}\n#sgdb-wrap #images-container .asset-box-wrap .dload-overlay {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  position: absolute;\n  left: 0;\n  right: 0;\n  top: 0;\n  bottom: 0;\n  opacity: 0;\n  z-index: -3;\n  background: rgba(0, 0, 0, 0.85);\n  transition: opacity ease 100ms, z-index 0s 100ms;\n}\n#sgdb-wrap #images-container .asset-box-wrap .dload-overlay.downloading {\n  opacity: 1;\n  z-index: 2;\n  transition: opacity ease 100ms;\n}\n#sgdb-wrap #images-container .asset-box-wrap .dload-overlay > img {\n  width: 100%;\n  max-height: 50%;\n  max-width: 4em;\n}\n#sgdb-wrap #images-container .asset-box-wrap .author {\n  display: flex;\n  align-items: center;\n  gap: 0.5em;\n  font-size: 0.65em;\n  padding-top: 0.15em;\n  margin-top: auto;\n  overflow: hidden;\n  z-index: 10006;\n  text-shadow: 0px 1px 1px #000;\n}\n#sgdb-wrap #images-container .asset-box-wrap .author > span {\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n}\n#sgdb-wrap #images-container .asset-box-wrap .author img {\n  width: 1em;\n  height: 1em;\n}\n#sgdb-wrap #images-container .asset-box-wrap .chips {\n  margin: 0;\n  padding: 0;\n  list-style: none;\n  display: flex;\n  flex-direction: column;\n  position: absolute;\n  right: -0.5em;\n  top: 0;\n  font-size: 0.5em;\n  font-weight: bold;\n  text-transform: uppercase;\n  z-index: -1;\n}\n#sgdb-wrap #images-container .asset-box-wrap .chips .chip {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  background: var(--chip-color);\n  color: var(--chip-text-color);\n  padding: 0.3em 0.8em;\n  min-height: 2em;\n  gap: 0.3em;\n  border-radius: 0 5px 5px 0;\n  transition: transform cubic-bezier(0.33, 1, 0.68, 1) 300ms;\n  will-change: transform;\n}\n#sgdb-wrap #images-container .asset-box-wrap .chips .chip:nth-child(1n) {\n  transition-delay: 120ms;\n}\n#sgdb-wrap #images-container .asset-box-wrap .chips .chip:nth-child(2n) {\n  transition-delay: 240ms;\n}\n#sgdb-wrap #images-container .asset-box-wrap .chips .chip:nth-child(3n) {\n  transition-delay: 360ms;\n}\n#sgdb-wrap #images-container .asset-box-wrap .chips .chip:nth-child(4n) {\n  transition-delay: 480ms;\n}\n#sgdb-wrap #images-container .asset-box-wrap .chips .chip:nth-child(5n) {\n  transition-delay: 600ms;\n}\n#sgdb-wrap #images-container .asset-box-wrap .chips.chips-left {\n  right: auto;\n  left: -0.5em;\n}\n#sgdb-wrap #images-container .asset-box-wrap .chips.chips-left .chip {\n  border-radius: 5px 0 0 5px;\n}\n#sgdb-wrap #images-container .asset-box-wrap .image-wrap:hover {\n  cursor: pointer;\n  outline-color: rgba(255, 255, 255, 0.5);\n}\n#sgdb-wrap #images-container .asset-box-wrap .image-wrap.gpfocus.type-hero > .thumb img.blur-bg,\n#sgdb-wrap #images-container .asset-box-wrap .image-wrap.gpfocus.type-hero > .thumb video.blur-bg,\n#sgdb-wrap #images-container .asset-box-wrap .image-wrap:hover.type-hero > .thumb img.blur-bg,\n#sgdb-wrap #images-container .asset-box-wrap .image-wrap:hover.type-hero > .thumb video.blur-bg {\n  opacity: 0.65;\n}\n#sgdb-wrap #images-container .asset-box-wrap .image-wrap.gpfocus .chips > .chip,\n#sgdb-wrap #images-container .asset-box-wrap .image-wrap:hover .chips > .chip {\n  transform: translateX(calc(100% - 0.5em - 1px));\n  box-shadow: 1px 2px 3px rgba(0, 0, 0, 0.25);\n}\n#sgdb-wrap #images-container .asset-box-wrap .image-wrap.gpfocus .chips.chips-left > .chip,\n#sgdb-wrap #images-container .asset-box-wrap .image-wrap:hover .chips.chips-left > .chip {\n  transform: translateX(calc(-100% + 0.5em + 1px));\n  box-shadow: -2px 2px 3px rgba(0, 0, 0, 0.25);\n}\n#sgdb-wrap #images-container .asset-box-wrap .image-wrap.gpfocus > .thumb img.blur-bg,\n#sgdb-wrap #images-container .asset-box-wrap .image-wrap.gpfocus > .thumb video.blur-bg,\n#sgdb-wrap #images-container .asset-box-wrap .image-wrap:hover > .thumb img.blur-bg,\n#sgdb-wrap #images-container .asset-box-wrap .image-wrap:hover > .thumb video.blur-bg {\n  opacity: 0.4;\n}\n#sgdb-wrap #local-images-container {\n  display: grid;\n  grid-template-columns: 30% 1fr;\n  gap: 1em;\n  margin-bottom: 2em;\n}\n#sgdb-wrap #local-images-container .asset-label {\n  text-align: left;\n  color: #fff;\n  font-weight: 500;\n  letter-spacing: 1px;\n  text-transform: uppercase;\n  line-height: 20px;\n  margin-bottom: 0.5em;\n}\n#sgdb-wrap #local-images-container .asset-wrap > .Panel {\n  position: relative;\n}\n#sgdb-wrap #local-images-container .asset-wrap > .Panel .action-overlay {\n  display: none;\n  position: absolute;\n  gap: 0.25em;\n  bottom: 0;\n  right: 0;\n  padding: 0.5em;\n  z-index: 2;\n}\n#sgdb-wrap #local-images-container .asset-wrap > .Panel .action-overlay .action-button {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  cursor: pointer;\n  box-sizing: border-box;\n  width: 2.5em;\n  height: 2.5em;\n  border-radius: 2px;\n  background-color: rgba(14, 20, 27, 0.75);\n  padding: 0.65em;\n  transition: background-color 120ms ease;\n}\n#sgdb-wrap #local-images-container .asset-wrap > .Panel .action-overlay .action-button > svg {\n  fill: #fff;\n  width: 100%;\n  height: 100%;\n}\n#sgdb-wrap #local-images-container .asset-wrap > .Panel .action-overlay .action-button.gpfocus, #sgdb-wrap #local-images-container .asset-wrap > .Panel .action-overlay .action-button:hover {\n  background-color: rgba(255, 255, 255, 0.75);\n}\n#sgdb-wrap #local-images-container .asset-wrap > .Panel .action-overlay .action-button.gpfocus > svg, #sgdb-wrap #local-images-container .asset-wrap > .Panel .action-overlay .action-button:hover > svg {\n  fill: #0e141b;\n}\n#sgdb-wrap #local-images-container .asset-wrap > .Panel.is-focused .action-overlay, #sgdb-wrap #local-images-container .asset-wrap > .Panel:hover .action-overlay {\n  display: flex;\n}\n#sgdb-wrap #local-images-container .asset-wrap-grid_p .asset {\n  padding-top: 150%;\n}\n#sgdb-wrap #local-images-container .asset-wrap-hero .asset {\n  padding-top: 32.2916666667%;\n}\n#sgdb-wrap #local-images-container .asset-wrap-hero .asset-img {\n  object-fit: cover;\n  height: 100%;\n}\n#sgdb-wrap #local-images-container .asset-wrap-logo {\n  flex: 1;\n  display: flex;\n  flex-direction: column;\n}\n#sgdb-wrap #local-images-container .asset-wrap-logo > .Panel.Focusable {\n  height: 100%;\n}\n#sgdb-wrap #local-images-container .asset-wrap-logo .asset {\n  height: 100%;\n}\n#sgdb-wrap #local-images-container .asset-wrap-logo .asset .asset-img {\n  padding: 0.25em;\n  margin: -0.25em auto;\n  width: auto;\n  max-width: 100%;\n  top: 50%;\n  transform: translateY(-50%);\n}\n#sgdb-wrap #local-images-container .asset-wrap-grid_l .asset {\n  padding-top: 46.7391304348%;\n}\n#sgdb-wrap #local-images-container .asset-wrap-icon .asset {\n  max-width: 32px;\n  max-height: 32px;\n  padding-top: 32px;\n}\n#sgdb-wrap #local-images-container .asset-wrap-icon .action-overlay {\n  padding: 0 !important;\n}\n#sgdb-wrap #local-images-container .asset-wrap-icon .action-overlay .action-button {\n  width: 32px !important;\n  height: 32px !important;\n  padding: 0.45em !important;\n}\n#sgdb-wrap #local-images-container .asset {\n  display: flex;\n  overflow: hidden;\n}\n#sgdb-wrap #local-images-container .asset .asset-img {\n  position: absolute;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  width: -webkit-fill-available;\n  max-height: 100%;\n}\n\n@keyframes sgdb-fadeIn {\n  from {\n    opacity: 0;\n  }\n  to {\n    opacity: 1;\n  }\n}";

const BeggingModal = ({ closeModal }) => {
    return (window.SP_REACT.createElement(DFL.ModalRoot, { className: "sgdb-modal sgdb-modal-begging", closeModal: closeModal, bDisableBackgroundDismiss: false, bHideCloseIcon: false },
        window.SP_REACT.createElement(DFL.DialogHeader, null, trans_string('LABEL_BEGGING_MODAL_TITLE', 'Thank you for using SteamGridDB!')),
        window.SP_REACT.createElement(DFL.DialogBody, null,
            window.SP_REACT.createElement("div", null, trans_string('LABEL_BEGGING_MODAL_DESC', 'Please consider donating to help with maintenance and server costs!'))),
        window.SP_REACT.createElement(DFL.DialogFooter, null,
            window.SP_REACT.createElement(DFL.ControlsList, null,
                window.SP_REACT.createElement(DFL.DialogButton, { onClick: closeModal, style: { height: '100%' } }, trans_string('Button_Close', 'Close', true)),
                window.SP_REACT.createElement(DFL.DialogButton, { onClick: () => {
                        DFL.Navigation.NavigateToExternalWeb('https://www.patreon.com/steamgriddb');
                        closeModal?.();
                    }, style: {
                        display: 'flex',
                        alignItems: 'center',
                        justifyContent: 'center',
                        gap: '.5em',
                    } },
                    window.SP_REACT.createElement(SiPatreon, { size: "1em" }),
                    " Patreon"),
                window.SP_REACT.createElement(DFL.DialogButton, { onClick: () => {
                        DFL.Navigation.NavigateToExternalWeb('https://ko-fi.com/steamgriddb');
                        closeModal?.();
                    }, style: {
                        display: 'flex',
                        alignItems: 'center',
                        justifyContent: 'center',
                        gap: '.5em',
                    } },
                    window.SP_REACT.createElement(SiKofi, { size: "1em" }),
                    " Ko-fi")))));
};

const LibraryImage = DFL.findModuleExport((e) => e?.toString && e.toString().includes('Either rgSources or app must be specified'));

var openFilePicker = (startPath, includeFiles, filter, filePickerSettings) => {
    return new Promise((resolve, reject) => {
        openFilePicker$1(0 /* FileSelectionType.FILE */, startPath, includeFiles, true, filter, filePickerSettings?.validFileExtensions, filePickerSettings?.defaultHidden, false).then(resolve, () => reject('User Canceled'));
    });
};

const getCustomLogoPosition = async (appId) => {
    try {
        const appoverview = await getAppOverview(appId);
        if (!appoverview)
            return null;
        return await l(() => {
            try {
                return window.appDetailsStore.GetCustomLogoPosition(appoverview) ?? null;
            }
            catch (error) {
                return null;
            }
        }, { timeout: 2000, intervalBetweenAttempts: 200 });
    }
    catch (err) {
        return null;
    }
};

var Dpad = 'http://127.0.0.1:1337/plugins/SteamGridDB/assets/dpad-daf9c40e.svg';

const getStylePositions = (pos, widthPct, heightPct) => {
    const positions = {
        BottomLeft: {
            bottom: 0,
            top: 100 - heightPct,
            left: 0,
            right: 100 - widthPct,
        },
        UpperLeft: {
            bottom: 100 - heightPct,
            top: 0,
            left: 0,
            right: 100 - widthPct,
        },
        CenterCenter: {
            bottom: (100 - heightPct) / 2,
            top: (100 - heightPct) / 2,
            left: (100 - widthPct) / 2,
            right: (100 - widthPct) / 2,
        },
        UpperCenter: {
            bottom: 100 - heightPct,
            top: 0,
            left: (100 - widthPct) / 2,
            right: (100 - widthPct) / 2,
        },
        BottomCenter: {
            bottom: 0,
            top: 100 - heightPct,
            left: (100 - widthPct) / 2,
            right: (100 - widthPct) / 2,
        },
    };
    return positions[pos];
};
const LogoPositioner = ({ app, logoPos, border, onAnchorClick, setLogoPos }) => {
    const [dragging, setDragging] = SP_REACT.useState(false);
    // Calculations when using cursor to resize are all refs for speed
    const positionerRef = SP_REACT.useRef(null);
    const lastX = SP_REACT.useRef(0);
    const lastY = SP_REACT.useRef(0);
    const heroBoundryRect = SP_REACT.useRef();
    const logoSizerWidth = SP_REACT.useRef(0);
    const logoSizerHeight = SP_REACT.useRef(0);
    const positions = logoPos ? getStylePositions(logoPos.pinnedPosition, logoPos.nWidthPct, logoPos.nHeightPct) : null;
    const handleMove = SP_REACT.useCallback((evt) => {
        const heroRect = heroBoundryRect.current;
        if (!dragging || !logoPos || !heroRect)
            return;
        let pctX = 0;
        let pctY = 0;
        const deltaX = evt.pageX - lastX.current;
        const deltaY = evt.pageY - lastY.current;
        if (['CenterCenter', 'UpperCenter', 'BottomCenter'].includes(logoPos.pinnedPosition)) {
            if (lastX.current < heroRect.width / 2 + heroRect.x) {
                pctX = (deltaX * -2 + logoSizerWidth.current) / heroRect.width;
            }
            else {
                pctX = (deltaX * 2 + logoSizerWidth.current) / heroRect.width;
            }
        }
        else {
            pctX = (deltaX + logoSizerWidth.current) / heroRect.width;
        }
        if (['UpperLeft', 'UpperCenter'].includes(logoPos.pinnedPosition)) {
            pctY = (deltaY + logoSizerHeight.current) / heroRect.height;
        }
        else if (logoPos.pinnedPosition === 'CenterCenter') {
            if (lastY.current > heroRect.height / 2 + heroRect.y) {
                pctY = (deltaY * 2 + logoSizerHeight.current) / heroRect.height;
            }
            else {
                pctY = (logoSizerHeight.current - deltaY * 2) / heroRect.height;
            }
        }
        else {
            pctY = (logoSizerHeight.current - deltaY) / heroRect.height;
        }
        setLogoPos((logoPos) => {
            const newLogoPos = { ...logoPos };
            newLogoPos.nWidthPct = pctX * 100;
            newLogoPos.nHeightPct = pctY * 100;
            newLogoPos.nWidthPct = Math.min(Math.max(newLogoPos.nWidthPct, 10), 100);
            newLogoPos.nHeightPct = Math.min(Math.max(newLogoPos.nHeightPct, 10), 100);
            return newLogoPos;
        });
    }, [dragging, logoPos, setLogoPos]);
    const handleMouseDown = (evt) => {
        lastX.current = evt.pageX;
        lastY.current = evt.pageY;
        const heroRect = evt.currentTarget?.closest('.logo-wrap')?.getBoundingClientRect();
        const logoRect = evt.currentTarget?.querySelector('.logo-positioner-logo')?.getBoundingClientRect();
        if (logoRect && heroRect) {
            heroBoundryRect.current = heroRect;
            logoSizerWidth.current = logoRect.width;
            logoSizerHeight.current = logoRect.height;
        }
        setDragging(true);
    };
    const handleMouseUp = () => {
        setDragging(false);
    };
    SP_REACT.useEffect(() => {
        const positionerEl = positionerRef.current;
        if (!positionerEl)
            return;
        const draggyEl = positionerEl.querySelector('.logo-wrap-pos');
        const modalOverlayEl = positionerEl.closest('.ModalOverlayContent.active');
        draggyEl?.addEventListener('mousedown', handleMouseDown);
        modalOverlayEl?.addEventListener('mousemove', handleMove);
        modalOverlayEl?.addEventListener('mouseup', handleMouseUp);
        return () => {
            draggyEl?.removeEventListener('mousedown', handleMouseDown);
            modalOverlayEl?.removeEventListener('mousemove', handleMove);
            modalOverlayEl?.removeEventListener('mouseup', handleMouseUp);
        };
    }, [handleMove, dragging]);
    if (!logoPos)
        return (window.SP_REACT.createElement("div", { className: "logo-positioner spinnyboi" },
            window.SP_REACT.createElement("img", { alt: "Loading...", src: "/images/steam_spinner.png" })));
    return (window.SP_REACT.createElement("div", { ref: positionerRef, className: DFL.joinClassNames(dragging ? 'is-mouse-resizing' : '', DFL.appDetailsHeaderClasses.TopCapsule, app.BIsModOrShortcut() ? DFL.appDetailsHeaderClasses.FallbackArt : '', 'logo-positioner', border ? 'logo-border' : '', `pos-${logoPos.pinnedPosition}`), style: {
            ['--logo-width']: `${logoPos.nWidthPct}%`,
            ['--logo-height']: `${logoPos.nHeightPct}%`,
            ['--logo-left']: positions ? `${positions.left}%` : undefined,
            ['--logo-top']: positions ? `${positions.top}%` : undefined,
        } },
        window.SP_REACT.createElement("div", { className: "logo-outer-region" },
            window.SP_REACT.createElement("div", { className: "logo-wrap" },
                window.SP_REACT.createElement("span", { className: "logo-anchor-guide guide-upperleft", onClick: () => onAnchorClick('UpperLeft') }),
                window.SP_REACT.createElement("span", { className: "logo-anchor-guide guide-bottomleft", onClick: () => onAnchorClick('BottomLeft') }),
                window.SP_REACT.createElement("span", { className: "guide-middlecontainer" },
                    window.SP_REACT.createElement("span", { className: "logo-anchor-guide guide-top", onClick: () => onAnchorClick('UpperCenter') }),
                    window.SP_REACT.createElement("span", { className: "logo-anchor-guide guide-mid", onClick: () => onAnchorClick('CenterCenter') }),
                    window.SP_REACT.createElement("span", { className: "logo-anchor-guide guide-bottom", onClick: () => onAnchorClick('BottomCenter') })),
                window.SP_REACT.createElement("div", { className: "logo-wrap-pos" },
                    window.SP_REACT.createElement(LibraryImage, { app: app, eAssetType: ASSET_TYPE.logo, allowCustomization: false, className: "logo-positioner-logo", imageClassName: "logo-positioner-logo-img", backgroundType: "transparent" })))),
        window.SP_REACT.createElement(LibraryImage, { app: app, eAssetType: ASSET_TYPE.hero, allowCustomization: false, neverShowTitle: true, backgroundType: "transparent", className: "logo-positioner-hero" })));
};
const LogoPositionerModal = ({ closeModal, appId }) => {
    const [overview, setOverview] = SP_REACT.useState(null);
    const [logoPos, setLogoPos] = SP_REACT.useState(null);
    const [showBorder, setShowBorder] = SP_REACT.useState(true);
    const resizeAmount = SP_REACT.useRef(.25);
    const handleCancel = () => {
        closeModal?.();
    };
    const handleSave = async () => {
        if (!overview || !logoPos)
            return;
        await window.appDetailsStore.SaveCustomLogoPosition(overview, logoPos);
        closeModal?.();
    };
    const handleReset = async () => {
        if (!overview || !logoPos)
            return;
        await window.appDetailsStore.ClearCustomLogoPosition(overview);
        closeModal?.();
    };
    const handleDirection = (evt) => {
        // Increase speed when held down
        resizeAmount.current = evt.detail.is_repeat ? Math.min(resizeAmount.current + 0.25, 2) : 0.25;
        setLogoPos((logoPos) => {
            const newLogoPos = { ...logoPos };
            switch (evt.detail.button) {
                case 9: // up
                    newLogoPos.nHeightPct = newLogoPos.nHeightPct + resizeAmount.current;
                    break;
                case 10: // down
                    newLogoPos.nHeightPct = newLogoPos.nHeightPct - resizeAmount.current;
                    break;
                case 11: // left
                    newLogoPos.nWidthPct = newLogoPos.nWidthPct - resizeAmount.current;
                    break;
                case 12: // right
                    newLogoPos.nWidthPct = newLogoPos.nWidthPct + resizeAmount.current;
                    break;
            }
            newLogoPos.nWidthPct = Math.min(Math.max(newLogoPos.nWidthPct, 0.01), 100);
            newLogoPos.nHeightPct = Math.min(Math.max(newLogoPos.nHeightPct, 0.01), 100);
            return newLogoPos;
        });
    };
    const handlePinPos = () => {
        const anchorPos = ['BottomLeft', 'UpperLeft', 'UpperCenter', 'CenterCenter', 'BottomCenter'];
        setLogoPos((logoPos) => {
            const currentPosIndex = anchorPos.indexOf(logoPos?.pinnedPosition ?? 'BottomLeft');
            const nextPosIndex = (currentPosIndex + 1) % anchorPos.length;
            return {
                ...logoPos,
                pinnedPosition: anchorPos[nextPosIndex],
            };
        });
    };
    const handleAnchorClick = (position) => {
        setLogoPos((logoPos) => {
            return {
                ...logoPos,
                pinnedPosition: position,
            };
        });
    };
    SP_REACT.useEffect(() => {
        if (appId) {
            (async () => {
                setOverview(await getAppOverview(appId));
            })();
        }
    }, [appId]);
    SP_REACT.useEffect(() => {
        if (overview) {
            (async () => {
                const appdetails = await getAppDetails(overview.appid);
                const logoPos = await getCustomLogoPosition(overview.appid) || // Loads from json
                    appdetails?.libraryAssets?.logoPosition || // Loads from default Steam app details
                    { pinnedPosition: 'BottomLeft', nWidthPct: 50, nHeightPct: 50 }; // Fallback when no data is available
                if (logoPos) {
                    setLogoPos(logoPos);
                }
            })();
        }
    }, [overview]);
    return (window.SP_REACT.createElement(DFL.Focusable, { noFocusRing: false, className: "sgdb-modal sgdb-modal-logo-position", onGamepadDirection: handleDirection, onCancel: handleCancel, onCancelButton: handleCancel, onCancelActionDescription: trans_string('Button_Cancel', 'Cancel', true), onActivate: handleSave, onOKActionDescription: trans_string('Button_Save', 'Save', true), onSecondaryButton: handlePinPos, onSecondaryActionDescription: trans_string('ACTION_CHANGE_POS_LOGO_ANCHOR_POINT', 'Change Anchor Point'), onOptionsButton: () => setShowBorder((x) => !x), onOptionsActionDescription: showBorder ? trans_string('ACTION_HIDE_POS_GUIDES', 'Hide Guides') : trans_string('ACTION_SHOW_OUTLINE', 'Show Guides'), onMenuButton: handleReset, onMenuActionDescription: trans_string('CustomArt_ResetLogoPosition', 'Reset Logo Position', true), onClick: (evt) => evt.preventDefault() },
        overview && (window.SP_REACT.createElement(LogoPositioner, { app: overview, logoPos: logoPos, border: showBorder, onAnchorClick: handleAnchorClick, setLogoPos: setLogoPos })),
        window.SP_REACT.createElement("ul", { className: "logo-positioner-instructions" },
            window.SP_REACT.createElement("li", null,
                window.SP_REACT.createElement("img", { src: Dpad }),
                " ",
                trans_string('ACTION_ADJUST_POS_SIZE', 'Adjust Size')),
            window.SP_REACT.createElement("li", { onClick: handlePinPos },
                window.SP_REACT.createElement(FooterGlyph, { button: 2, size: 1, type: 0 }),
                " ",
                trans_string('ACTION_CHANGE_POS_LOGO_ANCHOR_POINT', 'Change Anchor Point')))));
};

const AssetBlock = ({ app, browseStartPath, assetType, editable = true }) => {
    const { clearAsset, changeAsset, changeAssetFromUrl } = useSGDB();
    const [overview, setOverview] = SP_REACT.useState(app);
    const innerFocusRef = SP_REACT.useRef(null);
    const refreshing = SP_REACT.useRef(false);
    // god is dead
    const refreshOverview = async () => {
        if (refreshing.current)
            return;
        refreshing.current = true;
        setOverview(null);
        await new Promise((resolve) => setTimeout(resolve, 500));
        const appoverview = await getAppOverview(app.appid);
        if (assetType === 'icon' && appoverview?.icon_hash) {
            // Today i choose violence
            const hash = appoverview.icon_hash;
            // fuck up the hash to force render the icon file from the cache
            appoverview.icon_hash = String(new Date().getTime());
            setOverview(appoverview);
            // vibe for a bit
            await new Promise((resolve) => setTimeout(resolve, 300));
            // now put that shit back
            appoverview.icon_hash = hash;
        }
        setOverview(appoverview);
        refreshing.current = false;
    };
    const handleBrowse = async () => {
        const path = await openFilePicker(browseStartPath, true, undefined, {
            validFileExtensions: ['png', 'jpg', 'jpeg', 'gif', 'webp', 'apng', 'tiff', 'tga'],
        });
        await changeAssetFromUrl(path.path, assetType, true);
        await refreshOverview();
    };
    const handleBlank = async () => {
        await changeAsset('iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVQYV2NgYAAAAAMAAWgmWQ0AAAAASUVORK5CYII=', assetType);
        await refreshOverview();
    };
    const handleClear = async () => {
        await clearAsset(assetType);
        await refreshOverview();
    };
    return (window.SP_REACT.createElement("div", { className: DFL.joinClassNames('asset-wrap', `asset-wrap-${assetType}`) },
        window.SP_REACT.createElement("div", { className: "asset-label" }, trans_string('LABEL_ASSET_CURRENT', 'Current {assetType}').replace('{assetType}', SGDB_ASSET_TYPE_READABLE[assetType])),
        window.SP_REACT.createElement(DFL.Focusable, { onActivate: editable ? () => innerFocusRef.current?.focus() : undefined, onClick: (evt) => evt.preventDefault(), focusWithinClassName: "is-focused", focusClassName: "is-focused" },
            editable && (window.SP_REACT.createElement(DFL.Focusable, { "flow-children": "right", className: "action-overlay" },
                window.SP_REACT.createElement(DFL.Focusable, { ref: innerFocusRef, noFocusRing: true, className: "action-button", onActivate: handleClear, onOKActionDescription: trans_string('ACTION_ASSET_CUSTOM_CLEAR', 'Clear Custom Asset') },
                    window.SP_REACT.createElement(HiTrash, null)),
                window.SP_REACT.createElement(DFL.Focusable, { noFocusRing: true, className: "action-button", onActivate: handleBrowse, onOKActionDescription: trans_string('ACTION_ASSET_BROWSE_LOCAL', 'Browse for Local Files') },
                    window.SP_REACT.createElement(HiFolder, null)),
                assetType !== 'icon' && (window.SP_REACT.createElement(DFL.Focusable, { noFocusRing: true, className: "action-button", onActivate: handleBlank, onOKActionDescription: trans_string('ACTION_ASSET_APPLY_TRANSPARENT', 'Use Invisible Asset') },
                    window.SP_REACT.createElement(HiEyeSlash, null))))),
            overview ? (window.SP_REACT.createElement(LibraryImage, { app: overview, eAssetType: ASSET_TYPE[assetType], allowCustomization: false, className: "asset", imageClassName: "asset-img" })) : (window.SP_REACT.createElement("div", { className: "asset" })))));
};
const LocalTab = () => {
    const { appId, appOverview } = useSGDB();
    const [startPath, setStartPath] = SP_REACT.useState('/');
    const [overview, setOverview] = SP_REACT.useState();
    SP_REACT.useEffect(() => {
        if (!appId)
            return;
        (async () => {
            const appoverview = await getAppOverview(appId);
            if (!appoverview)
                return;
            // Today i choose violence
            if (appoverview.icon_hash) {
                const hash = appoverview.icon_hash;
                // fuck up the hash to force render the icon file from the cache
                appoverview.icon_hash = String(new Date().getTime());
                setOverview(appoverview);
                // vibe for a bit
                await new Promise((resolve) => setTimeout(resolve, 300));
                // now put that shit back
                appoverview.icon_hash = hash;
            }
            setOverview(appoverview);
            const path = await call('get_local_start');
            setStartPath(path);
        })();
    }, [appId, appOverview]);
    if (!overview || !appId)
        return null;
    return (window.SP_REACT.createElement(DFL.Focusable, { id: "local-images-container" },
        window.SP_REACT.createElement(DFL.Focusable, { "flow-children": "right", style: { display: 'flex', flexDirection: 'column', gap: '1em' } },
            window.SP_REACT.createElement(AssetBlock, { app: overview, assetType: "grid_p", browseStartPath: startPath }),
            window.SP_REACT.createElement(AssetBlock, { app: overview, assetType: "icon", browseStartPath: startPath, editable: !(overview.third_party_mod || (overview.BIsShortcut() && overview.selected_clientid != '0')) })),
        window.SP_REACT.createElement(DFL.Focusable, { "flow-children": "right", style: { display: 'flex', flexDirection: 'column', gap: '1em' } },
            window.SP_REACT.createElement(AssetBlock, { app: overview, assetType: "grid_l", browseStartPath: startPath }),
            window.SP_REACT.createElement(AssetBlock, { app: overview, assetType: "logo", browseStartPath: startPath })),
        window.SP_REACT.createElement("div", { style: { gridColumn: 'span 2' } },
            window.SP_REACT.createElement(AssetBlock, { app: overview, assetType: "hero", browseStartPath: startPath })),
        window.SP_REACT.createElement(DFL.Focusable, { "flow-children": "right", style: { gridColumn: 'span 2', display: 'flex', gap: '.5em' } },
            window.SP_REACT.createElement(DFL.DialogButton, { onClick: () => {
                    DFL.showModal(window.SP_REACT.createElement(LogoPositionerModal, { appId: appId }), window);
                } }, trans_string('CustomArt_EditLogoPosition', 'Adjust Logo Position', true)),
            window.SP_REACT.createElement(DFL.DialogButton, { onClick: async () => {
                    await window.appDetailsStore.ClearCustomLogoPosition(overview);
                } }, trans_string('CustomArt_ResetLogoPosition', 'Reset Logo Position', true)))));
};

var Spinner = 'http://127.0.0.1:1337/plugins/SteamGridDB/assets/spinner-667847d4.svg';

const Chips = ({ children }) => {
    const chipsRef = SP_REACT.useRef(null);
    const [leftAlign, setLeftAlign] = SP_REACT.useState(false);
    const isCutOff = SP_REACT.useCallback(() => {
        const el = chipsRef.current;
        if (!el)
            return false;
        const sizeEl = el.parentElement; // element we can check size aginst
        if (sizeEl) {
            return sizeEl.getBoundingClientRect().right + el.clientWidth + 10 > DFL.findSP().innerWidth;
        }
        return false;
    }, []);
    // Check if should switch to left aligned every time size is changed
    SP_REACT.useLayoutEffect(() => {
        const el = chipsRef.current;
        if (!el)
            return;
        const observer = new MutationObserver(debounce$1((mutations) => {
            if (mutations[0].attributeName === 'style') {
                if (el.parentElement) {
                    setLeftAlign(isCutOff());
                }
            }
        }, 500));
        const assetContainer = el.closest('#images-container');
        if (assetContainer) {
            observer.observe(assetContainer, { attributes: true });
        }
        // Inital
        setLeftAlign(isCutOff());
        return () => {
            observer.disconnect();
        };
    }, [isCutOff]);
    return window.SP_REACT.createElement("ul", { ref: chipsRef, className: DFL.joinClassNames('chips', leftAlign ? 'chips-left' : '') }, children);
};

const Chip = ({ color, colorText, children }) => (window.SP_REACT.createElement("li", { className: "chip", style: {
        ['--chip-color']: color,
        ['--chip-text-color']: colorText,
    } }, children));

// @todo: find a better way to get this
const ErrorIcon = Object.values(DFL.IconsModule).find((mod) => mod?.toString().includes('M27.7974 10L26.6274 2H33.3674L32.2374 10H27.7974Z'));
const LazyImage = ({ isVideo = false, unloadWhenOutside = false, marginOffset, scrollContainer, src, wrapperProps, blurBackground = false, ...props }) => {
    const [inViewport, setInViewport] = SP_REACT.useState(false);
    const [loading, setLoading] = SP_REACT.useState(true);
    const [error, setError] = SP_REACT.useState(false);
    const imgRef = SP_REACT.useRef(null);
    const intersectRef = SP_REACT.useRef(null);
    // reset some state when src changes
    SP_REACT.useEffect(() => {
        setInViewport(false);
        setError(false);
        setLoading(true);
    }, [src]);
    SP_REACT.useEffect(() => {
        if (!imgRef.current)
            return;
        const img = imgRef.current;
        const onLoad = () => {
            if (isVideo) {
                img.play();
            }
            setLoading(false);
        };
        const onError = () => setError(true);
        if (isVideo) {
            img.addEventListener('canplaythrough', onLoad);
        }
        else {
            img.addEventListener('load', onLoad);
        }
        img.addEventListener('error', onError);
        return () => {
            if (isVideo) {
                img.removeEventListener('canplaythrough', onLoad);
            }
            else {
                img.removeEventListener('load', onLoad);
            }
            img.removeEventListener('error', onError);
        };
    }, [src, isVideo, inViewport]);
    SP_REACT.useEffect(() => {
        if (!intersectRef.current)
            return;
        const observer = new IntersectionObserver((entries, observer) => {
            entries.forEach((entry) => {
                if (entry.isIntersecting && entry.intersectionRatio >= .5) {
                    setInViewport(true);
                    if (!unloadWhenOutside) {
                        observer.unobserve(entry.target);
                    }
                }
                else if (unloadWhenOutside && !loading && entry.intersectionRatio === 0) {
                    /* If completely out of view and already loaded, reset state.
                       images/videos should be cached by CEF so when back to view they will load instantly */
                    setInViewport(false);
                    setLoading(true);
                }
            });
        }, { threshold: [.5, 0], rootMargin: marginOffset, root: scrollContainer });
        observer.observe(intersectRef.current);
        return () => {
            observer.disconnect();
        };
    }, [loading, marginOffset, unloadWhenOutside, scrollContainer, src]);
    return (window.SP_REACT.createElement("div", { ref: intersectRef, style: {
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
        }, ...wrapperProps },
        error && window.SP_REACT.createElement(ErrorIcon, { style: { height: '2em' } }),
        (inViewport && !isVideo && error !== true) && (window.SP_REACT.createElement(window.SP_REACT.Fragment, null,
            blurBackground && (window.SP_REACT.createElement("img", { className: "blur-bg", "data-loaded": loading ? 'false' : 'true', src: src, ...props })),
            window.SP_REACT.createElement("img", { ref: imgRef, "data-loaded": loading ? 'false' : 'true', src: src, ...props }))),
        (inViewport && isVideo && error !== true) && (window.SP_REACT.createElement("video", { ref: imgRef, "data-loaded": loading ? 'false' : 'true', src: src, autoPlay: false, muted: true, loop: true, playsInline: true, ...props }))));
};

const Asset = ({ assetType, width, height, src, author, isAnimated, onActivate, isDownloading = false, scrollContainer, notes = null, nsfw, humor, epilepsy, onImgError, ...rest }) => (window.SP_REACT.createElement("div", { className: "asset-box-wrap" },
    window.SP_REACT.createElement(DFL.Focusable, { onActivate: onActivate, className: DFL.joinClassNames('image-wrap', `type-${assetType}`), style: { paddingBottom: `${(width === height) ? 100 : (height / width * 100)}%` }, ...rest },
        window.SP_REACT.createElement("div", { className: DFL.joinClassNames('dload-overlay', isDownloading ? 'downloading' : '') },
            window.SP_REACT.createElement("img", { src: Spinner })),
        window.SP_REACT.createElement(Chips, null,
            notes ? (window.SP_REACT.createElement(Chip, { color: "#8a8a8a" },
                window.SP_REACT.createElement(FooterGlyph, { button: 11, type: 0, size: 0, style: { width: '1em' } }),
                " ",
                trans_string('LABEL_NOTES', 'Notes'))) : null,
            isAnimated ? (window.SP_REACT.createElement(Chip, { color: "#e2a256" }, trans_string('LABEL_ANIMATED', 'Animated'))) : null,
            nsfw ? (window.SP_REACT.createElement(Chip, { color: "#e5344c" }, trans_string('LABEL_NSFW', 'Adult Content'))) : null,
            humor ? (window.SP_REACT.createElement(Chip, { color: "#eec314", colorText: "#434343" }, trans_string('LABEL_HUMOR', 'Humor'))) : null,
            epilepsy ? (window.SP_REACT.createElement(Chip, { color: "#735f9f" }, trans_string('LABEL_EPILEPSY', 'Epilepsy'))) : null),
        window.SP_REACT.createElement(LazyImage, { src: src, isVideo: isAnimated, scrollContainer: scrollContainer, wrapperProps: {
                className: 'thumb',
            }, marginOffset: "100px", unloadWhenOutside: true, blurBackground: true, onError: onImgError })),
    author && (window.SP_REACT.createElement("div", { className: "author" },
        window.SP_REACT.createElement(LazyImage, { src: author.avatar, alt: "" }),
        window.SP_REACT.createElement("span", null, author.name)))));

const sliderProps = {
    grid_p: {
        min: 100,
        max: 200,
        step: 5,
    },
    grid_l: {
        min: 160,
        max: 280,
        step: 5,
    },
    hero: {
        min: 2,
        max: 4,
        step: 1,
        notchCount: 3,
        notchTicksVisible: true,
    },
    logo: {
        min: 2,
        max: 6,
        step: 1,
        notchCount: 5,
        notchTicksVisible: true,
    },
    icon: {
        min: 100,
        max: 200,
        step: 5,
    },
};
const defaultSliderSizes = {
    grid_p: 150,
    grid_l: 200,
    hero: 3,
    logo: 4,
    icon: 120,
};
// map SGDBAssetType to steam response
const defaultAssetMap = {
    grid_p: 'library_capsule',
    grid_l: 'header_image',
    hero: 'library_hero',
    logo: 'library_logo',
    icon: 'clienticon',
};
const Toolbar = SP_REACT.forwardRef(({ assetType, onSizeChange, onFilterClick, onOfficialAssetsClick, onLogoPosClick, disabled = false, noFocusRing, }, ref) => {
    const { externalSgdbData } = useAssetSearch();
    const { set, get } = useSettings();
    const [sliderValue, setSliderValue] = SP_REACT.useState(120);
    const toolbarFocusRef = SP_REACT.useRef(null);
    const handleSliderChange = (size) => {
        setSliderValue(size);
        set(`zoomlevel_${assetType}`, size);
    };
    const assetSizeStyleAttr = SP_REACT.useMemo(() => {
        if (['hero', 'logo'].includes(assetType)) {
            const percent = 100 / (sliderProps[assetType].max - sliderValue + sliderProps[assetType].min);
            return {
                gridTemplateColumns: `repeat(auto-fill, minmax(calc(${percent}% - .65em), 1fr))`,
            };
        }
        return {
            ['--asset-size']: `${sliderValue}px`,
        };
    }, [assetType, sliderValue]);
    SP_REACT.useImperativeHandle(ref, () => ({
        focus: () => {
            toolbarFocusRef.current?.focus();
        },
        assetSizeStyleAttr,
    }), [assetSizeStyleAttr]);
    SP_REACT.useEffect(() => {
        onSizeChange?.(assetSizeStyleAttr);
    }, [assetSizeStyleAttr, onSizeChange]);
    // Set initial slider value from config or default
    SP_REACT.useEffect(() => {
        (async () => {
            const defSize = await get(`zoomlevel_${assetType}`, defaultSliderSizes[assetType]);
            setSliderValue(defSize);
        })();
    }, [assetType, get]);
    if (disabled)
        return null;
    return (window.SP_REACT.createElement(DFL.Focusable, { className: "sgdb-asset-toolbar", noFocusRing: noFocusRing, "flow-children": "row" },
        window.SP_REACT.createElement(DFL.Focusable, { className: "filter-buttons" },
            window.SP_REACT.createElement(DFL.DialogButton, { ref: toolbarFocusRef, style: { flex: 0 }, noFocusRing: true, onOKActionDescription: trans_string('ACTION_OPEN_FILTER', 'Filter'), onClick: onFilterClick }, trans_string('ACTION_OPEN_FILTER', 'Filter')),
            (externalSgdbData &&
                Object.keys(externalSgdbData).length !== 0 &&
                externalSgdbData?.steam[0]?.metadata[defaultAssetMap[assetType]]) && (window.SP_REACT.createElement(DFL.DialogButton, { noFocusRing: true, onOKActionDescription: trans_string('ACTION_OPEN_OFFICIAL_ASSETS', 'Official {assetType}').replace('{assetType}', SGDB_ASSET_TYPE_READABLE[assetType]), onClick: onOfficialAssetsClick }, trans_string('ACTION_OPEN_OFFICIAL_ASSETS', 'Official {assetType}').replace('{assetType}', SGDB_ASSET_TYPE_READABLE[assetType]))),
            ['logo', 'hero'].includes(assetType) && (window.SP_REACT.createElement(DFL.DialogButton, { noFocusRing: true, onOKActionDescription: trans_string('CustomArt_EditLogoPosition', 'Adjust Logo Position', true), onClick: onLogoPosClick }, trans_string('CustomArt_EditLogoPosition', 'Adjust Logo Position', true)))),
        window.SP_REACT.createElement(DFL.SliderField, { className: "size-slider", onChange: handleSliderChange, value: sliderValue, layout: "below", bottomSeparator: "none", ...sliderProps[assetType] })));
});
Toolbar.displayName = 'Toolbar';

const protocols = ['http', 'https', 'mailto', 'tel'];

/**
 * @param {string} uri
 * @returns {string}
 */
function uriTransformer(uri) {
  const url = (uri || '').trim();
  const first = url.charAt(0);

  if (first === '#' || first === '/') {
    return url
  }

  const colon = url.indexOf(':');
  if (colon === -1) {
    return url
  }

  let index = -1;

  while (++index < protocols.length) {
    const protocol = protocols[index];

    if (
      colon === protocol.length &&
      url.slice(0, protocol.length).toLowerCase() === protocol
    ) {
      return url
    }
  }

  index = url.indexOf('?');
  if (index !== -1 && colon > index) {
    return url
  }

  index = url.indexOf('#');
  if (index !== -1 && colon > index) {
    return url
  }

  // eslint-disable-next-line no-script-url
  return 'javascript:void(0)'
}

/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */

var isBuffer = function isBuffer (obj) {
  return obj != null && obj.constructor != null &&
    typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
};

var isBuffer$1 = /*@__PURE__*/getDefaultExportFromCjs(isBuffer);

/**
 * @typedef {import('unist').Node} Node
 * @typedef {import('unist').Point} Point
 * @typedef {import('unist').Position} Position
 */

/**
 * @typedef NodeLike
 * @property {string} type
 * @property {PositionLike | null | undefined} [position]
 *
 * @typedef PositionLike
 * @property {PointLike | null | undefined} [start]
 * @property {PointLike | null | undefined} [end]
 *
 * @typedef PointLike
 * @property {number | null | undefined} [line]
 * @property {number | null | undefined} [column]
 * @property {number | null | undefined} [offset]
 */

/**
 * Serialize the positional info of a point, position (start and end points),
 * or node.
 *
 * @param {Node | NodeLike | Position | PositionLike | Point | PointLike | null | undefined} [value]
 *   Node, position, or point.
 * @returns {string}
 *   Pretty printed positional info of a node (`string`).
 *
 *   In the format of a range `ls:cs-le:ce` (when given `node` or `position`)
 *   or a point `l:c` (when given `point`), where `l` stands for line, `c` for
 *   column, `s` for `start`, and `e` for end.
 *   An empty string (`''`) is returned if the given value is neither `node`,
 *   `position`, nor `point`.
 */
function stringifyPosition(value) {
  // Nothing.
  if (!value || typeof value !== 'object') {
    return ''
  }

  // Node.
  if ('position' in value || 'type' in value) {
    return position$1(value.position)
  }

  // Position.
  if ('start' in value || 'end' in value) {
    return position$1(value)
  }

  // Point.
  if ('line' in value || 'column' in value) {
    return point$2(value)
  }

  // ?
  return ''
}

/**
 * @param {Point | PointLike | null | undefined} point
 * @returns {string}
 */
function point$2(point) {
  return index$1(point && point.line) + ':' + index$1(point && point.column)
}

/**
 * @param {Position | PositionLike | null | undefined} pos
 * @returns {string}
 */
function position$1(pos) {
  return point$2(pos && pos.start) + '-' + point$2(pos && pos.end)
}

/**
 * @param {number | null | undefined} value
 * @returns {number}
 */
function index$1(value) {
  return value && typeof value === 'number' ? value : 1
}

/**
 * @typedef {import('unist').Node} Node
 * @typedef {import('unist').Position} Position
 * @typedef {import('unist').Point} Point
 * @typedef {object & {type: string, position?: Position | undefined}} NodeLike
 */


/**
 * Message.
 */
class VFileMessage extends Error {
  /**
   * Create a message for `reason` at `place` from `origin`.
   *
   * When an error is passed in as `reason`, the `stack` is copied.
   *
   * @param {string | Error | VFileMessage} reason
   *   Reason for message, uses the stack and message of the error if given.
   *
   *   > 👉 **Note**: you should use markdown.
   * @param {Node | NodeLike | Position | Point | null | undefined} [place]
   *   Place in file where the message occurred.
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns
   *   Instance of `VFileMessage`.
   */
  // To do: next major: expose `undefined` everywhere instead of `null`.
  constructor(reason, place, origin) {
    /** @type {[string | null, string | null]} */
    const parts = [null, null];
    /** @type {Position} */
    let position = {
      // @ts-expect-error: we always follows the structure of `position`.
      start: {line: null, column: null},
      // @ts-expect-error: "
      end: {line: null, column: null}
    };

    super();

    if (typeof place === 'string') {
      origin = place;
      place = undefined;
    }

    if (typeof origin === 'string') {
      const index = origin.indexOf(':');

      if (index === -1) {
        parts[1] = origin;
      } else {
        parts[0] = origin.slice(0, index);
        parts[1] = origin.slice(index + 1);
      }
    }

    if (place) {
      // Node.
      if ('type' in place || 'position' in place) {
        if (place.position) {
          // To do: next major: deep clone.
          // @ts-expect-error: looks like a position.
          position = place.position;
        }
      }
      // Position.
      else if ('start' in place || 'end' in place) {
        // @ts-expect-error: looks like a position.
        // To do: next major: deep clone.
        position = place;
      }
      // Point.
      else if ('line' in place || 'column' in place) {
        // To do: next major: deep clone.
        position.start = place;
      }
    }

    // Fields from `Error`.
    /**
     * Serialized positional info of error.
     *
     * On normal errors, this would be something like `ParseError`, buit in
     * `VFile` messages we use this space to show where an error happened.
     */
    this.name = stringifyPosition(place) || '1:1';

    /**
     * Reason for message.
     *
     * @type {string}
     */
    this.message = typeof reason === 'object' ? reason.message : reason;

    /**
     * Stack of message.
     *
     * This is used by normal errors to show where something happened in
     * programming code, irrelevant for `VFile` messages,
     *
     * @type {string}
     */
    this.stack = '';

    if (typeof reason === 'object' && reason.stack) {
      this.stack = reason.stack;
    }

    /**
     * Reason for message.
     *
     * > 👉 **Note**: you should use markdown.
     *
     * @type {string}
     */
    this.reason = this.message;

    /**
     * Starting line of error.
     *
     * @type {number | null}
     */
    this.line = position.start.line;

    /**
     * Starting column of error.
     *
     * @type {number | null}
     */
    this.column = position.start.column;

    /**
     * Full unist position.
     *
     * @type {Position | null}
     */
    this.position = position;

    /**
     * Namespace of message (example: `'my-package'`).
     *
     * @type {string | null}
     */
    this.source = parts[0];

    /**
     * Category of message (example: `'my-rule'`).
     *
     * @type {string | null}
     */
    this.ruleId = parts[1];
    /* eslint-enable no-unused-expressions */
  }
}

VFileMessage.prototype.file = '';
VFileMessage.prototype.name = '';
VFileMessage.prototype.reason = '';
VFileMessage.prototype.message = '';
VFileMessage.prototype.stack = '';
VFileMessage.prototype.fatal = null;
VFileMessage.prototype.column = null;
VFileMessage.prototype.line = null;
VFileMessage.prototype.source = null;
VFileMessage.prototype.ruleId = null;
VFileMessage.prototype.position = null;

// A derivative work based on:
// <https://github.com/browserify/path-browserify>.
// Which is licensed:
//
// MIT License
//
// Copyright (c) 2013 James Halliday
//
// Permission is hereby granted, free of charge, to any person obtaining a copy of
// this software and associated documentation files (the "Software"), to deal in
// the Software without restriction, including without limitation the rights to
// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
// the Software, and to permit persons to whom the Software is furnished to do so,
// subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
// FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
// IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
// CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
// A derivative work based on:
//
// Parts of that are extracted from Node’s internal `path` module:
// <https://github.com/nodejs/node/blob/master/lib/path.js>.
// Which is licensed:
//
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

const path$1 = {basename, dirname, extname, join, sep: '/'};

/* eslint-disable max-depth, complexity */

/**
 * Get the basename from a path.
 *
 * @param {string} path
 *   File path.
 * @param {string | undefined} [ext]
 *   Extension to strip.
 * @returns {string}
 *   Stem or basename.
 */
function basename(path, ext) {
  if (ext !== undefined && typeof ext !== 'string') {
    throw new TypeError('"ext" argument must be a string')
  }

  assertPath$1(path);
  let start = 0;
  let end = -1;
  let index = path.length;
  /** @type {boolean | undefined} */
  let seenNonSlash;

  if (ext === undefined || ext.length === 0 || ext.length > path.length) {
    while (index--) {
      if (path.charCodeAt(index) === 47 /* `/` */) {
        // If we reached a path separator that was not part of a set of path
        // separators at the end of the string, stop now.
        if (seenNonSlash) {
          start = index + 1;
          break
        }
      } else if (end < 0) {
        // We saw the first non-path separator, mark this as the end of our
        // path component.
        seenNonSlash = true;
        end = index + 1;
      }
    }

    return end < 0 ? '' : path.slice(start, end)
  }

  if (ext === path) {
    return ''
  }

  let firstNonSlashEnd = -1;
  let extIndex = ext.length - 1;

  while (index--) {
    if (path.charCodeAt(index) === 47 /* `/` */) {
      // If we reached a path separator that was not part of a set of path
      // separators at the end of the string, stop now.
      if (seenNonSlash) {
        start = index + 1;
        break
      }
    } else {
      if (firstNonSlashEnd < 0) {
        // We saw the first non-path separator, remember this index in case
        // we need it if the extension ends up not matching.
        seenNonSlash = true;
        firstNonSlashEnd = index + 1;
      }

      if (extIndex > -1) {
        // Try to match the explicit extension.
        if (path.charCodeAt(index) === ext.charCodeAt(extIndex--)) {
          if (extIndex < 0) {
            // We matched the extension, so mark this as the end of our path
            // component
            end = index;
          }
        } else {
          // Extension does not match, so our result is the entire path
          // component
          extIndex = -1;
          end = firstNonSlashEnd;
        }
      }
    }
  }

  if (start === end) {
    end = firstNonSlashEnd;
  } else if (end < 0) {
    end = path.length;
  }

  return path.slice(start, end)
}

/**
 * Get the dirname from a path.
 *
 * @param {string} path
 *   File path.
 * @returns {string}
 *   File path.
 */
function dirname(path) {
  assertPath$1(path);

  if (path.length === 0) {
    return '.'
  }

  let end = -1;
  let index = path.length;
  /** @type {boolean | undefined} */
  let unmatchedSlash;

  // Prefix `--` is important to not run on `0`.
  while (--index) {
    if (path.charCodeAt(index) === 47 /* `/` */) {
      if (unmatchedSlash) {
        end = index;
        break
      }
    } else if (!unmatchedSlash) {
      // We saw the first non-path separator
      unmatchedSlash = true;
    }
  }

  return end < 0
    ? path.charCodeAt(0) === 47 /* `/` */
      ? '/'
      : '.'
    : end === 1 && path.charCodeAt(0) === 47 /* `/` */
    ? '//'
    : path.slice(0, end)
}

/**
 * Get an extname from a path.
 *
 * @param {string} path
 *   File path.
 * @returns {string}
 *   Extname.
 */
function extname(path) {
  assertPath$1(path);

  let index = path.length;

  let end = -1;
  let startPart = 0;
  let startDot = -1;
  // Track the state of characters (if any) we see before our first dot and
  // after any path separator we find.
  let preDotState = 0;
  /** @type {boolean | undefined} */
  let unmatchedSlash;

  while (index--) {
    const code = path.charCodeAt(index);

    if (code === 47 /* `/` */) {
      // If we reached a path separator that was not part of a set of path
      // separators at the end of the string, stop now.
      if (unmatchedSlash) {
        startPart = index + 1;
        break
      }

      continue
    }

    if (end < 0) {
      // We saw the first non-path separator, mark this as the end of our
      // extension.
      unmatchedSlash = true;
      end = index + 1;
    }

    if (code === 46 /* `.` */) {
      // If this is our first dot, mark it as the start of our extension.
      if (startDot < 0) {
        startDot = index;
      } else if (preDotState !== 1) {
        preDotState = 1;
      }
    } else if (startDot > -1) {
      // We saw a non-dot and non-path separator before our dot, so we should
      // have a good chance at having a non-empty extension.
      preDotState = -1;
    }
  }

  if (
    startDot < 0 ||
    end < 0 ||
    // We saw a non-dot character immediately before the dot.
    preDotState === 0 ||
    // The (right-most) trimmed path component is exactly `..`.
    (preDotState === 1 && startDot === end - 1 && startDot === startPart + 1)
  ) {
    return ''
  }

  return path.slice(startDot, end)
}

/**
 * Join segments from a path.
 *
 * @param {Array<string>} segments
 *   Path segments.
 * @returns {string}
 *   File path.
 */
function join(...segments) {
  let index = -1;
  /** @type {string | undefined} */
  let joined;

  while (++index < segments.length) {
    assertPath$1(segments[index]);

    if (segments[index]) {
      joined =
        joined === undefined ? segments[index] : joined + '/' + segments[index];
    }
  }

  return joined === undefined ? '.' : normalize$1(joined)
}

/**
 * Normalize a basic file path.
 *
 * @param {string} path
 *   File path.
 * @returns {string}
 *   File path.
 */
// Note: `normalize` is not exposed as `path.normalize`, so some code is
// manually removed from it.
function normalize$1(path) {
  assertPath$1(path);

  const absolute = path.charCodeAt(0) === 47; /* `/` */

  // Normalize the path according to POSIX rules.
  let value = normalizeString(path, !absolute);

  if (value.length === 0 && !absolute) {
    value = '.';
  }

  if (value.length > 0 && path.charCodeAt(path.length - 1) === 47 /* / */) {
    value += '/';
  }

  return absolute ? '/' + value : value
}

/**
 * Resolve `.` and `..` elements in a path with directory names.
 *
 * @param {string} path
 *   File path.
 * @param {boolean} allowAboveRoot
 *   Whether `..` can move above root.
 * @returns {string}
 *   File path.
 */
function normalizeString(path, allowAboveRoot) {
  let result = '';
  let lastSegmentLength = 0;
  let lastSlash = -1;
  let dots = 0;
  let index = -1;
  /** @type {number | undefined} */
  let code;
  /** @type {number} */
  let lastSlashIndex;

  while (++index <= path.length) {
    if (index < path.length) {
      code = path.charCodeAt(index);
    } else if (code === 47 /* `/` */) {
      break
    } else {
      code = 47; /* `/` */
    }

    if (code === 47 /* `/` */) {
      if (lastSlash === index - 1 || dots === 1) ; else if (lastSlash !== index - 1 && dots === 2) {
        if (
          result.length < 2 ||
          lastSegmentLength !== 2 ||
          result.charCodeAt(result.length - 1) !== 46 /* `.` */ ||
          result.charCodeAt(result.length - 2) !== 46 /* `.` */
        ) {
          if (result.length > 2) {
            lastSlashIndex = result.lastIndexOf('/');

            if (lastSlashIndex !== result.length - 1) {
              if (lastSlashIndex < 0) {
                result = '';
                lastSegmentLength = 0;
              } else {
                result = result.slice(0, lastSlashIndex);
                lastSegmentLength = result.length - 1 - result.lastIndexOf('/');
              }

              lastSlash = index;
              dots = 0;
              continue
            }
          } else if (result.length > 0) {
            result = '';
            lastSegmentLength = 0;
            lastSlash = index;
            dots = 0;
            continue
          }
        }

        if (allowAboveRoot) {
          result = result.length > 0 ? result + '/..' : '..';
          lastSegmentLength = 2;
        }
      } else {
        if (result.length > 0) {
          result += '/' + path.slice(lastSlash + 1, index);
        } else {
          result = path.slice(lastSlash + 1, index);
        }

        lastSegmentLength = index - lastSlash - 1;
      }

      lastSlash = index;
      dots = 0;
    } else if (code === 46 /* `.` */ && dots > -1) {
      dots++;
    } else {
      dots = -1;
    }
  }

  return result
}

/**
 * Make sure `path` is a string.
 *
 * @param {string} path
 *   File path.
 * @returns {asserts path is string}
 *   Nothing.
 */
function assertPath$1(path) {
  if (typeof path !== 'string') {
    throw new TypeError(
      'Path must be a string. Received ' + JSON.stringify(path)
    )
  }
}

/* eslint-enable max-depth, complexity */

// Somewhat based on:
// <https://github.com/defunctzombie/node-process/blob/master/browser.js>.
// But I don’t think one tiny line of code can be copyrighted. 😅
const proc = {cwd};

function cwd() {
  return '/'
}

/**
 * @typedef URL
 * @property {string} hash
 * @property {string} host
 * @property {string} hostname
 * @property {string} href
 * @property {string} origin
 * @property {string} password
 * @property {string} pathname
 * @property {string} port
 * @property {string} protocol
 * @property {string} search
 * @property {any} searchParams
 * @property {string} username
 * @property {() => string} toString
 * @property {() => string} toJSON
 */

/**
 * Check if `fileUrlOrPath` looks like a URL.
 *
 * @param {unknown} fileUrlOrPath
 *   File path or URL.
 * @returns {fileUrlOrPath is URL}
 *   Whether it’s a URL.
 */
// From: <https://github.com/nodejs/node/blob/fcf8ba4/lib/internal/url.js#L1501>
function isUrl(fileUrlOrPath) {
  return (
    fileUrlOrPath !== null &&
    typeof fileUrlOrPath === 'object' &&
    // @ts-expect-error: indexable.
    fileUrlOrPath.href &&
    // @ts-expect-error: indexable.
    fileUrlOrPath.origin
  )
}

/// <reference lib="dom" />


// See: <https://github.com/nodejs/node/blob/fcf8ba4/lib/internal/url.js>

/**
 * @param {string | URL} path
 *   File URL.
 * @returns {string}
 *   File URL.
 */
function urlToPath(path) {
  if (typeof path === 'string') {
    path = new URL(path);
  } else if (!isUrl(path)) {
    /** @type {NodeJS.ErrnoException} */
    const error = new TypeError(
      'The "path" argument must be of type string or an instance of URL. Received `' +
        path +
        '`'
    );
    error.code = 'ERR_INVALID_ARG_TYPE';
    throw error
  }

  if (path.protocol !== 'file:') {
    /** @type {NodeJS.ErrnoException} */
    const error = new TypeError('The URL must be of scheme file');
    error.code = 'ERR_INVALID_URL_SCHEME';
    throw error
  }

  return getPathFromURLPosix(path)
}

/**
 * Get a path from a POSIX URL.
 *
 * @param {URL} url
 *   URL.
 * @returns {string}
 *   File path.
 */
function getPathFromURLPosix(url) {
  if (url.hostname !== '') {
    /** @type {NodeJS.ErrnoException} */
    const error = new TypeError(
      'File URL host must be "localhost" or empty on darwin'
    );
    error.code = 'ERR_INVALID_FILE_URL_HOST';
    throw error
  }

  const pathname = url.pathname;
  let index = -1;

  while (++index < pathname.length) {
    if (
      pathname.charCodeAt(index) === 37 /* `%` */ &&
      pathname.charCodeAt(index + 1) === 50 /* `2` */
    ) {
      const third = pathname.charCodeAt(index + 2);
      if (third === 70 /* `F` */ || third === 102 /* `f` */) {
        /** @type {NodeJS.ErrnoException} */
        const error = new TypeError(
          'File URL path must not include encoded / characters'
        );
        error.code = 'ERR_INVALID_FILE_URL_PATH';
        throw error
      }
    }
  }

  return decodeURIComponent(pathname)
}

/**
 * @typedef {import('unist').Node} Node
 * @typedef {import('unist').Position} Position
 * @typedef {import('unist').Point} Point
 * @typedef {import('./minurl.shared.js').URL} URL
 * @typedef {import('../index.js').Data} Data
 * @typedef {import('../index.js').Value} Value
 */


/**
 * Order of setting (least specific to most), we need this because otherwise
 * `{stem: 'a', path: '~/b.js'}` would throw, as a path is needed before a
 * stem can be set.
 *
 * @type {Array<'basename' | 'dirname' | 'extname' | 'history' | 'path' | 'stem'>}
 */
const order = ['history', 'path', 'basename', 'stem', 'extname', 'dirname'];

class VFile {
  /**
   * Create a new virtual file.
   *
   * `options` is treated as:
   *
   * *   `string` or `Buffer` — `{value: options}`
   * *   `URL` — `{path: options}`
   * *   `VFile` — shallow copies its data over to the new file
   * *   `object` — all fields are shallow copied over to the new file
   *
   * Path related fields are set in the following order (least specific to
   * most specific): `history`, `path`, `basename`, `stem`, `extname`,
   * `dirname`.
   *
   * You cannot set `dirname` or `extname` without setting either `history`,
   * `path`, `basename`, or `stem` too.
   *
   * @param {Compatible | null | undefined} [value]
   *   File value.
   * @returns
   *   New instance.
   */
  constructor(value) {
    /** @type {Options | VFile} */
    let options;

    if (!value) {
      options = {};
    } else if (typeof value === 'string' || buffer(value)) {
      options = {value};
    } else if (isUrl(value)) {
      options = {path: value};
    } else {
      options = value;
    }

    /**
     * Place to store custom information (default: `{}`).
     *
     * It’s OK to store custom data directly on the file but moving it to
     * `data` is recommended.
     *
     * @type {Data}
     */
    this.data = {};

    /**
     * List of messages associated with the file.
     *
     * @type {Array<VFileMessage>}
     */
    this.messages = [];

    /**
     * List of filepaths the file moved between.
     *
     * The first is the original path and the last is the current path.
     *
     * @type {Array<string>}
     */
    this.history = [];

    /**
     * Base of `path` (default: `process.cwd()` or `'/'` in browsers).
     *
     * @type {string}
     */
    this.cwd = proc.cwd();
    /* eslint-enable no-unused-expressions */

    // Set path related properties in the correct order.
    let index = -1;

    while (++index < order.length) {
      const prop = order[index];

      // Note: we specifically use `in` instead of `hasOwnProperty` to accept
      // `vfile`s too.
      if (
        prop in options &&
        options[prop] !== undefined &&
        options[prop] !== null
      ) {
        // @ts-expect-error: TS doesn’t understand basic reality.
        this[prop] = prop === 'history' ? [...options[prop]] : options[prop];
      }
    }

    /** @type {string} */
    let prop;

    // Set non-path related properties.
    for (prop in options) {
      // @ts-expect-error: fine to set other things.
      if (!order.includes(prop)) {
        // @ts-expect-error: fine to set other things.
        this[prop] = options[prop];
      }
    }
  }

  /**
   * Get the full path (example: `'~/index.min.js'`).
   *
   * @returns {string}
   */
  get path() {
    return this.history[this.history.length - 1]
  }

  /**
   * Set the full path (example: `'~/index.min.js'`).
   *
   * Cannot be nullified.
   * You can set a file URL (a `URL` object with a `file:` protocol) which will
   * be turned into a path with `url.fileURLToPath`.
   *
   * @param {string | URL} path
   */
  set path(path) {
    if (isUrl(path)) {
      path = urlToPath(path);
    }

    assertNonEmpty(path, 'path');

    if (this.path !== path) {
      this.history.push(path);
    }
  }

  /**
   * Get the parent path (example: `'~'`).
   */
  get dirname() {
    return typeof this.path === 'string' ? path$1.dirname(this.path) : undefined
  }

  /**
   * Set the parent path (example: `'~'`).
   *
   * Cannot be set if there’s no `path` yet.
   */
  set dirname(dirname) {
    assertPath(this.basename, 'dirname');
    this.path = path$1.join(dirname || '', this.basename);
  }

  /**
   * Get the basename (including extname) (example: `'index.min.js'`).
   */
  get basename() {
    return typeof this.path === 'string' ? path$1.basename(this.path) : undefined
  }

  /**
   * Set basename (including extname) (`'index.min.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   */
  set basename(basename) {
    assertNonEmpty(basename, 'basename');
    assertPart(basename, 'basename');
    this.path = path$1.join(this.dirname || '', basename);
  }

  /**
   * Get the extname (including dot) (example: `'.js'`).
   */
  get extname() {
    return typeof this.path === 'string' ? path$1.extname(this.path) : undefined
  }

  /**
   * Set the extname (including dot) (example: `'.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be set if there’s no `path` yet.
   */
  set extname(extname) {
    assertPart(extname, 'extname');
    assertPath(this.dirname, 'extname');

    if (extname) {
      if (extname.charCodeAt(0) !== 46 /* `.` */) {
        throw new Error('`extname` must start with `.`')
      }

      if (extname.includes('.', 1)) {
        throw new Error('`extname` cannot contain multiple dots')
      }
    }

    this.path = path$1.join(this.dirname, this.stem + (extname || ''));
  }

  /**
   * Get the stem (basename w/o extname) (example: `'index.min'`).
   */
  get stem() {
    return typeof this.path === 'string'
      ? path$1.basename(this.path, this.extname)
      : undefined
  }

  /**
   * Set the stem (basename w/o extname) (example: `'index.min'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   */
  set stem(stem) {
    assertNonEmpty(stem, 'stem');
    assertPart(stem, 'stem');
    this.path = path$1.join(this.dirname || '', stem + (this.extname || ''));
  }

  /**
   * Serialize the file.
   *
   * @param {BufferEncoding | null | undefined} [encoding='utf8']
   *   Character encoding to understand `value` as when it’s a `Buffer`
   *   (default: `'utf8'`).
   * @returns {string}
   *   Serialized file.
   */
  toString(encoding) {
    return (this.value || '').toString(encoding || undefined)
  }

  /**
   * Create a warning message associated with the file.
   *
   * Its `fatal` is set to `false` and `file` is set to the current file path.
   * Its added to `file.messages`.
   *
   * @param {string | Error | VFileMessage} reason
   *   Reason for message, uses the stack and message of the error if given.
   * @param {Node | NodeLike | Position | Point | null | undefined} [place]
   *   Place in file where the message occurred.
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  message(reason, place, origin) {
    const message = new VFileMessage(reason, place, origin);

    if (this.path) {
      message.name = this.path + ':' + message.name;
      message.file = this.path;
    }

    message.fatal = false;

    this.messages.push(message);

    return message
  }

  /**
   * Create an info message associated with the file.
   *
   * Its `fatal` is set to `null` and `file` is set to the current file path.
   * Its added to `file.messages`.
   *
   * @param {string | Error | VFileMessage} reason
   *   Reason for message, uses the stack and message of the error if given.
   * @param {Node | NodeLike | Position | Point | null | undefined} [place]
   *   Place in file where the message occurred.
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  info(reason, place, origin) {
    const message = this.message(reason, place, origin);

    message.fatal = null;

    return message
  }

  /**
   * Create a fatal error associated with the file.
   *
   * Its `fatal` is set to `true` and `file` is set to the current file path.
   * Its added to `file.messages`.
   *
   * > 👉 **Note**: a fatal error means that a file is no longer processable.
   *
   * @param {string | Error | VFileMessage} reason
   *   Reason for message, uses the stack and message of the error if given.
   * @param {Node | NodeLike | Position | Point | null | undefined} [place]
   *   Place in file where the message occurred.
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {never}
   *   Message.
   * @throws {VFileMessage}
   *   Message.
   */
  fail(reason, place, origin) {
    const message = this.message(reason, place, origin);

    message.fatal = true;

    throw message
  }
}

/**
 * Assert that `part` is not a path (as in, does not contain `path.sep`).
 *
 * @param {string | null | undefined} part
 *   File path part.
 * @param {string} name
 *   Part name.
 * @returns {void}
 *   Nothing.
 */
function assertPart(part, name) {
  if (part && part.includes(path$1.sep)) {
    throw new Error(
      '`' + name + '` cannot be a path: did not expect `' + path$1.sep + '`'
    )
  }
}

/**
 * Assert that `part` is not empty.
 *
 * @param {string | undefined} part
 *   Thing.
 * @param {string} name
 *   Part name.
 * @returns {asserts part is string}
 *   Nothing.
 */
function assertNonEmpty(part, name) {
  if (!part) {
    throw new Error('`' + name + '` cannot be empty')
  }
}

/**
 * Assert `path` exists.
 *
 * @param {string | undefined} path
 *   Path.
 * @param {string} name
 *   Dependency name.
 * @returns {asserts path is string}
 *   Nothing.
 */
function assertPath(path, name) {
  if (!path) {
    throw new Error('Setting `' + name + '` requires `path` to be set too')
  }
}

/**
 * Assert `value` is a buffer.
 *
 * @param {unknown} value
 *   thing.
 * @returns {value is Buffer}
 *   Whether `value` is a Node.js buffer.
 */
function buffer(value) {
  return isBuffer$1(value)
}

/**
 * Throw a given error.
 *
 * @param {Error|null|undefined} [error]
 *   Maybe error.
 * @returns {asserts error is null|undefined}
 */
function bail(error) {
  if (error) {
    throw error
  }
}

var hasOwn = Object.prototype.hasOwnProperty;
var toStr = Object.prototype.toString;
var defineProperty = Object.defineProperty;
var gOPD = Object.getOwnPropertyDescriptor;

var isArray = function isArray(arr) {
	if (typeof Array.isArray === 'function') {
		return Array.isArray(arr);
	}

	return toStr.call(arr) === '[object Array]';
};

var isPlainObject$1 = function isPlainObject(obj) {
	if (!obj || toStr.call(obj) !== '[object Object]') {
		return false;
	}

	var hasOwnConstructor = hasOwn.call(obj, 'constructor');
	var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, 'isPrototypeOf');
	// Not own constructor property must be Object
	if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
		return false;
	}

	// Own properties are enumerated firstly, so to speed up,
	// if last one is own, then all properties are own.
	var key;
	for (key in obj) { /**/ }

	return typeof key === 'undefined' || hasOwn.call(obj, key);
};

// If name is '__proto__', and Object.defineProperty is available, define __proto__ as an own property on target
var setProperty = function setProperty(target, options) {
	if (defineProperty && options.name === '__proto__') {
		defineProperty(target, options.name, {
			enumerable: true,
			configurable: true,
			value: options.newValue,
			writable: true
		});
	} else {
		target[options.name] = options.newValue;
	}
};

// Return undefined instead of __proto__ if '__proto__' is not an own property
var getProperty = function getProperty(obj, name) {
	if (name === '__proto__') {
		if (!hasOwn.call(obj, name)) {
			return void 0;
		} else if (gOPD) {
			// In early versions of node, obj['__proto__'] is buggy when obj has
			// __proto__ as an own property. Object.getOwnPropertyDescriptor() works.
			return gOPD(obj, name).value;
		}
	}

	return obj[name];
};

var extend = function extend() {
	var options, name, src, copy, copyIsArray, clone;
	var target = arguments[0];
	var i = 1;
	var length = arguments.length;
	var deep = false;

	// Handle a deep copy situation
	if (typeof target === 'boolean') {
		deep = target;
		target = arguments[1] || {};
		// skip the boolean and the target
		i = 2;
	}
	if (target == null || (typeof target !== 'object' && typeof target !== 'function')) {
		target = {};
	}

	for (; i < length; ++i) {
		options = arguments[i];
		// Only deal with non-null/undefined values
		if (options != null) {
			// Extend the base object
			for (name in options) {
				src = getProperty(target, name);
				copy = getProperty(options, name);

				// Prevent never-ending loop
				if (target !== copy) {
					// Recurse if we're merging plain objects or arrays
					if (deep && copy && (isPlainObject$1(copy) || (copyIsArray = isArray(copy)))) {
						if (copyIsArray) {
							copyIsArray = false;
							clone = src && isArray(src) ? src : [];
						} else {
							clone = src && isPlainObject$1(src) ? src : {};
						}

						// Never move original objects, clone them
						setProperty(target, { name: name, newValue: extend(deep, clone, copy) });

					// Don't bring in undefined values
					} else if (typeof copy !== 'undefined') {
						setProperty(target, { name: name, newValue: copy });
					}
				}
			}
		}
	}

	// Return the modified object
	return target;
};

var extend$1 = /*@__PURE__*/getDefaultExportFromCjs(extend);

function isPlainObject(value) {
	if (typeof value !== 'object' || value === null) {
		return false;
	}

	const prototype = Object.getPrototypeOf(value);
	return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);
}

// To do: remove `void`s
// To do: remove `null` from output of our APIs, allow it as user APIs.

/**
 * @typedef {(error?: Error | null | undefined, ...output: Array<any>) => void} Callback
 *   Callback.
 *
 * @typedef {(...input: Array<any>) => any} Middleware
 *   Ware.
 *
 * @typedef Pipeline
 *   Pipeline.
 * @property {Run} run
 *   Run the pipeline.
 * @property {Use} use
 *   Add middleware.
 *
 * @typedef {(...input: Array<any>) => void} Run
 *   Call all middleware.
 *
 *   Calls `done` on completion with either an error or the output of the
 *   last middleware.
 *
 *   > 👉 **Note**: as the length of input defines whether async functions get a
 *   > `next` function,
 *   > it’s recommended to keep `input` at one value normally.

 *
 * @typedef {(fn: Middleware) => Pipeline} Use
 *   Add middleware.
 */

/**
 * Create new middleware.
 *
 * @returns {Pipeline}
 *   Pipeline.
 */
function trough() {
  /** @type {Array<Middleware>} */
  const fns = [];
  /** @type {Pipeline} */
  const pipeline = {run, use};

  return pipeline

  /** @type {Run} */
  function run(...values) {
    let middlewareIndex = -1;
    /** @type {Callback} */
    const callback = values.pop();

    if (typeof callback !== 'function') {
      throw new TypeError('Expected function as last argument, not ' + callback)
    }

    next(null, ...values);

    /**
     * Run the next `fn`, or we’re done.
     *
     * @param {Error | null | undefined} error
     * @param {Array<any>} output
     */
    function next(error, ...output) {
      const fn = fns[++middlewareIndex];
      let index = -1;

      if (error) {
        callback(error);
        return
      }

      // Copy non-nullish input into values.
      while (++index < values.length) {
        if (output[index] === null || output[index] === undefined) {
          output[index] = values[index];
        }
      }

      // Save the newly created `output` for the next call.
      values = output;

      // Next or done.
      if (fn) {
        wrap$1(fn, next)(...output);
      } else {
        callback(null, ...output);
      }
    }
  }

  /** @type {Use} */
  function use(middelware) {
    if (typeof middelware !== 'function') {
      throw new TypeError(
        'Expected `middelware` to be a function, not ' + middelware
      )
    }

    fns.push(middelware);
    return pipeline
  }
}

/**
 * Wrap `middleware` into a uniform interface.
 *
 * You can pass all input to the resulting function.
 * `callback` is then called with the output of `middleware`.
 *
 * If `middleware` accepts more arguments than the later given in input,
 * an extra `done` function is passed to it after that input,
 * which must be called by `middleware`.
 *
 * The first value in `input` is the main input value.
 * All other input values are the rest input values.
 * The values given to `callback` are the input values,
 * merged with every non-nullish output value.
 *
 * * if `middleware` throws an error,
 *   returns a promise that is rejected,
 *   or calls the given `done` function with an error,
 *   `callback` is called with that error
 * * if `middleware` returns a value or returns a promise that is resolved,
 *   that value is the main output value
 * * if `middleware` calls `done`,
 *   all non-nullish values except for the first one (the error) overwrite the
 *   output values
 *
 * @param {Middleware} middleware
 *   Function to wrap.
 * @param {Callback} callback
 *   Callback called with the output of `middleware`.
 * @returns {Run}
 *   Wrapped middleware.
 */
function wrap$1(middleware, callback) {
  /** @type {boolean} */
  let called;

  return wrapped

  /**
   * Call `middleware`.
   * @this {any}
   * @param {Array<any>} parameters
   * @returns {void}
   */
  function wrapped(...parameters) {
    const fnExpectsCallback = middleware.length > parameters.length;
    /** @type {any} */
    let result;

    if (fnExpectsCallback) {
      parameters.push(done);
    }

    try {
      result = middleware.apply(this, parameters);
    } catch (error) {
      const exception = /** @type {Error} */ (error);

      // Well, this is quite the pickle.
      // `middleware` received a callback and called it synchronously, but that
      // threw an error.
      // The only thing left to do is to throw the thing instead.
      if (fnExpectsCallback && called) {
        throw exception
      }

      return done(exception)
    }

    if (!fnExpectsCallback) {
      if (result && result.then && typeof result.then === 'function') {
        result.then(then, done);
      } else if (result instanceof Error) {
        done(result);
      } else {
        then(result);
      }
    }
  }

  /**
   * Call `callback`, only once.
   *
   * @type {Callback}
   */
  function done(error, ...output) {
    if (!called) {
      called = true;
      callback(error, ...output);
    }
  }

  /**
   * Call `done` with one value.
   *
   * @param {any} [value]
   */
  function then(value) {
    done(null, value);
  }
}

/**
 * @typedef {import('unist').Node} Node
 * @typedef {import('vfile').VFileCompatible} VFileCompatible
 * @typedef {import('vfile').VFileValue} VFileValue
 * @typedef {import('..').Processor} Processor
 * @typedef {import('..').Plugin} Plugin
 * @typedef {import('..').Preset} Preset
 * @typedef {import('..').Pluggable} Pluggable
 * @typedef {import('..').PluggableList} PluggableList
 * @typedef {import('..').Transformer} Transformer
 * @typedef {import('..').Parser} Parser
 * @typedef {import('..').Compiler} Compiler
 * @typedef {import('..').RunCallback} RunCallback
 * @typedef {import('..').ProcessCallback} ProcessCallback
 *
 * @typedef Context
 * @property {Node} tree
 * @property {VFile} file
 */


// Expose a frozen processor.
const unified = base().freeze();

const own$7 = {}.hasOwnProperty;

// Function to create the first processor.
/**
 * @returns {Processor}
 */
function base() {
  const transformers = trough();
  /** @type {Processor['attachers']} */
  const attachers = [];
  /** @type {Record<string, unknown>} */
  let namespace = {};
  /** @type {boolean|undefined} */
  let frozen;
  let freezeIndex = -1;

  // Data management.
  // @ts-expect-error: overloads are handled.
  processor.data = data;
  processor.Parser = undefined;
  processor.Compiler = undefined;

  // Lock.
  processor.freeze = freeze;

  // Plugins.
  processor.attachers = attachers;
  // @ts-expect-error: overloads are handled.
  processor.use = use;

  // API.
  processor.parse = parse;
  processor.stringify = stringify;
  // @ts-expect-error: overloads are handled.
  processor.run = run;
  processor.runSync = runSync;
  // @ts-expect-error: overloads are handled.
  processor.process = process;
  processor.processSync = processSync;

  // Expose.
  return processor

  // Create a new processor based on the processor in the current scope.
  /** @type {Processor} */
  function processor() {
    const destination = base();
    let index = -1;

    while (++index < attachers.length) {
      destination.use(...attachers[index]);
    }

    destination.data(extend$1(true, {}, namespace));

    return destination
  }

  /**
   * @param {string|Record<string, unknown>} [key]
   * @param {unknown} [value]
   * @returns {unknown}
   */
  function data(key, value) {
    if (typeof key === 'string') {
      // Set `key`.
      if (arguments.length === 2) {
        assertUnfrozen('data', frozen);
        namespace[key] = value;
        return processor
      }

      // Get `key`.
      return (own$7.call(namespace, key) && namespace[key]) || null
    }

    // Set space.
    if (key) {
      assertUnfrozen('data', frozen);
      namespace = key;
      return processor
    }

    // Get space.
    return namespace
  }

  /** @type {Processor['freeze']} */
  function freeze() {
    if (frozen) {
      return processor
    }

    while (++freezeIndex < attachers.length) {
      const [attacher, ...options] = attachers[freezeIndex];

      if (options[0] === false) {
        continue
      }

      if (options[0] === true) {
        options[0] = undefined;
      }

      /** @type {Transformer|void} */
      const transformer = attacher.call(processor, ...options);

      if (typeof transformer === 'function') {
        transformers.use(transformer);
      }
    }

    frozen = true;
    freezeIndex = Number.POSITIVE_INFINITY;

    return processor
  }

  /**
   * @param {Pluggable|null|undefined} [value]
   * @param {...unknown} options
   * @returns {Processor}
   */
  function use(value, ...options) {
    /** @type {Record<string, unknown>|undefined} */
    let settings;

    assertUnfrozen('use', frozen);

    if (value === null || value === undefined) ; else if (typeof value === 'function') {
      addPlugin(value, ...options);
    } else if (typeof value === 'object') {
      if (Array.isArray(value)) {
        addList(value);
      } else {
        addPreset(value);
      }
    } else {
      throw new TypeError('Expected usable value, not `' + value + '`')
    }

    if (settings) {
      namespace.settings = Object.assign(namespace.settings || {}, settings);
    }

    return processor

    /**
     * @param {import('..').Pluggable<unknown[]>} value
     * @returns {void}
     */
    function add(value) {
      if (typeof value === 'function') {
        addPlugin(value);
      } else if (typeof value === 'object') {
        if (Array.isArray(value)) {
          const [plugin, ...options] = value;
          addPlugin(plugin, ...options);
        } else {
          addPreset(value);
        }
      } else {
        throw new TypeError('Expected usable value, not `' + value + '`')
      }
    }

    /**
     * @param {Preset} result
     * @returns {void}
     */
    function addPreset(result) {
      addList(result.plugins);

      if (result.settings) {
        settings = Object.assign(settings || {}, result.settings);
      }
    }

    /**
     * @param {PluggableList|null|undefined} [plugins]
     * @returns {void}
     */
    function addList(plugins) {
      let index = -1;

      if (plugins === null || plugins === undefined) ; else if (Array.isArray(plugins)) {
        while (++index < plugins.length) {
          const thing = plugins[index];
          add(thing);
        }
      } else {
        throw new TypeError('Expected a list of plugins, not `' + plugins + '`')
      }
    }

    /**
     * @param {Plugin} plugin
     * @param {...unknown} [value]
     * @returns {void}
     */
    function addPlugin(plugin, value) {
      let index = -1;
      /** @type {Processor['attachers'][number]|undefined} */
      let entry;

      while (++index < attachers.length) {
        if (attachers[index][0] === plugin) {
          entry = attachers[index];
          break
        }
      }

      if (entry) {
        if (isPlainObject(entry[1]) && isPlainObject(value)) {
          value = extend$1(true, entry[1], value);
        }

        entry[1] = value;
      } else {
        // @ts-expect-error: fine.
        attachers.push([...arguments]);
      }
    }
  }

  /** @type {Processor['parse']} */
  function parse(doc) {
    processor.freeze();
    const file = vfile(doc);
    const Parser = processor.Parser;
    assertParser('parse', Parser);

    if (newable(Parser, 'parse')) {
      // @ts-expect-error: `newable` checks this.
      return new Parser(String(file), file).parse()
    }

    // @ts-expect-error: `newable` checks this.
    return Parser(String(file), file) // eslint-disable-line new-cap
  }

  /** @type {Processor['stringify']} */
  function stringify(node, doc) {
    processor.freeze();
    const file = vfile(doc);
    const Compiler = processor.Compiler;
    assertCompiler('stringify', Compiler);
    assertNode(node);

    if (newable(Compiler, 'compile')) {
      // @ts-expect-error: `newable` checks this.
      return new Compiler(node, file).compile()
    }

    // @ts-expect-error: `newable` checks this.
    return Compiler(node, file) // eslint-disable-line new-cap
  }

  /**
   * @param {Node} node
   * @param {VFileCompatible|RunCallback} [doc]
   * @param {RunCallback} [callback]
   * @returns {Promise<Node>|void}
   */
  function run(node, doc, callback) {
    assertNode(node);
    processor.freeze();

    if (!callback && typeof doc === 'function') {
      callback = doc;
      doc = undefined;
    }

    if (!callback) {
      return new Promise(executor)
    }

    executor(null, callback);

    /**
     * @param {null|((node: Node) => void)} resolve
     * @param {(error: Error) => void} reject
     * @returns {void}
     */
    function executor(resolve, reject) {
      // @ts-expect-error: `doc` can’t be a callback anymore, we checked.
      transformers.run(node, vfile(doc), done);

      /**
       * @param {Error|null} error
       * @param {Node} tree
       * @param {VFile} file
       * @returns {void}
       */
      function done(error, tree, file) {
        tree = tree || node;
        if (error) {
          reject(error);
        } else if (resolve) {
          resolve(tree);
        } else {
          // @ts-expect-error: `callback` is defined if `resolve` is not.
          callback(null, tree, file);
        }
      }
    }
  }

  /** @type {Processor['runSync']} */
  function runSync(node, file) {
    /** @type {Node|undefined} */
    let result;
    /** @type {boolean|undefined} */
    let complete;

    processor.run(node, file, done);

    assertDone('runSync', 'run', complete);

    // @ts-expect-error: we either bailed on an error or have a tree.
    return result

    /**
     * @param {Error|null} [error]
     * @param {Node} [tree]
     * @returns {void}
     */
    function done(error, tree) {
      bail(error);
      result = tree;
      complete = true;
    }
  }

  /**
   * @param {VFileCompatible} doc
   * @param {ProcessCallback} [callback]
   * @returns {Promise<VFile>|undefined}
   */
  function process(doc, callback) {
    processor.freeze();
    assertParser('process', processor.Parser);
    assertCompiler('process', processor.Compiler);

    if (!callback) {
      return new Promise(executor)
    }

    executor(null, callback);

    /**
     * @param {null|((file: VFile) => void)} resolve
     * @param {(error?: Error|null|undefined) => void} reject
     * @returns {void}
     */
    function executor(resolve, reject) {
      const file = vfile(doc);

      processor.run(processor.parse(file), file, (error, tree, file) => {
        if (error || !tree || !file) {
          done(error);
        } else {
          /** @type {unknown} */
          const result = processor.stringify(tree, file);

          if (result === undefined || result === null) ; else if (looksLikeAVFileValue(result)) {
            file.value = result;
          } else {
            file.result = result;
          }

          done(error, file);
        }
      });

      /**
       * @param {Error|null|undefined} [error]
       * @param {VFile|undefined} [file]
       * @returns {void}
       */
      function done(error, file) {
        if (error || !file) {
          reject(error);
        } else if (resolve) {
          resolve(file);
        } else {
          // @ts-expect-error: `callback` is defined if `resolve` is not.
          callback(null, file);
        }
      }
    }
  }

  /** @type {Processor['processSync']} */
  function processSync(doc) {
    /** @type {boolean|undefined} */
    let complete;

    processor.freeze();
    assertParser('processSync', processor.Parser);
    assertCompiler('processSync', processor.Compiler);

    const file = vfile(doc);

    processor.process(file, done);

    assertDone('processSync', 'process', complete);

    return file

    /**
     * @param {Error|null|undefined} [error]
     * @returns {void}
     */
    function done(error) {
      complete = true;
      bail(error);
    }
  }
}

/**
 * Check if `value` is a constructor.
 *
 * @param {unknown} value
 * @param {string} name
 * @returns {boolean}
 */
function newable(value, name) {
  return (
    typeof value === 'function' &&
    // Prototypes do exist.
    // type-coverage:ignore-next-line
    value.prototype &&
    // A function with keys in its prototype is probably a constructor.
    // Classes’ prototype methods are not enumerable, so we check if some value
    // exists in the prototype.
    // type-coverage:ignore-next-line
    (keys(value.prototype) || name in value.prototype)
  )
}

/**
 * Check if `value` is an object with keys.
 *
 * @param {Record<string, unknown>} value
 * @returns {boolean}
 */
function keys(value) {
  /** @type {string} */
  let key;

  for (key in value) {
    if (own$7.call(value, key)) {
      return true
    }
  }

  return false
}

/**
 * Assert a parser is available.
 *
 * @param {string} name
 * @param {unknown} value
 * @returns {asserts value is Parser}
 */
function assertParser(name, value) {
  if (typeof value !== 'function') {
    throw new TypeError('Cannot `' + name + '` without `Parser`')
  }
}

/**
 * Assert a compiler is available.
 *
 * @param {string} name
 * @param {unknown} value
 * @returns {asserts value is Compiler}
 */
function assertCompiler(name, value) {
  if (typeof value !== 'function') {
    throw new TypeError('Cannot `' + name + '` without `Compiler`')
  }
}

/**
 * Assert the processor is not frozen.
 *
 * @param {string} name
 * @param {unknown} frozen
 * @returns {asserts frozen is false}
 */
function assertUnfrozen(name, frozen) {
  if (frozen) {
    throw new Error(
      'Cannot call `' +
        name +
        '` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`.'
    )
  }
}

/**
 * Assert `node` is a unist node.
 *
 * @param {unknown} node
 * @returns {asserts node is Node}
 */
function assertNode(node) {
  // `isPlainObj` unfortunately uses `any` instead of `unknown`.
  // type-coverage:ignore-next-line
  if (!isPlainObject(node) || typeof node.type !== 'string') {
    throw new TypeError('Expected node, got `' + node + '`')
    // Fine.
  }
}

/**
 * Assert that `complete` is `true`.
 *
 * @param {string} name
 * @param {string} asyncName
 * @param {unknown} complete
 * @returns {asserts complete is true}
 */
function assertDone(name, asyncName, complete) {
  if (!complete) {
    throw new Error(
      '`' + name + '` finished async. Use `' + asyncName + '` instead'
    )
  }
}

/**
 * @param {VFileCompatible} [value]
 * @returns {VFile}
 */
function vfile(value) {
  return looksLikeAVFile(value) ? value : new VFile(value)
}

/**
 * @param {VFileCompatible} [value]
 * @returns {value is VFile}
 */
function looksLikeAVFile(value) {
  return Boolean(
    value &&
      typeof value === 'object' &&
      'message' in value &&
      'messages' in value
  )
}

/**
 * @param {unknown} [value]
 * @returns {value is VFileValue}
 */
function looksLikeAVFileValue(value) {
  return typeof value === 'string' || isBuffer$1(value)
}

/**
 * @typedef {import('mdast').Root|import('mdast').Content} Node
 *
 * @typedef Options
 *   Configuration (optional).
 * @property {boolean | null | undefined} [includeImageAlt=true]
 *   Whether to use `alt` for `image`s.
 * @property {boolean | null | undefined} [includeHtml=true]
 *   Whether to use `value` of HTML.
 */

/** @type {Options} */
const emptyOptions = {};

/**
 * Get the text content of a node or list of nodes.
 *
 * Prefers the node’s plain-text fields, otherwise serializes its children,
 * and if the given value is an array, serialize the nodes in it.
 *
 * @param {unknown} value
 *   Thing to serialize, typically `Node`.
 * @param {Options | null | undefined} [options]
 *   Configuration (optional).
 * @returns {string}
 *   Serialized `value`.
 */
function toString(value, options) {
  const settings = emptyOptions;
  const includeImageAlt =
    typeof settings.includeImageAlt === 'boolean'
      ? settings.includeImageAlt
      : true;
  const includeHtml =
    typeof settings.includeHtml === 'boolean' ? settings.includeHtml : true;

  return one$1(value, includeImageAlt, includeHtml)
}

/**
 * One node or several nodes.
 *
 * @param {unknown} value
 *   Thing to serialize.
 * @param {boolean} includeImageAlt
 *   Include image `alt`s.
 * @param {boolean} includeHtml
 *   Include HTML.
 * @returns {string}
 *   Serialized node.
 */
function one$1(value, includeImageAlt, includeHtml) {
  if (node(value)) {
    if ('value' in value) {
      return value.type === 'html' && !includeHtml ? '' : value.value
    }

    if (includeImageAlt && 'alt' in value && value.alt) {
      return value.alt
    }

    if ('children' in value) {
      return all$1(value.children, includeImageAlt, includeHtml)
    }
  }

  if (Array.isArray(value)) {
    return all$1(value, includeImageAlt, includeHtml)
  }

  return ''
}

/**
 * Serialize a list of nodes.
 *
 * @param {Array<unknown>} values
 *   Thing to serialize.
 * @param {boolean} includeImageAlt
 *   Include image `alt`s.
 * @param {boolean} includeHtml
 *   Include HTML.
 * @returns {string}
 *   Serialized nodes.
 */
function all$1(values, includeImageAlt, includeHtml) {
  /** @type {Array<string>} */
  const result = [];
  let index = -1;

  while (++index < values.length) {
    result[index] = one$1(values[index], includeImageAlt, includeHtml);
  }

  return result.join('')
}

/**
 * Check if `value` looks like a node.
 *
 * @param {unknown} value
 *   Thing.
 * @returns {value is Node}
 *   Whether `value` is a node.
 */
function node(value) {
  return Boolean(value && typeof value === 'object')
}

/**
 * Like `Array#splice`, but smarter for giant arrays.
 *
 * `Array#splice` takes all items to be inserted as individual argument which
 * causes a stack overflow in V8 when trying to insert 100k items for instance.
 *
 * Otherwise, this does not return the removed items, and takes `items` as an
 * array instead of rest parameters.
 *
 * @template {unknown} T
 *   Item type.
 * @param {Array<T>} list
 *   List to operate on.
 * @param {number} start
 *   Index to remove/insert at (can be negative).
 * @param {number} remove
 *   Number of items to remove.
 * @param {Array<T>} items
 *   Items to inject into `list`.
 * @returns {void}
 *   Nothing.
 */
function splice(list, start, remove, items) {
  const end = list.length;
  let chunkStart = 0;
  /** @type {Array<unknown>} */
  let parameters;

  // Make start between zero and `end` (included).
  if (start < 0) {
    start = -start > end ? 0 : end + start;
  } else {
    start = start > end ? end : start;
  }
  remove = remove > 0 ? remove : 0;

  // No need to chunk the items if there’s only a couple (10k) items.
  if (items.length < 10000) {
    parameters = Array.from(items);
    parameters.unshift(start, remove);
    // @ts-expect-error Hush, it’s fine.
    list.splice(...parameters);
  } else {
    // Delete `remove` items starting from `start`
    if (remove) list.splice(start, remove);

    // Insert the items in chunks to not cause stack overflows.
    while (chunkStart < items.length) {
      parameters = items.slice(chunkStart, chunkStart + 10000);
      parameters.unshift(start, 0);
      // @ts-expect-error Hush, it’s fine.
      list.splice(...parameters);
      chunkStart += 10000;
      start += 10000;
    }
  }
}

/**
 * Append `items` (an array) at the end of `list` (another array).
 * When `list` was empty, returns `items` instead.
 *
 * This prevents a potentially expensive operation when `list` is empty,
 * and adds items in batches to prevent V8 from hanging.
 *
 * @template {unknown} T
 *   Item type.
 * @param {Array<T>} list
 *   List to operate on.
 * @param {Array<T>} items
 *   Items to add to `list`.
 * @returns {Array<T>}
 *   Either `list` or `items`.
 */
function push(list, items) {
  if (list.length > 0) {
    splice(list, list.length, 0, items);
    return list
  }
  return items
}

/**
 * @typedef {import('micromark-util-types').Extension} Extension
 * @typedef {import('micromark-util-types').Handles} Handles
 * @typedef {import('micromark-util-types').HtmlExtension} HtmlExtension
 * @typedef {import('micromark-util-types').NormalizedExtension} NormalizedExtension
 */


const hasOwnProperty = {}.hasOwnProperty;

/**
 * Combine multiple syntax extensions into one.
 *
 * @param {Array<Extension>} extensions
 *   List of syntax extensions.
 * @returns {NormalizedExtension}
 *   A single combined extension.
 */
function combineExtensions(extensions) {
  /** @type {NormalizedExtension} */
  const all = {};
  let index = -1;

  while (++index < extensions.length) {
    syntaxExtension(all, extensions[index]);
  }

  return all
}

/**
 * Merge `extension` into `all`.
 *
 * @param {NormalizedExtension} all
 *   Extension to merge into.
 * @param {Extension} extension
 *   Extension to merge.
 * @returns {void}
 */
function syntaxExtension(all, extension) {
  /** @type {keyof Extension} */
  let hook;

  for (hook in extension) {
    const maybe = hasOwnProperty.call(all, hook) ? all[hook] : undefined;
    /** @type {Record<string, unknown>} */
    const left = maybe || (all[hook] = {});
    /** @type {Record<string, unknown> | undefined} */
    const right = extension[hook];
    /** @type {string} */
    let code;

    if (right) {
      for (code in right) {
        if (!hasOwnProperty.call(left, code)) left[code] = [];
        const value = right[code];
        constructs(
          // @ts-expect-error Looks like a list.
          left[code],
          Array.isArray(value) ? value : value ? [value] : []
        );
      }
    }
  }
}

/**
 * Merge `list` into `existing` (both lists of constructs).
 * Mutates `existing`.
 *
 * @param {Array<unknown>} existing
 * @param {Array<unknown>} list
 * @returns {void}
 */
function constructs(existing, list) {
  let index = -1;
  /** @type {Array<unknown>} */
  const before = [];

  while (++index < list.length) {
(list[index].add === 'after' ? existing : before).push(list[index]);
  }

  splice(existing, 0, 0, before);
}

// This module is generated by `script/`.
//
// CommonMark handles attention (emphasis, strong) markers based on what comes
// before or after them.
// One such difference is if those characters are Unicode punctuation.
// This script is generated from the Unicode data.

/**
 * Regular expression that matches a unicode punctuation character.
 */
const unicodePunctuationRegex =
  /[!-\/:-@\[-`\{-~\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061D-\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1B7D\u1B7E\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u2E52-\u2E5D\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]/;

/**
 * @typedef {import('micromark-util-types').Code} Code
 */


/**
 * Check whether the character code represents an ASCII alpha (`a` through `z`,
 * case insensitive).
 *
 * An **ASCII alpha** is an ASCII upper alpha or ASCII lower alpha.
 *
 * An **ASCII upper alpha** is a character in the inclusive range U+0041 (`A`)
 * to U+005A (`Z`).
 *
 * An **ASCII lower alpha** is a character in the inclusive range U+0061 (`a`)
 * to U+007A (`z`).
 *
 * @param code
 *   Code.
 * @returns
 *   Whether it matches.
 */
const asciiAlpha = regexCheck(/[A-Za-z]/);

/**
 * Check whether the character code represents an ASCII alphanumeric (`a`
 * through `z`, case insensitive, or `0` through `9`).
 *
 * An **ASCII alphanumeric** is an ASCII digit (see `asciiDigit`) or ASCII alpha
 * (see `asciiAlpha`).
 *
 * @param code
 *   Code.
 * @returns
 *   Whether it matches.
 */
const asciiAlphanumeric = regexCheck(/[\dA-Za-z]/);

/**
 * Check whether the character code represents an ASCII atext.
 *
 * atext is an ASCII alphanumeric (see `asciiAlphanumeric`), or a character in
 * the inclusive ranges U+0023 NUMBER SIGN (`#`) to U+0027 APOSTROPHE (`'`),
 * U+002A ASTERISK (`*`), U+002B PLUS SIGN (`+`), U+002D DASH (`-`), U+002F
 * SLASH (`/`), U+003D EQUALS TO (`=`), U+003F QUESTION MARK (`?`), U+005E
 * CARET (`^`) to U+0060 GRAVE ACCENT (`` ` ``), or U+007B LEFT CURLY BRACE
 * (`{`) to U+007E TILDE (`~`).
 *
 * See:
 * **\[RFC5322]**:
 * [Internet Message Format](https://tools.ietf.org/html/rfc5322).
 * P. Resnick.
 * IETF.
 *
 * @param code
 *   Code.
 * @returns
 *   Whether it matches.
 */
const asciiAtext = regexCheck(/[#-'*+\--9=?A-Z^-~]/);

/**
 * Check whether a character code is an ASCII control character.
 *
 * An **ASCII control** is a character in the inclusive range U+0000 NULL (NUL)
 * to U+001F (US), or U+007F (DEL).
 *
 * @param {Code} code
 *   Code.
 * @returns {boolean}
 *   Whether it matches.
 */
function asciiControl(code) {
  return (
    // Special whitespace codes (which have negative values), C0 and Control
    // character DEL
    code !== null && (code < 32 || code === 127)
  )
}

/**
 * Check whether the character code represents an ASCII digit (`0` through `9`).
 *
 * An **ASCII digit** is a character in the inclusive range U+0030 (`0`) to
 * U+0039 (`9`).
 *
 * @param code
 *   Code.
 * @returns
 *   Whether it matches.
 */
const asciiDigit = regexCheck(/\d/);

/**
 * Check whether the character code represents an ASCII hex digit (`a` through
 * `f`, case insensitive, or `0` through `9`).
 *
 * An **ASCII hex digit** is an ASCII digit (see `asciiDigit`), ASCII upper hex
 * digit, or an ASCII lower hex digit.
 *
 * An **ASCII upper hex digit** is a character in the inclusive range U+0041
 * (`A`) to U+0046 (`F`).
 *
 * An **ASCII lower hex digit** is a character in the inclusive range U+0061
 * (`a`) to U+0066 (`f`).
 *
 * @param code
 *   Code.
 * @returns
 *   Whether it matches.
 */
const asciiHexDigit = regexCheck(/[\dA-Fa-f]/);

/**
 * Check whether the character code represents ASCII punctuation.
 *
 * An **ASCII punctuation** is a character in the inclusive ranges U+0021
 * EXCLAMATION MARK (`!`) to U+002F SLASH (`/`), U+003A COLON (`:`) to U+0040 AT
 * SIGN (`@`), U+005B LEFT SQUARE BRACKET (`[`) to U+0060 GRAVE ACCENT
 * (`` ` ``), or U+007B LEFT CURLY BRACE (`{`) to U+007E TILDE (`~`).
 *
 * @param code
 *   Code.
 * @returns
 *   Whether it matches.
 */
const asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/);

/**
 * Check whether a character code is a markdown line ending.
 *
 * A **markdown line ending** is the virtual characters M-0003 CARRIAGE RETURN
 * LINE FEED (CRLF), M-0004 LINE FEED (LF) and M-0005 CARRIAGE RETURN (CR).
 *
 * In micromark, the actual character U+000A LINE FEED (LF) and U+000D CARRIAGE
 * RETURN (CR) are replaced by these virtual characters depending on whether
 * they occurred together.
 *
 * @param {Code} code
 *   Code.
 * @returns {boolean}
 *   Whether it matches.
 */
function markdownLineEnding(code) {
  return code !== null && code < -2
}

/**
 * Check whether a character code is a markdown line ending (see
 * `markdownLineEnding`) or markdown space (see `markdownSpace`).
 *
 * @param {Code} code
 *   Code.
 * @returns {boolean}
 *   Whether it matches.
 */
function markdownLineEndingOrSpace(code) {
  return code !== null && (code < 0 || code === 32)
}

/**
 * Check whether a character code is a markdown space.
 *
 * A **markdown space** is the concrete character U+0020 SPACE (SP) and the
 * virtual characters M-0001 VIRTUAL SPACE (VS) and M-0002 HORIZONTAL TAB (HT).
 *
 * In micromark, the actual character U+0009 CHARACTER TABULATION (HT) is
 * replaced by one M-0002 HORIZONTAL TAB (HT) and between 0 and 3 M-0001 VIRTUAL
 * SPACE (VS) characters, depending on the column at which the tab occurred.
 *
 * @param {Code} code
 *   Code.
 * @returns {boolean}
 *   Whether it matches.
 */
function markdownSpace(code) {
  return code === -2 || code === -1 || code === 32
}

// Size note: removing ASCII from the regex and using `asciiPunctuation` here
// In fact adds to the bundle size.
/**
 * Check whether the character code represents Unicode punctuation.
 *
 * A **Unicode punctuation** is a character in the Unicode `Pc` (Punctuation,
 * Connector), `Pd` (Punctuation, Dash), `Pe` (Punctuation, Close), `Pf`
 * (Punctuation, Final quote), `Pi` (Punctuation, Initial quote), `Po`
 * (Punctuation, Other), or `Ps` (Punctuation, Open) categories, or an ASCII
 * punctuation (see `asciiPunctuation`).
 *
 * See:
 * **\[UNICODE]**:
 * [The Unicode Standard](https://www.unicode.org/versions/).
 * Unicode Consortium.
 *
 * @param code
 *   Code.
 * @returns
 *   Whether it matches.
 */
const unicodePunctuation = regexCheck(unicodePunctuationRegex);

/**
 * Check whether the character code represents Unicode whitespace.
 *
 * Note that this does handle micromark specific markdown whitespace characters.
 * See `markdownLineEndingOrSpace` to check that.
 *
 * A **Unicode whitespace** is a character in the Unicode `Zs` (Separator,
 * Space) category, or U+0009 CHARACTER TABULATION (HT), U+000A LINE FEED (LF),
 * U+000C (FF), or U+000D CARRIAGE RETURN (CR) (**\[UNICODE]**).
 *
 * See:
 * **\[UNICODE]**:
 * [The Unicode Standard](https://www.unicode.org/versions/).
 * Unicode Consortium.
 *
 * @param code
 *   Code.
 * @returns
 *   Whether it matches.
 */
const unicodeWhitespace = regexCheck(/\s/);

/**
 * Create a code check from a regex.
 *
 * @param {RegExp} regex
 * @returns {(code: Code) => boolean}
 */
function regexCheck(regex) {
  return check

  /**
   * Check whether a code matches the bound regex.
   *
   * @param {Code} code
   *   Character code.
   * @returns {boolean}
   *   Whether the character code matches the bound regex.
   */
  function check(code) {
    return code !== null && regex.test(String.fromCharCode(code))
  }
}

/**
 * @typedef {import('micromark-util-types').Effects} Effects
 * @typedef {import('micromark-util-types').State} State
 * @typedef {import('micromark-util-types').TokenType} TokenType
 */


// To do: implement `spaceOrTab`, `spaceOrTabMinMax`, `spaceOrTabWithOptions`.

/**
 * Parse spaces and tabs.
 *
 * There is no `nok` parameter:
 *
 * *   spaces in markdown are often optional, in which case this factory can be
 *     used and `ok` will be switched to whether spaces were found or not
 * *   one line ending or space can be detected with `markdownSpace(code)` right
 *     before using `factorySpace`
 *
 * ###### Examples
 *
 * Where `␉` represents a tab (plus how much it expands) and `␠` represents a
 * single space.
 *
 * ```markdown
 * ␉
 * ␠␠␠␠
 * ␉␠
 * ```
 *
 * @param {Effects} effects
 *   Context.
 * @param {State} ok
 *   State switched to when successful.
 * @param {TokenType} type
 *   Type (`' \t'`).
 * @param {number | undefined} [max=Infinity]
 *   Max (exclusive).
 * @returns
 *   Start state.
 */
function factorySpace(effects, ok, type, max) {
  const limit = max ? max - 1 : Number.POSITIVE_INFINITY;
  let size = 0;
  return start

  /** @type {State} */
  function start(code) {
    if (markdownSpace(code)) {
      effects.enter(type);
      return prefix(code)
    }
    return ok(code)
  }

  /** @type {State} */
  function prefix(code) {
    if (markdownSpace(code) && size++ < limit) {
      effects.consume(code);
      return prefix
    }
    effects.exit(type);
    return ok(code)
  }
}

/**
 * @typedef {import('micromark-util-types').InitialConstruct} InitialConstruct
 * @typedef {import('micromark-util-types').Initializer} Initializer
 * @typedef {import('micromark-util-types').State} State
 * @typedef {import('micromark-util-types').Token} Token
 * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext
 */

/** @type {InitialConstruct} */
const content$1 = {
  tokenize: initializeContent
};

/**
 * @this {TokenizeContext}
 * @type {Initializer}
 */
function initializeContent(effects) {
  const contentStart = effects.attempt(
    this.parser.constructs.contentInitial,
    afterContentStartConstruct,
    paragraphInitial
  );
  /** @type {Token} */
  let previous;
  return contentStart

  /** @type {State} */
  function afterContentStartConstruct(code) {
    if (code === null) {
      effects.consume(code);
      return
    }
    effects.enter('lineEnding');
    effects.consume(code);
    effects.exit('lineEnding');
    return factorySpace(effects, contentStart, 'linePrefix')
  }

  /** @type {State} */
  function paragraphInitial(code) {
    effects.enter('paragraph');
    return lineStart(code)
  }

  /** @type {State} */
  function lineStart(code) {
    const token = effects.enter('chunkText', {
      contentType: 'text',
      previous
    });
    if (previous) {
      previous.next = token;
    }
    previous = token;
    return data(code)
  }

  /** @type {State} */
  function data(code) {
    if (code === null) {
      effects.exit('chunkText');
      effects.exit('paragraph');
      effects.consume(code);
      return
    }
    if (markdownLineEnding(code)) {
      effects.consume(code);
      effects.exit('chunkText');
      return lineStart
    }

    // Data.
    effects.consume(code);
    return data
  }
}

/**
 * @typedef {import('micromark-util-types').Construct} Construct
 * @typedef {import('micromark-util-types').ContainerState} ContainerState
 * @typedef {import('micromark-util-types').InitialConstruct} InitialConstruct
 * @typedef {import('micromark-util-types').Initializer} Initializer
 * @typedef {import('micromark-util-types').Point} Point
 * @typedef {import('micromark-util-types').State} State
 * @typedef {import('micromark-util-types').Token} Token
 * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext
 * @typedef {import('micromark-util-types').Tokenizer} Tokenizer
 */

/** @type {InitialConstruct} */
const document$2 = {
  tokenize: initializeDocument
};

/** @type {Construct} */
const containerConstruct = {
  tokenize: tokenizeContainer
};

/**
 * @this {TokenizeContext}
 * @type {Initializer}
 */
function initializeDocument(effects) {
  const self = this;
  /** @type {Array<StackItem>} */
  const stack = [];
  let continued = 0;
  /** @type {TokenizeContext | undefined} */
  let childFlow;
  /** @type {Token | undefined} */
  let childToken;
  /** @type {number} */
  let lineStartOffset;
  return start

  /** @type {State} */
  function start(code) {
    // First we iterate through the open blocks, starting with the root
    // document, and descending through last children down to the last open
    // block.
    // Each block imposes a condition that the line must satisfy if the block is
    // to remain open.
    // For example, a block quote requires a `>` character.
    // A paragraph requires a non-blank line.
    // In this phase we may match all or just some of the open blocks.
    // But we cannot close unmatched blocks yet, because we may have a lazy
    // continuation line.
    if (continued < stack.length) {
      const item = stack[continued];
      self.containerState = item[1];
      return effects.attempt(
        item[0].continuation,
        documentContinue,
        checkNewContainers
      )(code)
    }

    // Done.
    return checkNewContainers(code)
  }

  /** @type {State} */
  function documentContinue(code) {
    continued++;

    // Note: this field is called `_closeFlow` but it also closes containers.
    // Perhaps a good idea to rename it but it’s already used in the wild by
    // extensions.
    if (self.containerState._closeFlow) {
      self.containerState._closeFlow = undefined;
      if (childFlow) {
        closeFlow();
      }

      // Note: this algorithm for moving events around is similar to the
      // algorithm when dealing with lazy lines in `writeToChild`.
      const indexBeforeExits = self.events.length;
      let indexBeforeFlow = indexBeforeExits;
      /** @type {Point | undefined} */
      let point;

      // Find the flow chunk.
      while (indexBeforeFlow--) {
        if (
          self.events[indexBeforeFlow][0] === 'exit' &&
          self.events[indexBeforeFlow][1].type === 'chunkFlow'
        ) {
          point = self.events[indexBeforeFlow][1].end;
          break
        }
      }
      exitContainers(continued);

      // Fix positions.
      let index = indexBeforeExits;
      while (index < self.events.length) {
        self.events[index][1].end = Object.assign({}, point);
        index++;
      }

      // Inject the exits earlier (they’re still also at the end).
      splice(
        self.events,
        indexBeforeFlow + 1,
        0,
        self.events.slice(indexBeforeExits)
      );

      // Discard the duplicate exits.
      self.events.length = index;
      return checkNewContainers(code)
    }
    return start(code)
  }

  /** @type {State} */
  function checkNewContainers(code) {
    // Next, after consuming the continuation markers for existing blocks, we
    // look for new block starts (e.g. `>` for a block quote).
    // If we encounter a new block start, we close any blocks unmatched in
    // step 1 before creating the new block as a child of the last matched
    // block.
    if (continued === stack.length) {
      // No need to `check` whether there’s a container, of `exitContainers`
      // would be moot.
      // We can instead immediately `attempt` to parse one.
      if (!childFlow) {
        return documentContinued(code)
      }

      // If we have concrete content, such as block HTML or fenced code,
      // we can’t have containers “pierce” into them, so we can immediately
      // start.
      if (childFlow.currentConstruct && childFlow.currentConstruct.concrete) {
        return flowStart(code)
      }

      // If we do have flow, it could still be a blank line,
      // but we’d be interrupting it w/ a new container if there’s a current
      // construct.
      // To do: next major: remove `_gfmTableDynamicInterruptHack` (no longer
      // needed in micromark-extension-gfm-table@1.0.6).
      self.interrupt = Boolean(
        childFlow.currentConstruct && !childFlow._gfmTableDynamicInterruptHack
      );
    }

    // Check if there is a new container.
    self.containerState = {};
    return effects.check(
      containerConstruct,
      thereIsANewContainer,
      thereIsNoNewContainer
    )(code)
  }

  /** @type {State} */
  function thereIsANewContainer(code) {
    if (childFlow) closeFlow();
    exitContainers(continued);
    return documentContinued(code)
  }

  /** @type {State} */
  function thereIsNoNewContainer(code) {
    self.parser.lazy[self.now().line] = continued !== stack.length;
    lineStartOffset = self.now().offset;
    return flowStart(code)
  }

  /** @type {State} */
  function documentContinued(code) {
    // Try new containers.
    self.containerState = {};
    return effects.attempt(
      containerConstruct,
      containerContinue,
      flowStart
    )(code)
  }

  /** @type {State} */
  function containerContinue(code) {
    continued++;
    stack.push([self.currentConstruct, self.containerState]);
    // Try another.
    return documentContinued(code)
  }

  /** @type {State} */
  function flowStart(code) {
    if (code === null) {
      if (childFlow) closeFlow();
      exitContainers(0);
      effects.consume(code);
      return
    }
    childFlow = childFlow || self.parser.flow(self.now());
    effects.enter('chunkFlow', {
      contentType: 'flow',
      previous: childToken,
      _tokenizer: childFlow
    });
    return flowContinue(code)
  }

  /** @type {State} */
  function flowContinue(code) {
    if (code === null) {
      writeToChild(effects.exit('chunkFlow'), true);
      exitContainers(0);
      effects.consume(code);
      return
    }
    if (markdownLineEnding(code)) {
      effects.consume(code);
      writeToChild(effects.exit('chunkFlow'));
      // Get ready for the next line.
      continued = 0;
      self.interrupt = undefined;
      return start
    }
    effects.consume(code);
    return flowContinue
  }

  /**
   * @param {Token} token
   * @param {boolean | undefined} [eof]
   * @returns {void}
   */
  function writeToChild(token, eof) {
    const stream = self.sliceStream(token);
    if (eof) stream.push(null);
    token.previous = childToken;
    if (childToken) childToken.next = token;
    childToken = token;
    childFlow.defineSkip(token.start);
    childFlow.write(stream);

    // Alright, so we just added a lazy line:
    //
    // ```markdown
    // > a
    // b.
    //
    // Or:
    //
    // > ~~~c
    // d
    //
    // Or:
    //
    // > | e |
    // f
    // ```
    //
    // The construct in the second example (fenced code) does not accept lazy
    // lines, so it marked itself as done at the end of its first line, and
    // then the content construct parses `d`.
    // Most constructs in markdown match on the first line: if the first line
    // forms a construct, a non-lazy line can’t “unmake” it.
    //
    // The construct in the third example is potentially a GFM table, and
    // those are *weird*.
    // It *could* be a table, from the first line, if the following line
    // matches a condition.
    // In this case, that second line is lazy, which “unmakes” the first line
    // and turns the whole into one content block.
    //
    // We’ve now parsed the non-lazy and the lazy line, and can figure out
    // whether the lazy line started a new flow block.
    // If it did, we exit the current containers between the two flow blocks.
    if (self.parser.lazy[token.start.line]) {
      let index = childFlow.events.length;
      while (index--) {
        if (
          // The token starts before the line ending…
          childFlow.events[index][1].start.offset < lineStartOffset &&
          // …and either is not ended yet…
          (!childFlow.events[index][1].end ||
            // …or ends after it.
            childFlow.events[index][1].end.offset > lineStartOffset)
        ) {
          // Exit: there’s still something open, which means it’s a lazy line
          // part of something.
          return
        }
      }

      // Note: this algorithm for moving events around is similar to the
      // algorithm when closing flow in `documentContinue`.
      const indexBeforeExits = self.events.length;
      let indexBeforeFlow = indexBeforeExits;
      /** @type {boolean | undefined} */
      let seen;
      /** @type {Point | undefined} */
      let point;

      // Find the previous chunk (the one before the lazy line).
      while (indexBeforeFlow--) {
        if (
          self.events[indexBeforeFlow][0] === 'exit' &&
          self.events[indexBeforeFlow][1].type === 'chunkFlow'
        ) {
          if (seen) {
            point = self.events[indexBeforeFlow][1].end;
            break
          }
          seen = true;
        }
      }
      exitContainers(continued);

      // Fix positions.
      index = indexBeforeExits;
      while (index < self.events.length) {
        self.events[index][1].end = Object.assign({}, point);
        index++;
      }

      // Inject the exits earlier (they’re still also at the end).
      splice(
        self.events,
        indexBeforeFlow + 1,
        0,
        self.events.slice(indexBeforeExits)
      );

      // Discard the duplicate exits.
      self.events.length = index;
    }
  }

  /**
   * @param {number} size
   * @returns {void}
   */
  function exitContainers(size) {
    let index = stack.length;

    // Exit open containers.
    while (index-- > size) {
      const entry = stack[index];
      self.containerState = entry[1];
      entry[0].exit.call(self, effects);
    }
    stack.length = size;
  }
  function closeFlow() {
    childFlow.write([null]);
    childToken = undefined;
    childFlow = undefined;
    self.containerState._closeFlow = undefined;
  }
}

/**
 * @this {TokenizeContext}
 * @type {Tokenizer}
 */
function tokenizeContainer(effects, ok, nok) {
  // Always populated by defaults.

  return factorySpace(
    effects,
    effects.attempt(this.parser.constructs.document, ok, nok),
    'linePrefix',
    this.parser.constructs.disable.null.includes('codeIndented') ? undefined : 4
  )
}

/**
 * @typedef {import('micromark-util-types').Code} Code
 */

/**
 * Classify whether a code represents whitespace, punctuation, or something
 * else.
 *
 * Used for attention (emphasis, strong), whose sequences can open or close
 * based on the class of surrounding characters.
 *
 * > 👉 **Note**: eof (`null`) is seen as whitespace.
 *
 * @param {Code} code
 *   Code.
 * @returns {typeof constants.characterGroupWhitespace | typeof constants.characterGroupPunctuation | undefined}
 *   Group.
 */
function classifyCharacter(code) {
  if (
    code === null ||
    markdownLineEndingOrSpace(code) ||
    unicodeWhitespace(code)
  ) {
    return 1
  }
  if (unicodePunctuation(code)) {
    return 2
  }
}

/**
 * @typedef {import('micromark-util-types').Event} Event
 * @typedef {import('micromark-util-types').Resolver} Resolver
 * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext
 */

/**
 * Call all `resolveAll`s.
 *
 * @param {Array<{resolveAll?: Resolver | undefined}>} constructs
 *   List of constructs, optionally with `resolveAll`s.
 * @param {Array<Event>} events
 *   List of events.
 * @param {TokenizeContext} context
 *   Context used by `tokenize`.
 * @returns {Array<Event>}
 *   Changed events.
 */
function resolveAll(constructs, events, context) {
  /** @type {Array<Resolver>} */
  const called = [];
  let index = -1;

  while (++index < constructs.length) {
    const resolve = constructs[index].resolveAll;

    if (resolve && !called.includes(resolve)) {
      events = resolve(events, context);
      called.push(resolve);
    }
  }

  return events
}

/**
 * @typedef {import('micromark-util-types').Code} Code
 * @typedef {import('micromark-util-types').Construct} Construct
 * @typedef {import('micromark-util-types').Event} Event
 * @typedef {import('micromark-util-types').Point} Point
 * @typedef {import('micromark-util-types').Resolver} Resolver
 * @typedef {import('micromark-util-types').State} State
 * @typedef {import('micromark-util-types').Token} Token
 * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext
 * @typedef {import('micromark-util-types').Tokenizer} Tokenizer
 */

/** @type {Construct} */
const attention = {
  name: 'attention',
  tokenize: tokenizeAttention,
  resolveAll: resolveAllAttention
};

/**
 * Take all events and resolve attention to emphasis or strong.
 *
 * @type {Resolver}
 */
function resolveAllAttention(events, context) {
  let index = -1;
  /** @type {number} */
  let open;
  /** @type {Token} */
  let group;
  /** @type {Token} */
  let text;
  /** @type {Token} */
  let openingSequence;
  /** @type {Token} */
  let closingSequence;
  /** @type {number} */
  let use;
  /** @type {Array<Event>} */
  let nextEvents;
  /** @type {number} */
  let offset;

  // Walk through all events.
  //
  // Note: performance of this is fine on an mb of normal markdown, but it’s
  // a bottleneck for malicious stuff.
  while (++index < events.length) {
    // Find a token that can close.
    if (
      events[index][0] === 'enter' &&
      events[index][1].type === 'attentionSequence' &&
      events[index][1]._close
    ) {
      open = index;

      // Now walk back to find an opener.
      while (open--) {
        // Find a token that can open the closer.
        if (
          events[open][0] === 'exit' &&
          events[open][1].type === 'attentionSequence' &&
          events[open][1]._open &&
          // If the markers are the same:
          context.sliceSerialize(events[open][1]).charCodeAt(0) ===
            context.sliceSerialize(events[index][1]).charCodeAt(0)
        ) {
          // If the opening can close or the closing can open,
          // and the close size *is not* a multiple of three,
          // but the sum of the opening and closing size *is* multiple of three,
          // then don’t match.
          if (
            (events[open][1]._close || events[index][1]._open) &&
            (events[index][1].end.offset - events[index][1].start.offset) % 3 &&
            !(
              (events[open][1].end.offset -
                events[open][1].start.offset +
                events[index][1].end.offset -
                events[index][1].start.offset) %
              3
            )
          ) {
            continue
          }

          // Number of markers to use from the sequence.
          use =
            events[open][1].end.offset - events[open][1].start.offset > 1 &&
            events[index][1].end.offset - events[index][1].start.offset > 1
              ? 2
              : 1;
          const start = Object.assign({}, events[open][1].end);
          const end = Object.assign({}, events[index][1].start);
          movePoint(start, -use);
          movePoint(end, use);
          openingSequence = {
            type: use > 1 ? 'strongSequence' : 'emphasisSequence',
            start,
            end: Object.assign({}, events[open][1].end)
          };
          closingSequence = {
            type: use > 1 ? 'strongSequence' : 'emphasisSequence',
            start: Object.assign({}, events[index][1].start),
            end
          };
          text = {
            type: use > 1 ? 'strongText' : 'emphasisText',
            start: Object.assign({}, events[open][1].end),
            end: Object.assign({}, events[index][1].start)
          };
          group = {
            type: use > 1 ? 'strong' : 'emphasis',
            start: Object.assign({}, openingSequence.start),
            end: Object.assign({}, closingSequence.end)
          };
          events[open][1].end = Object.assign({}, openingSequence.start);
          events[index][1].start = Object.assign({}, closingSequence.end);
          nextEvents = [];

          // If there are more markers in the opening, add them before.
          if (events[open][1].end.offset - events[open][1].start.offset) {
            nextEvents = push(nextEvents, [
              ['enter', events[open][1], context],
              ['exit', events[open][1], context]
            ]);
          }

          // Opening.
          nextEvents = push(nextEvents, [
            ['enter', group, context],
            ['enter', openingSequence, context],
            ['exit', openingSequence, context],
            ['enter', text, context]
          ]);

          // Always populated by defaults.

          // Between.
          nextEvents = push(
            nextEvents,
            resolveAll(
              context.parser.constructs.insideSpan.null,
              events.slice(open + 1, index),
              context
            )
          );

          // Closing.
          nextEvents = push(nextEvents, [
            ['exit', text, context],
            ['enter', closingSequence, context],
            ['exit', closingSequence, context],
            ['exit', group, context]
          ]);

          // If there are more markers in the closing, add them after.
          if (events[index][1].end.offset - events[index][1].start.offset) {
            offset = 2;
            nextEvents = push(nextEvents, [
              ['enter', events[index][1], context],
              ['exit', events[index][1], context]
            ]);
          } else {
            offset = 0;
          }
          splice(events, open - 1, index - open + 3, nextEvents);
          index = open + nextEvents.length - offset - 2;
          break
        }
      }
    }
  }

  // Remove remaining sequences.
  index = -1;
  while (++index < events.length) {
    if (events[index][1].type === 'attentionSequence') {
      events[index][1].type = 'data';
    }
  }
  return events
}

/**
 * @this {TokenizeContext}
 * @type {Tokenizer}
 */
function tokenizeAttention(effects, ok) {
  const attentionMarkers = this.parser.constructs.attentionMarkers.null;
  const previous = this.previous;
  const before = classifyCharacter(previous);

  /** @type {NonNullable<Code>} */
  let marker;
  return start

  /**
   * Before a sequence.
   *
   * ```markdown
   * > | **
   *     ^
   * ```
   *
   * @type {State}
   */
  function start(code) {
    marker = code;
    effects.enter('attentionSequence');
    return inside(code)
  }

  /**
   * In a sequence.
   *
   * ```markdown
   * > | **
   *     ^^
   * ```
   *
   * @type {State}
   */
  function inside(code) {
    if (code === marker) {
      effects.consume(code);
      return inside
    }
    const token = effects.exit('attentionSequence');

    // To do: next major: move this to resolver, just like `markdown-rs`.
    const after = classifyCharacter(code);

    // Always populated by defaults.

    const open =
      !after || (after === 2 && before) || attentionMarkers.includes(code);
    const close =
      !before || (before === 2 && after) || attentionMarkers.includes(previous);
    token._open = Boolean(marker === 42 ? open : open && (before || !close));
    token._close = Boolean(marker === 42 ? close : close && (after || !open));
    return ok(code)
  }
}

/**
 * Move a point a bit.
 *
 * Note: `move` only works inside lines! It’s not possible to move past other
 * chunks (replacement characters, tabs, or line endings).
 *
 * @param {Point} point
 * @param {number} offset
 * @returns {void}
 */
function movePoint(point, offset) {
  point.column += offset;
  point.offset += offset;
  point._bufferIndex += offset;
}

/**
 * @typedef {import('micromark-util-types').Construct} Construct
 * @typedef {import('micromark-util-types').State} State
 * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext
 * @typedef {import('micromark-util-types').Tokenizer} Tokenizer
 */

/** @type {Construct} */
const autolink = {
  name: 'autolink',
  tokenize: tokenizeAutolink
};

/**
 * @this {TokenizeContext}
 * @type {Tokenizer}
 */
function tokenizeAutolink(effects, ok, nok) {
  let size = 0;
  return start

  /**
   * Start of an autolink.
   *
   * ```markdown
   * > | a<https://example.com>b
   *      ^
   * > | a<user@example.com>b
   *      ^
   * ```
   *
   * @type {State}
   */
  function start(code) {
    effects.enter('autolink');
    effects.enter('autolinkMarker');
    effects.consume(code);
    effects.exit('autolinkMarker');
    effects.enter('autolinkProtocol');
    return open
  }

  /**
   * After `<`, at protocol or atext.
   *
   * ```markdown
   * > | a<https://example.com>b
   *       ^
   * > | a<user@example.com>b
   *       ^
   * ```
   *
   * @type {State}
   */
  function open(code) {
    if (asciiAlpha(code)) {
      effects.consume(code);
      return schemeOrEmailAtext
    }
    return emailAtext(code)
  }

  /**
   * At second byte of protocol or atext.
   *
   * ```markdown
   * > | a<https://example.com>b
   *        ^
   * > | a<user@example.com>b
   *        ^
   * ```
   *
   * @type {State}
   */
  function schemeOrEmailAtext(code) {
    // ASCII alphanumeric and `+`, `-`, and `.`.
    if (code === 43 || code === 45 || code === 46 || asciiAlphanumeric(code)) {
      // Count the previous alphabetical from `open` too.
      size = 1;
      return schemeInsideOrEmailAtext(code)
    }
    return emailAtext(code)
  }

  /**
   * In ambiguous protocol or atext.
   *
   * ```markdown
   * > | a<https://example.com>b
   *        ^
   * > | a<user@example.com>b
   *        ^
   * ```
   *
   * @type {State}
   */
  function schemeInsideOrEmailAtext(code) {
    if (code === 58) {
      effects.consume(code);
      size = 0;
      return urlInside
    }

    // ASCII alphanumeric and `+`, `-`, and `.`.
    if (
      (code === 43 || code === 45 || code === 46 || asciiAlphanumeric(code)) &&
      size++ < 32
    ) {
      effects.consume(code);
      return schemeInsideOrEmailAtext
    }
    size = 0;
    return emailAtext(code)
  }

  /**
   * After protocol, in URL.
   *
   * ```markdown
   * > | a<https://example.com>b
   *             ^
   * ```
   *
   * @type {State}
   */
  function urlInside(code) {
    if (code === 62) {
      effects.exit('autolinkProtocol');
      effects.enter('autolinkMarker');
      effects.consume(code);
      effects.exit('autolinkMarker');
      effects.exit('autolink');
      return ok
    }

    // ASCII control, space, or `<`.
    if (code === null || code === 32 || code === 60 || asciiControl(code)) {
      return nok(code)
    }
    effects.consume(code);
    return urlInside
  }

  /**
   * In email atext.
   *
   * ```markdown
   * > | a<user.name@example.com>b
   *              ^
   * ```
   *
   * @type {State}
   */
  function emailAtext(code) {
    if (code === 64) {
      effects.consume(code);
      return emailAtSignOrDot
    }
    if (asciiAtext(code)) {
      effects.consume(code);
      return emailAtext
    }
    return nok(code)
  }

  /**
   * In label, after at-sign or dot.
   *
   * ```markdown
   * > | a<user.name@example.com>b
   *                 ^       ^
   * ```
   *
   * @type {State}
   */
  function emailAtSignOrDot(code) {
    return asciiAlphanumeric(code) ? emailLabel(code) : nok(code)
  }

  /**
   * In label, where `.` and `>` are allowed.
   *
   * ```markdown
   * > | a<user.name@example.com>b
   *                   ^
   * ```
   *
   * @type {State}
   */
  function emailLabel(code) {
    if (code === 46) {
      effects.consume(code);
      size = 0;
      return emailAtSignOrDot
    }
    if (code === 62) {
      // Exit, then change the token type.
      effects.exit('autolinkProtocol').type = 'autolinkEmail';
      effects.enter('autolinkMarker');
      effects.consume(code);
      effects.exit('autolinkMarker');
      effects.exit('autolink');
      return ok
    }
    return emailValue(code)
  }

  /**
   * In label, where `.` and `>` are *not* allowed.
   *
   * Though, this is also used in `emailLabel` to parse other values.
   *
   * ```markdown
   * > | a<user.name@ex-ample.com>b
   *                    ^
   * ```
   *
   * @type {State}
   */
  function emailValue(code) {
    // ASCII alphanumeric or `-`.
    if ((code === 45 || asciiAlphanumeric(code)) && size++ < 63) {
      const next = code === 45 ? emailValue : emailLabel;
      effects.consume(code);
      return next
    }
    return nok(code)
  }
}

/**
 * @typedef {import('micromark-util-types').Construct} Construct
 * @typedef {import('micromark-util-types').State} State
 * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext
 * @typedef {import('micromark-util-types').Tokenizer} Tokenizer
 */

/** @type {Construct} */
const blankLine = {
  tokenize: tokenizeBlankLine,
  partial: true
};

/**
 * @this {TokenizeContext}
 * @type {Tokenizer}
 */
function tokenizeBlankLine(effects, ok, nok) {
  return start

  /**
   * Start of blank line.
   *
   * > 👉 **Note**: `␠` represents a space character.
   *
   * ```markdown
   * > | ␠␠␊
   *     ^
   * > | ␊
   *     ^
   * ```
   *
   * @type {State}
   */
  function start(code) {
    return markdownSpace(code)
      ? factorySpace(effects, after, 'linePrefix')(code)
      : after(code)
  }

  /**
   * At eof/eol, after optional whitespace.
   *
   * > 👉 **Note**: `␠` represents a space character.
   *
   * ```markdown
   * > | ␠␠␊
   *       ^
   * > | ␊
   *     ^
   * ```
   *
   * @type {State}
   */
  function after(code) {
    return code === null || markdownLineEnding(code) ? ok(code) : nok(code)
  }
}

/**
 * @typedef {import('micromark-util-types').Construct} Construct
 * @typedef {import('micromark-util-types').Exiter} Exiter
 * @typedef {import('micromark-util-types').State} State
 * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext
 * @typedef {import('micromark-util-types').Tokenizer} Tokenizer
 */

/** @type {Construct} */
const blockQuote = {
  name: 'blockQuote',
  tokenize: tokenizeBlockQuoteStart,
  continuation: {
    tokenize: tokenizeBlockQuoteContinuation
  },
  exit: exit$1
};

/**
 * @this {TokenizeContext}
 * @type {Tokenizer}
 */
function tokenizeBlockQuoteStart(effects, ok, nok) {
  const self = this;
  return start

  /**
   * Start of block quote.
   *
   * ```markdown
   * > | > a
   *     ^
   * ```
   *
   * @type {State}
   */
  function start(code) {
    if (code === 62) {
      const state = self.containerState;
      if (!state.open) {
        effects.enter('blockQuote', {
          _container: true
        });
        state.open = true;
      }
      effects.enter('blockQuotePrefix');
      effects.enter('blockQuoteMarker');
      effects.consume(code);
      effects.exit('blockQuoteMarker');
      return after
    }
    return nok(code)
  }

  /**
   * After `>`, before optional whitespace.
   *
   * ```markdown
   * > | > a
   *      ^
   * ```
   *
   * @type {State}
   */
  function after(code) {
    if (markdownSpace(code)) {
      effects.enter('blockQuotePrefixWhitespace');
      effects.consume(code);
      effects.exit('blockQuotePrefixWhitespace');
      effects.exit('blockQuotePrefix');
      return ok
    }
    effects.exit('blockQuotePrefix');
    return ok(code)
  }
}

/**
 * Start of block quote continuation.
 *
 * ```markdown
 *   | > a
 * > | > b
 *     ^
 * ```
 *
 * @this {TokenizeContext}
 * @type {Tokenizer}
 */
function tokenizeBlockQuoteContinuation(effects, ok, nok) {
  const self = this;
  return contStart

  /**
   * Start of block quote continuation.
   *
   * Also used to parse the first block quote opening.
   *
   * ```markdown
   *   | > a
   * > | > b
   *     ^
   * ```
   *
   * @type {State}
   */
  function contStart(code) {
    if (markdownSpace(code)) {
      // Always populated by defaults.

      return factorySpace(
        effects,
        contBefore,
        'linePrefix',
        self.parser.constructs.disable.null.includes('codeIndented')
          ? undefined
          : 4
      )(code)
    }
    return contBefore(code)
  }

  /**
   * At `>`, after optional whitespace.
   *
   * Also used to parse the first block quote opening.
   *
   * ```markdown
   *   | > a
   * > | > b
   *     ^
   * ```
   *
   * @type {State}
   */
  function contBefore(code) {
    return effects.attempt(blockQuote, ok, nok)(code)
  }
}

/** @type {Exiter} */
function exit$1(effects) {
  effects.exit('blockQuote');
}

/**
 * @typedef {import('micromark-util-types').Construct} Construct
 * @typedef {import('micromark-util-types').State} State
 * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext
 * @typedef {import('micromark-util-types').Tokenizer} Tokenizer
 */

/** @type {Construct} */
const characterEscape = {
  name: 'characterEscape',
  tokenize: tokenizeCharacterEscape
};

/**
 * @this {TokenizeContext}
 * @type {Tokenizer}
 */
function tokenizeCharacterEscape(effects, ok, nok) {
  return start

  /**
   * Start of character escape.
   *
   * ```markdown
   * > | a\*b
   *      ^
   * ```
   *
   * @type {State}
   */
  function start(code) {
    effects.enter('characterEscape');
    effects.enter('escapeMarker');
    effects.consume(code);
    effects.exit('escapeMarker');
    return inside
  }

  /**
   * After `\`, at punctuation.
   *
   * ```markdown
   * > | a\*b
   *       ^
   * ```
   *
   * @type {State}
   */
  function inside(code) {
    // ASCII punctuation.
    if (asciiPunctuation(code)) {
      effects.enter('characterEscapeValue');
      effects.consume(code);
      effects.exit('characterEscapeValue');
      effects.exit('characterEscape');
      return ok
    }
    return nok(code)
  }
}

/// <reference lib="dom" />

/* eslint-env browser */

const element = document.createElement('i');

/**
 * @param {string} value
 * @returns {string|false}
 */
function decodeNamedCharacterReference(value) {
  const characterReference = '&' + value + ';';
  element.innerHTML = characterReference;
  const char = element.textContent;

  // Some named character references do not require the closing semicolon
  // (`&not`, for instance), which leads to situations where parsing the assumed
  // named reference of `&notit;` will result in the string `¬it;`.
  // When we encounter a trailing semicolon after parsing, and the character
  // reference to decode was not a semicolon (`&semi;`), we can assume that the
  // matching was not complete.
  // @ts-expect-error: TypeScript is wrong that `textContent` on elements can
  // yield `null`.
  if (char.charCodeAt(char.length - 1) === 59 /* `;` */ && value !== 'semi') {
    return false
  }

  // If the decoded string is equal to the input, the character reference was
  // not valid.
  // @ts-expect-error: TypeScript is wrong that `textContent` on elements can
  // yield `null`.
  return char === characterReference ? false : char
}

/**
 * @typedef {import('micromark-util-types').Code} Code
 * @typedef {import('micromark-util-types').Construct} Construct
 * @typedef {import('micromark-util-types').State} State
 * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext
 * @typedef {import('micromark-util-types').Tokenizer} Tokenizer
 */

/** @type {Construct} */
const characterReference = {
  name: 'characterReference',
  tokenize: tokenizeCharacterReference
};

/**
 * @this {TokenizeContext}
 * @type {Tokenizer}
 */
function tokenizeCharacterReference(effects, ok, nok) {
  const self = this;
  let size = 0;
  /** @type {number} */
  let max;
  /** @type {(code: Code) => boolean} */
  let test;
  return start

  /**
   * Start of character reference.
   *
   * ```markdown
   * > | a&amp;b
   *      ^
   * > | a&#123;b
   *      ^
   * > | a&#x9;b
   *      ^
   * ```
   *
   * @type {State}
   */
  function start(code) {
    effects.enter('characterReference');
    effects.enter('characterReferenceMarker');
    effects.consume(code);
    effects.exit('characterReferenceMarker');
    return open
  }

  /**
   * After `&`, at `#` for numeric references or alphanumeric for named
   * references.
   *
   * ```markdown
   * > | a&amp;b
   *       ^
   * > | a&#123;b
   *       ^
   * > | a&#x9;b
   *       ^
   * ```
   *
   * @type {State}
   */
  function open(code) {
    if (code === 35) {
      effects.enter('characterReferenceMarkerNumeric');
      effects.consume(code);
      effects.exit('characterReferenceMarkerNumeric');
      return numeric
    }
    effects.enter('characterReferenceValue');
    max = 31;
    test = asciiAlphanumeric;
    return value(code)
  }

  /**
   * After `#`, at `x` for hexadecimals or digit for decimals.
   *
   * ```markdown
   * > | a&#123;b
   *        ^
   * > | a&#x9;b
   *        ^
   * ```
   *
   * @type {State}
   */
  function numeric(code) {
    if (code === 88 || code === 120) {
      effects.enter('characterReferenceMarkerHexadecimal');
      effects.consume(code);
      effects.exit('characterReferenceMarkerHexadecimal');
      effects.enter('characterReferenceValue');
      max = 6;
      test = asciiHexDigit;
      return value
    }
    effects.enter('characterReferenceValue');
    max = 7;
    test = asciiDigit;
    return value(code)
  }

  /**
   * After markers (`&#x`, `&#`, or `&`), in value, before `;`.
   *
   * The character reference kind defines what and how many characters are
   * allowed.
   *
   * ```markdown
   * > | a&amp;b
   *       ^^^
   * > | a&#123;b
   *        ^^^
   * > | a&#x9;b
   *         ^
   * ```
   *
   * @type {State}
   */
  function value(code) {
    if (code === 59 && size) {
      const token = effects.exit('characterReferenceValue');
      if (
        test === asciiAlphanumeric &&
        !decodeNamedCharacterReference(self.sliceSerialize(token))
      ) {
        return nok(code)
      }

      // To do: `markdown-rs` uses a different name:
      // `CharacterReferenceMarkerSemi`.
      effects.enter('characterReferenceMarker');
      effects.consume(code);
      effects.exit('characterReferenceMarker');
      effects.exit('characterReference');
      return ok
    }
    if (test(code) && size++ < max) {
      effects.consume(code);
      return value
    }
    return nok(code)
  }
}

/**
 * @typedef {import('micromark-util-types').Code} Code
 * @typedef {import('micromark-util-types').Construct} Construct
 * @typedef {import('micromark-util-types').State} State
 * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext
 * @typedef {import('micromark-util-types').Tokenizer} Tokenizer
 */

/** @type {Construct} */
const nonLazyContinuation = {
  tokenize: tokenizeNonLazyContinuation,
  partial: true
};

/** @type {Construct} */
const codeFenced = {
  name: 'codeFenced',
  tokenize: tokenizeCodeFenced,
  concrete: true
};

/**
 * @this {TokenizeContext}
 * @type {Tokenizer}
 */
function tokenizeCodeFenced(effects, ok, nok) {
  const self = this;
  /** @type {Construct} */
  const closeStart = {
    tokenize: tokenizeCloseStart,
    partial: true
  };
  let initialPrefix = 0;
  let sizeOpen = 0;
  /** @type {NonNullable<Code>} */
  let marker;
  return start

  /**
   * Start of code.
   *
   * ```markdown
   * > | ~~~js
   *     ^
   *   | alert(1)
   *   | ~~~
   * ```
   *
   * @type {State}
   */
  function start(code) {
    // To do: parse whitespace like `markdown-rs`.
    return beforeSequenceOpen(code)
  }

  /**
   * In opening fence, after prefix, at sequence.
   *
   * ```markdown
   * > | ~~~js
   *     ^
   *   | alert(1)
   *   | ~~~
   * ```
   *
   * @type {State}
   */
  function beforeSequenceOpen(code) {
    const tail = self.events[self.events.length - 1];
    initialPrefix =
      tail && tail[1].type === 'linePrefix'
        ? tail[2].sliceSerialize(tail[1], true).length
        : 0;
    marker = code;
    effects.enter('codeFenced');
    effects.enter('codeFencedFence');
    effects.enter('codeFencedFenceSequence');
    return sequenceOpen(code)
  }

  /**
   * In opening fence sequence.
   *
   * ```markdown
   * > | ~~~js
   *      ^
   *   | alert(1)
   *   | ~~~
   * ```
   *
   * @type {State}
   */
  function sequenceOpen(code) {
    if (code === marker) {
      sizeOpen++;
      effects.consume(code);
      return sequenceOpen
    }
    if (sizeOpen < 3) {
      return nok(code)
    }
    effects.exit('codeFencedFenceSequence');
    return markdownSpace(code)
      ? factorySpace(effects, infoBefore, 'whitespace')(code)
      : infoBefore(code)
  }

  /**
   * In opening fence, after the sequence (and optional whitespace), before info.
   *
   * ```markdown
   * > | ~~~js
   *        ^
   *   | alert(1)
   *   | ~~~
   * ```
   *
   * @type {State}
   */
  function infoBefore(code) {
    if (code === null || markdownLineEnding(code)) {
      effects.exit('codeFencedFence');
      return self.interrupt
        ? ok(code)
        : effects.check(nonLazyContinuation, atNonLazyBreak, after)(code)
    }
    effects.enter('codeFencedFenceInfo');
    effects.enter('chunkString', {
      contentType: 'string'
    });
    return info(code)
  }

  /**
   * In info.
   *
   * ```markdown
   * > | ~~~js
   *        ^
   *   | alert(1)
   *   | ~~~
   * ```
   *
   * @type {State}
   */
  function info(code) {
    if (code === null || markdownLineEnding(code)) {
      effects.exit('chunkString');
      effects.exit('codeFencedFenceInfo');
      return infoBefore(code)
    }
    if (markdownSpace(code)) {
      effects.exit('chunkString');
      effects.exit('codeFencedFenceInfo');
      return factorySpace(effects, metaBefore, 'whitespace')(code)
    }
    if (code === 96 && code === marker) {
      return nok(code)
    }
    effects.consume(code);
    return info
  }

  /**
   * In opening fence, after info and whitespace, before meta.
   *
   * ```markdown
   * > | ~~~js eval
   *           ^
   *   | alert(1)
   *   | ~~~
   * ```
   *
   * @type {State}
   */
  function metaBefore(code) {
    if (code === null || markdownLineEnding(code)) {
      return infoBefore(code)
    }
    effects.enter('codeFencedFenceMeta');
    effects.enter('chunkString', {
      contentType: 'string'
    });
    return meta(code)
  }

  /**
   * In meta.
   *
   * ```markdown
   * > | ~~~js eval
   *           ^
   *   | alert(1)
   *   | ~~~
   * ```
   *
   * @type {State}
   */
  function meta(code) {
    if (code === null || markdownLineEnding(code)) {
      effects.exit('chunkString');
      effects.exit('codeFencedFenceMeta');
      return infoBefore(code)
    }
    if (code === 96 && code === marker) {
      return nok(code)
    }
    effects.consume(code);
    return meta
  }

  /**
   * At eol/eof in code, before a non-lazy closing fence or content.
   *
   * ```markdown
   * > | ~~~js
   *          ^
   * > | alert(1)
   *             ^
   *   | ~~~
   * ```
   *
   * @type {State}
   */
  function atNonLazyBreak(code) {
    return effects.attempt(closeStart, after, contentBefore)(code)
  }

  /**
   * Before code content, not a closing fence, at eol.
   *
   * ```markdown
   *   | ~~~js
   * > | alert(1)
   *             ^
   *   | ~~~
   * ```
   *
   * @type {State}
   */
  function contentBefore(code) {
    effects.enter('lineEnding');
    effects.consume(code);
    effects.exit('lineEnding');
    return contentStart
  }

  /**
   * Before code content, not a closing fence.
   *
   * ```markdown
   *   | ~~~js
   * > | alert(1)
   *     ^
   *   | ~~~
   * ```
   *
   * @type {State}
   */
  function contentStart(code) {
    return initialPrefix > 0 && markdownSpace(code)
      ? factorySpace(
          effects,
          beforeContentChunk,
          'linePrefix',
          initialPrefix + 1
        )(code)
      : beforeContentChunk(code)
  }

  /**
   * Before code content, after optional prefix.
   *
   * ```markdown
   *   | ~~~js
   * > | alert(1)
   *     ^
   *   | ~~~
   * ```
   *
   * @type {State}
   */
  function beforeContentChunk(code) {
    if (code === null || markdownLineEnding(code)) {
      return effects.check(nonLazyContinuation, atNonLazyBreak, after)(code)
    }
    effects.enter('codeFlowValue');
    return contentChunk(code)
  }

  /**
   * In code content.
   *
   * ```markdown
   *   | ~~~js
   * > | alert(1)
   *     ^^^^^^^^
   *   | ~~~
   * ```
   *
   * @type {State}
   */
  function contentChunk(code) {
    if (code === null || markdownLineEnding(code)) {
      effects.exit('codeFlowValue');
      return beforeContentChunk(code)
    }
    effects.consume(code);
    return contentChunk
  }

  /**
   * After code.
   *
   * ```markdown
   *   | ~~~js
   *   | alert(1)
   * > | ~~~
   *        ^
   * ```
   *
   * @type {State}
   */
  function after(code) {
    effects.exit('codeFenced');
    return ok(code)
  }

  /**
   * @this {TokenizeContext}
   * @type {Tokenizer}
   */
  function tokenizeCloseStart(effects, ok, nok) {
    let size = 0;
    return startBefore

    /**
     *
     *
     * @type {State}
     */
    function startBefore(code) {
      effects.enter('lineEnding');
      effects.consume(code);
      effects.exit('lineEnding');
      return start
    }

    /**
     * Before closing fence, at optional whitespace.
     *
     * ```markdown
     *   | ~~~js
     *   | alert(1)
     * > | ~~~
     *     ^
     * ```
     *
     * @type {State}
     */
    function start(code) {
      // Always populated by defaults.

      // To do: `enter` here or in next state?
      effects.enter('codeFencedFence');
      return markdownSpace(code)
        ? factorySpace(
            effects,
            beforeSequenceClose,
            'linePrefix',
            self.parser.constructs.disable.null.includes('codeIndented')
              ? undefined
              : 4
          )(code)
        : beforeSequenceClose(code)
    }

    /**
     * In closing fence, after optional whitespace, at sequence.
     *
     * ```markdown
     *   | ~~~js
     *   | alert(1)
     * > | ~~~
     *     ^
     * ```
     *
     * @type {State}
     */
    function beforeSequenceClose(code) {
      if (code === marker) {
        effects.enter('codeFencedFenceSequence');
        return sequenceClose(code)
      }
      return nok(code)
    }

    /**
     * In closing fence sequence.
     *
     * ```markdown
     *   | ~~~js
     *   | alert(1)
     * > | ~~~
     *     ^
     * ```
     *
     * @type {State}
     */
    function sequenceClose(code) {
      if (code === marker) {
        size++;
        effects.consume(code);
        return sequenceClose
      }
      if (size >= sizeOpen) {
        effects.exit('codeFencedFenceSequence');
        return markdownSpace(code)
          ? factorySpace(effects, sequenceCloseAfter, 'whitespace')(code)
          : sequenceCloseAfter(code)
      }
      return nok(code)
    }

    /**
     * After closing fence sequence, after optional whitespace.
     *
     * ```markdown
     *   | ~~~js
     *   | alert(1)
     * > | ~~~
     *        ^
     * ```
     *
     * @type {State}
     */
    function sequenceCloseAfter(code) {
      if (code === null || markdownLineEnding(code)) {
        effects.exit('codeFencedFence');
        return ok(code)
      }
      return nok(code)
    }
  }
}

/**
 * @this {TokenizeContext}
 * @type {Tokenizer}
 */
function tokenizeNonLazyContinuation(effects, ok, nok) {
  const self = this;
  return start

  /**
   *
   *
   * @type {State}
   */
  function start(code) {
    if (code === null) {
      return nok(code)
    }
    effects.enter('lineEnding');
    effects.consume(code);
    effects.exit('lineEnding');
    return lineStart
  }

  /**
   *
   *
   * @type {State}
   */
  function lineStart(code) {
    return self.parser.lazy[self.now().line] ? nok(code) : ok(code)
  }
}

/**
 * @typedef {import('micromark-util-types').Construct} Construct
 * @typedef {import('micromark-util-types').State} State
 * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext
 * @typedef {import('micromark-util-types').Tokenizer} Tokenizer
 */

/** @type {Construct} */
const codeIndented = {
  name: 'codeIndented',
  tokenize: tokenizeCodeIndented
};

/** @type {Construct} */
const furtherStart = {
  tokenize: tokenizeFurtherStart,
  partial: true
};

/**
 * @this {TokenizeContext}
 * @type {Tokenizer}
 */
function tokenizeCodeIndented(effects, ok, nok) {
  const self = this;
  return start

  /**
   * Start of code (indented).
   *
   * > **Parsing note**: it is not needed to check if this first line is a
   * > filled line (that it has a non-whitespace character), because blank lines
   * > are parsed already, so we never run into that.
   *
   * ```markdown
   * > |     aaa
   *     ^
   * ```
   *
   * @type {State}
   */
  function start(code) {
    // To do: manually check if interrupting like `markdown-rs`.

    effects.enter('codeIndented');
    // To do: use an improved `space_or_tab` function like `markdown-rs`,
    // so that we can drop the next state.
    return factorySpace(effects, afterPrefix, 'linePrefix', 4 + 1)(code)
  }

  /**
   * At start, after 1 or 4 spaces.
   *
   * ```markdown
   * > |     aaa
   *         ^
   * ```
   *
   * @type {State}
   */
  function afterPrefix(code) {
    const tail = self.events[self.events.length - 1];
    return tail &&
      tail[1].type === 'linePrefix' &&
      tail[2].sliceSerialize(tail[1], true).length >= 4
      ? atBreak(code)
      : nok(code)
  }

  /**
   * At a break.
   *
   * ```markdown
   * > |     aaa
   *         ^  ^
   * ```
   *
   * @type {State}
   */
  function atBreak(code) {
    if (code === null) {
      return after(code)
    }
    if (markdownLineEnding(code)) {
      return effects.attempt(furtherStart, atBreak, after)(code)
    }
    effects.enter('codeFlowValue');
    return inside(code)
  }

  /**
   * In code content.
   *
   * ```markdown
   * > |     aaa
   *         ^^^^
   * ```
   *
   * @type {State}
   */
  function inside(code) {
    if (code === null || markdownLineEnding(code)) {
      effects.exit('codeFlowValue');
      return atBreak(code)
    }
    effects.consume(code);
    return inside
  }

  /** @type {State} */
  function after(code) {
    effects.exit('codeIndented');
    // To do: allow interrupting like `markdown-rs`.
    // Feel free to interrupt.
    // tokenizer.interrupt = false
    return ok(code)
  }
}

/**
 * @this {TokenizeContext}
 * @type {Tokenizer}
 */
function tokenizeFurtherStart(effects, ok, nok) {
  const self = this;
  return furtherStart

  /**
   * At eol, trying to parse another indent.
   *
   * ```markdown
   * > |     aaa
   *            ^
   *   |     bbb
   * ```
   *
   * @type {State}
   */
  function furtherStart(code) {
    // To do: improve `lazy` / `pierce` handling.
    // If this is a lazy line, it can’t be code.
    if (self.parser.lazy[self.now().line]) {
      return nok(code)
    }
    if (markdownLineEnding(code)) {
      effects.enter('lineEnding');
      effects.consume(code);
      effects.exit('lineEnding');
      return furtherStart
    }

    // To do: the code here in `micromark-js` is a bit different from
    // `markdown-rs` because there it can attempt spaces.
    // We can’t yet.
    //
    // To do: use an improved `space_or_tab` function like `markdown-rs`,
    // so that we can drop the next state.
    return factorySpace(effects, afterPrefix, 'linePrefix', 4 + 1)(code)
  }

  /**
   * At start, after 1 or 4 spaces.
   *
   * ```markdown
   * > |     aaa
   *         ^
   * ```
   *
   * @type {State}
   */
  function afterPrefix(code) {
    const tail = self.events[self.events.length - 1];
    return tail &&
      tail[1].type === 'linePrefix' &&
      tail[2].sliceSerialize(tail[1], true).length >= 4
      ? ok(code)
      : markdownLineEnding(code)
      ? furtherStart(code)
      : nok(code)
  }
}

/**
 * @typedef {import('micromark-util-types').Construct} Construct
 * @typedef {import('micromark-util-types').Previous} Previous
 * @typedef {import('micromark-util-types').Resolver} Resolver
 * @typedef {import('micromark-util-types').State} State
 * @typedef {import('micromark-util-types').Token} Token
 * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext
 * @typedef {import('micromark-util-types').Tokenizer} Tokenizer
 */

/** @type {Construct} */
const codeText = {
  name: 'codeText',
  tokenize: tokenizeCodeText,
  resolve: resolveCodeText,
  previous: previous$1
};

// To do: next major: don’t resolve, like `markdown-rs`.
/** @type {Resolver} */
function resolveCodeText(events) {
  let tailExitIndex = events.length - 4;
  let headEnterIndex = 3;
  /** @type {number} */
  let index;
  /** @type {number | undefined} */
  let enter;

  // If we start and end with an EOL or a space.
  if (
    (events[headEnterIndex][1].type === 'lineEnding' ||
      events[headEnterIndex][1].type === 'space') &&
    (events[tailExitIndex][1].type === 'lineEnding' ||
      events[tailExitIndex][1].type === 'space')
  ) {
    index = headEnterIndex;

    // And we have data.
    while (++index < tailExitIndex) {
      if (events[index][1].type === 'codeTextData') {
        // Then we have padding.
        events[headEnterIndex][1].type = 'codeTextPadding';
        events[tailExitIndex][1].type = 'codeTextPadding';
        headEnterIndex += 2;
        tailExitIndex -= 2;
        break
      }
    }
  }

  // Merge adjacent spaces and data.
  index = headEnterIndex - 1;
  tailExitIndex++;
  while (++index <= tailExitIndex) {
    if (enter === undefined) {
      if (index !== tailExitIndex && events[index][1].type !== 'lineEnding') {
        enter = index;
      }
    } else if (
      index === tailExitIndex ||
      events[index][1].type === 'lineEnding'
    ) {
      events[enter][1].type = 'codeTextData';
      if (index !== enter + 2) {
        events[enter][1].end = events[index - 1][1].end;
        events.splice(enter + 2, index - enter - 2);
        tailExitIndex -= index - enter - 2;
        index = enter + 2;
      }
      enter = undefined;
    }
  }
  return events
}

/**
 * @this {TokenizeContext}
 * @type {Previous}
 */
function previous$1(code) {
  // If there is a previous code, there will always be a tail.
  return (
    code !== 96 ||
    this.events[this.events.length - 1][1].type === 'characterEscape'
  )
}

/**
 * @this {TokenizeContext}
 * @type {Tokenizer}
 */
function tokenizeCodeText(effects, ok, nok) {
  let sizeOpen = 0;
  /** @type {number} */
  let size;
  /** @type {Token} */
  let token;
  return start

  /**
   * Start of code (text).
   *
   * ```markdown
   * > | `a`
   *     ^
   * > | \`a`
   *      ^
   * ```
   *
   * @type {State}
   */
  function start(code) {
    effects.enter('codeText');
    effects.enter('codeTextSequence');
    return sequenceOpen(code)
  }

  /**
   * In opening sequence.
   *
   * ```markdown
   * > | `a`
   *     ^
   * ```
   *
   * @type {State}
   */
  function sequenceOpen(code) {
    if (code === 96) {
      effects.consume(code);
      sizeOpen++;
      return sequenceOpen
    }
    effects.exit('codeTextSequence');
    return between(code)
  }

  /**
   * Between something and something else.
   *
   * ```markdown
   * > | `a`
   *      ^^
   * ```
   *
   * @type {State}
   */
  function between(code) {
    // EOF.
    if (code === null) {
      return nok(code)
    }

    // To do: next major: don’t do spaces in resolve, but when compiling,
    // like `markdown-rs`.
    // Tabs don’t work, and virtual spaces don’t make sense.
    if (code === 32) {
      effects.enter('space');
      effects.consume(code);
      effects.exit('space');
      return between
    }

    // Closing fence? Could also be data.
    if (code === 96) {
      token = effects.enter('codeTextSequence');
      size = 0;
      return sequenceClose(code)
    }
    if (markdownLineEnding(code)) {
      effects.enter('lineEnding');
      effects.consume(code);
      effects.exit('lineEnding');
      return between
    }

    // Data.
    effects.enter('codeTextData');
    return data(code)
  }

  /**
   * In data.
   *
   * ```markdown
   * > | `a`
   *      ^
   * ```
   *
   * @type {State}
   */
  function data(code) {
    if (
      code === null ||
      code === 32 ||
      code === 96 ||
      markdownLineEnding(code)
    ) {
      effects.exit('codeTextData');
      return between(code)
    }
    effects.consume(code);
    return data
  }

  /**
   * In closing sequence.
   *
   * ```markdown
   * > | `a`
   *       ^
   * ```
   *
   * @type {State}
   */
  function sequenceClose(code) {
    // More.
    if (code === 96) {
      effects.consume(code);
      size++;
      return sequenceClose
    }

    // Done!
    if (size === sizeOpen) {
      effects.exit('codeTextSequence');
      effects.exit('codeText');
      return ok(code)
    }

    // More or less accents: mark as data.
    token.type = 'codeTextData';
    return data(code)
  }
}

/**
 * @typedef {import('micromark-util-types').Chunk} Chunk
 * @typedef {import('micromark-util-types').Event} Event
 * @typedef {import('micromark-util-types').Token} Token
 */

/**
 * Tokenize subcontent.
 *
 * @param {Array<Event>} events
 *   List of events.
 * @returns {boolean}
 *   Whether subtokens were found.
 */
function subtokenize(events) {
  /** @type {Record<string, number>} */
  const jumps = {};
  let index = -1;
  /** @type {Event} */
  let event;
  /** @type {number | undefined} */
  let lineIndex;
  /** @type {number} */
  let otherIndex;
  /** @type {Event} */
  let otherEvent;
  /** @type {Array<Event>} */
  let parameters;
  /** @type {Array<Event>} */
  let subevents;
  /** @type {boolean | undefined} */
  let more;
  while (++index < events.length) {
    while (index in jumps) {
      index = jumps[index];
    }
    event = events[index];

    // Add a hook for the GFM tasklist extension, which needs to know if text
    // is in the first content of a list item.
    if (
      index &&
      event[1].type === 'chunkFlow' &&
      events[index - 1][1].type === 'listItemPrefix'
    ) {
      subevents = event[1]._tokenizer.events;
      otherIndex = 0;
      if (
        otherIndex < subevents.length &&
        subevents[otherIndex][1].type === 'lineEndingBlank'
      ) {
        otherIndex += 2;
      }
      if (
        otherIndex < subevents.length &&
        subevents[otherIndex][1].type === 'content'
      ) {
        while (++otherIndex < subevents.length) {
          if (subevents[otherIndex][1].type === 'content') {
            break
          }
          if (subevents[otherIndex][1].type === 'chunkText') {
            subevents[otherIndex][1]._isInFirstContentOfListItem = true;
            otherIndex++;
          }
        }
      }
    }

    // Enter.
    if (event[0] === 'enter') {
      if (event[1].contentType) {
        Object.assign(jumps, subcontent(events, index));
        index = jumps[index];
        more = true;
      }
    }
    // Exit.
    else if (event[1]._container) {
      otherIndex = index;
      lineIndex = undefined;
      while (otherIndex--) {
        otherEvent = events[otherIndex];
        if (
          otherEvent[1].type === 'lineEnding' ||
          otherEvent[1].type === 'lineEndingBlank'
        ) {
          if (otherEvent[0] === 'enter') {
            if (lineIndex) {
              events[lineIndex][1].type = 'lineEndingBlank';
            }
            otherEvent[1].type = 'lineEnding';
            lineIndex = otherIndex;
          }
        } else {
          break
        }
      }
      if (lineIndex) {
        // Fix position.
        event[1].end = Object.assign({}, events[lineIndex][1].start);

        // Switch container exit w/ line endings.
        parameters = events.slice(lineIndex, index);
        parameters.unshift(event);
        splice(events, lineIndex, index - lineIndex + 1, parameters);
      }
    }
  }
  return !more
}

/**
 * Tokenize embedded tokens.
 *
 * @param {Array<Event>} events
 * @param {number} eventIndex
 * @returns {Record<string, number>}
 */
function subcontent(events, eventIndex) {
  const token = events[eventIndex][1];
  const context = events[eventIndex][2];
  let startPosition = eventIndex - 1;
  /** @type {Array<number>} */
  const startPositions = [];
  const tokenizer =
    token._tokenizer || context.parser[token.contentType](token.start);
  const childEvents = tokenizer.events;
  /** @type {Array<[number, number]>} */
  const jumps = [];
  /** @type {Record<string, number>} */
  const gaps = {};
  /** @type {Array<Chunk>} */
  let stream;
  /** @type {Token | undefined} */
  let previous;
  let index = -1;
  /** @type {Token | undefined} */
  let current = token;
  let adjust = 0;
  let start = 0;
  const breaks = [start];

  // Loop forward through the linked tokens to pass them in order to the
  // subtokenizer.
  while (current) {
    // Find the position of the event for this token.
    while (events[++startPosition][1] !== current) {
      // Empty.
    }
    startPositions.push(startPosition);
    if (!current._tokenizer) {
      stream = context.sliceStream(current);
      if (!current.next) {
        stream.push(null);
      }
      if (previous) {
        tokenizer.defineSkip(current.start);
      }
      if (current._isInFirstContentOfListItem) {
        tokenizer._gfmTasklistFirstContentOfListItem = true;
      }
      tokenizer.write(stream);
      if (current._isInFirstContentOfListItem) {
        tokenizer._gfmTasklistFirstContentOfListItem = undefined;
      }
    }

    // Unravel the next token.
    previous = current;
    current = current.next;
  }

  // Now, loop back through all events (and linked tokens), to figure out which
  // parts belong where.
  current = token;
  while (++index < childEvents.length) {
    if (
      // Find a void token that includes a break.
      childEvents[index][0] === 'exit' &&
      childEvents[index - 1][0] === 'enter' &&
      childEvents[index][1].type === childEvents[index - 1][1].type &&
      childEvents[index][1].start.line !== childEvents[index][1].end.line
    ) {
      start = index + 1;
      breaks.push(start);
      // Help GC.
      current._tokenizer = undefined;
      current.previous = undefined;
      current = current.next;
    }
  }

  // Help GC.
  tokenizer.events = [];

  // If there’s one more token (which is the cases for lines that end in an
  // EOF), that’s perfect: the last point we found starts it.
  // If there isn’t then make sure any remaining content is added to it.
  if (current) {
    // Help GC.
    current._tokenizer = undefined;
    current.previous = undefined;
  } else {
    breaks.pop();
  }

  // Now splice the events from the subtokenizer into the current events,
  // moving back to front so that splice indices aren’t affected.
  index = breaks.length;
  while (index--) {
    const slice = childEvents.slice(breaks[index], breaks[index + 1]);
    const start = startPositions.pop();
    jumps.unshift([start, start + slice.length - 1]);
    splice(events, start, 2, slice);
  }
  index = -1;
  while (++index < jumps.length) {
    gaps[adjust + jumps[index][0]] = adjust + jumps[index][1];
    adjust += jumps[index][1] - jumps[index][0] - 1;
  }
  return gaps
}

/**
 * @typedef {import('micromark-util-types').Construct} Construct
 * @typedef {import('micromark-util-types').Resolver} Resolver
 * @typedef {import('micromark-util-types').State} State
 * @typedef {import('micromark-util-types').Token} Token
 * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext
 * @typedef {import('micromark-util-types').Tokenizer} Tokenizer
 */

/**
 * No name because it must not be turned off.
 * @type {Construct}
 */
const content = {
  tokenize: tokenizeContent,
  resolve: resolveContent
};

/** @type {Construct} */
const continuationConstruct = {
  tokenize: tokenizeContinuation,
  partial: true
};

/**
 * Content is transparent: it’s parsed right now. That way, definitions are also
 * parsed right now: before text in paragraphs (specifically, media) are parsed.
 *
 * @type {Resolver}
 */
function resolveContent(events) {
  subtokenize(events);
  return events
}

/**
 * @this {TokenizeContext}
 * @type {Tokenizer}
 */
function tokenizeContent(effects, ok) {
  /** @type {Token | undefined} */
  let previous;
  return chunkStart

  /**
   * Before a content chunk.
   *
   * ```markdown
   * > | abc
   *     ^
   * ```
   *
   * @type {State}
   */
  function chunkStart(code) {
    effects.enter('content');
    previous = effects.enter('chunkContent', {
      contentType: 'content'
    });
    return chunkInside(code)
  }

  /**
   * In a content chunk.
   *
   * ```markdown
   * > | abc
   *     ^^^
   * ```
   *
   * @type {State}
   */
  function chunkInside(code) {
    if (code === null) {
      return contentEnd(code)
    }

    // To do: in `markdown-rs`, each line is parsed on its own, and everything
    // is stitched together resolving.
    if (markdownLineEnding(code)) {
      return effects.check(
        continuationConstruct,
        contentContinue,
        contentEnd
      )(code)
    }

    // Data.
    effects.consume(code);
    return chunkInside
  }

  /**
   *
   *
   * @type {State}
   */
  function contentEnd(code) {
    effects.exit('chunkContent');
    effects.exit('content');
    return ok(code)
  }

  /**
   *
   *
   * @type {State}
   */
  function contentContinue(code) {
    effects.consume(code);
    effects.exit('chunkContent');
    previous.next = effects.enter('chunkContent', {
      contentType: 'content',
      previous
    });
    previous = previous.next;
    return chunkInside
  }
}

/**
 * @this {TokenizeContext}
 * @type {Tokenizer}
 */
function tokenizeContinuation(effects, ok, nok) {
  const self = this;
  return startLookahead

  /**
   *
   *
   * @type {State}
   */
  function startLookahead(code) {
    effects.exit('chunkContent');
    effects.enter('lineEnding');
    effects.consume(code);
    effects.exit('lineEnding');
    return factorySpace(effects, prefixed, 'linePrefix')
  }

  /**
   *
   *
   * @type {State}
   */
  function prefixed(code) {
    if (code === null || markdownLineEnding(code)) {
      return nok(code)
    }

    // Always populated by defaults.

    const tail = self.events[self.events.length - 1];
    if (
      !self.parser.constructs.disable.null.includes('codeIndented') &&
      tail &&
      tail[1].type === 'linePrefix' &&
      tail[2].sliceSerialize(tail[1], true).length >= 4
    ) {
      return ok(code)
    }
    return effects.interrupt(self.parser.constructs.flow, nok, ok)(code)
  }
}

/**
 * @typedef {import('micromark-util-types').Effects} Effects
 * @typedef {import('micromark-util-types').State} State
 * @typedef {import('micromark-util-types').TokenType} TokenType
 */

/**
 * Parse destinations.
 *
 * ###### Examples
 *
 * ```markdown
 * <a>
 * <a\>b>
 * <a b>
 * <a)>
 * a
 * a\)b
 * a(b)c
 * a(b)
 * ```
 *
 * @param {Effects} effects
 *   Context.
 * @param {State} ok
 *   State switched to when successful.
 * @param {State} nok
 *   State switched to when unsuccessful.
 * @param {TokenType} type
 *   Type for whole (`<a>` or `b`).
 * @param {TokenType} literalType
 *   Type when enclosed (`<a>`).
 * @param {TokenType} literalMarkerType
 *   Type for enclosing (`<` and `>`).
 * @param {TokenType} rawType
 *   Type when not enclosed (`b`).
 * @param {TokenType} stringType
 *   Type for the value (`a` or `b`).
 * @param {number | undefined} [max=Infinity]
 *   Depth of nested parens (inclusive).
 * @returns {State}
 *   Start state.
 */ // eslint-disable-next-line max-params
function factoryDestination(
  effects,
  ok,
  nok,
  type,
  literalType,
  literalMarkerType,
  rawType,
  stringType,
  max
) {
  const limit = max || Number.POSITIVE_INFINITY;
  let balance = 0;
  return start

  /**
   * Start of destination.
   *
   * ```markdown
   * > | <aa>
   *     ^
   * > | aa
   *     ^
   * ```
   *
   * @type {State}
   */
  function start(code) {
    if (code === 60) {
      effects.enter(type);
      effects.enter(literalType);
      effects.enter(literalMarkerType);
      effects.consume(code);
      effects.exit(literalMarkerType);
      return enclosedBefore
    }

    // ASCII control, space, closing paren.
    if (code === null || code === 32 || code === 41 || asciiControl(code)) {
      return nok(code)
    }
    effects.enter(type);
    effects.enter(rawType);
    effects.enter(stringType);
    effects.enter('chunkString', {
      contentType: 'string'
    });
    return raw(code)
  }

  /**
   * After `<`, at an enclosed destination.
   *
   * ```markdown
   * > | <aa>
   *      ^
   * ```
   *
   * @type {State}
   */
  function enclosedBefore(code) {
    if (code === 62) {
      effects.enter(literalMarkerType);
      effects.consume(code);
      effects.exit(literalMarkerType);
      effects.exit(literalType);
      effects.exit(type);
      return ok
    }
    effects.enter(stringType);
    effects.enter('chunkString', {
      contentType: 'string'
    });
    return enclosed(code)
  }

  /**
   * In enclosed destination.
   *
   * ```markdown
   * > | <aa>
   *      ^
   * ```
   *
   * @type {State}
   */
  function enclosed(code) {
    if (code === 62) {
      effects.exit('chunkString');
      effects.exit(stringType);
      return enclosedBefore(code)
    }
    if (code === null || code === 60 || markdownLineEnding(code)) {
      return nok(code)
    }
    effects.consume(code);
    return code === 92 ? enclosedEscape : enclosed
  }

  /**
   * After `\`, at a special character.
   *
   * ```markdown
   * > | <a\*a>
   *        ^
   * ```
   *
   * @type {State}
   */
  function enclosedEscape(code) {
    if (code === 60 || code === 62 || code === 92) {
      effects.consume(code);
      return enclosed
    }
    return enclosed(code)
  }

  /**
   * In raw destination.
   *
   * ```markdown
   * > | aa
   *     ^
   * ```
   *
   * @type {State}
   */
  function raw(code) {
    if (
      !balance &&
      (code === null || code === 41 || markdownLineEndingOrSpace(code))
    ) {
      effects.exit('chunkString');
      effects.exit(stringType);
      effects.exit(rawType);
      effects.exit(type);
      return ok(code)
    }
    if (balance < limit && code === 40) {
      effects.consume(code);
      balance++;
      return raw
    }
    if (code === 41) {
      effects.consume(code);
      balance--;
      return raw
    }

    // ASCII control (but *not* `\0`) and space and `(`.
    // Note: in `markdown-rs`, `\0` exists in codes, in `micromark-js` it
    // doesn’t.
    if (code === null || code === 32 || code === 40 || asciiControl(code)) {
      return nok(code)
    }
    effects.consume(code);
    return code === 92 ? rawEscape : raw
  }

  /**
   * After `\`, at special character.
   *
   * ```markdown
   * > | a\*a
   *       ^
   * ```
   *
   * @type {State}
   */
  function rawEscape(code) {
    if (code === 40 || code === 41 || code === 92) {
      effects.consume(code);
      return raw
    }
    return raw(code)
  }
}

/**
 * @typedef {import('micromark-util-types').Effects} Effects
 * @typedef {import('micromark-util-types').State} State
 * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext
 * @typedef {import('micromark-util-types').TokenType} TokenType
 */

/**
 * Parse labels.
 *
 * > 👉 **Note**: labels in markdown are capped at 999 characters in the string.
 *
 * ###### Examples
 *
 * ```markdown
 * [a]
 * [a
 * b]
 * [a\]b]
 * ```
 *
 * @this {TokenizeContext}
 *   Tokenize context.
 * @param {Effects} effects
 *   Context.
 * @param {State} ok
 *   State switched to when successful.
 * @param {State} nok
 *   State switched to when unsuccessful.
 * @param {TokenType} type
 *   Type of the whole label (`[a]`).
 * @param {TokenType} markerType
 *   Type for the markers (`[` and `]`).
 * @param {TokenType} stringType
 *   Type for the identifier (`a`).
 * @returns {State}
 *   Start state.
 */ // eslint-disable-next-line max-params
function factoryLabel(effects, ok, nok, type, markerType, stringType) {
  const self = this;
  let size = 0;
  /** @type {boolean} */
  let seen;
  return start

  /**
   * Start of label.
   *
   * ```markdown
   * > | [a]
   *     ^
   * ```
   *
   * @type {State}
   */
  function start(code) {
    effects.enter(type);
    effects.enter(markerType);
    effects.consume(code);
    effects.exit(markerType);
    effects.enter(stringType);
    return atBreak
  }

  /**
   * In label, at something, before something else.
   *
   * ```markdown
   * > | [a]
   *      ^
   * ```
   *
   * @type {State}
   */
  function atBreak(code) {
    if (
      size > 999 ||
      code === null ||
      code === 91 ||
      (code === 93 && !seen) ||
      // To do: remove in the future once we’ve switched from
      // `micromark-extension-footnote` to `micromark-extension-gfm-footnote`,
      // which doesn’t need this.
      // Hidden footnotes hook.
      /* c8 ignore next 3 */
      (code === 94 &&
        !size &&
        '_hiddenFootnoteSupport' in self.parser.constructs)
    ) {
      return nok(code)
    }
    if (code === 93) {
      effects.exit(stringType);
      effects.enter(markerType);
      effects.consume(code);
      effects.exit(markerType);
      effects.exit(type);
      return ok
    }

    // To do: indent? Link chunks and EOLs together?
    if (markdownLineEnding(code)) {
      effects.enter('lineEnding');
      effects.consume(code);
      effects.exit('lineEnding');
      return atBreak
    }
    effects.enter('chunkString', {
      contentType: 'string'
    });
    return labelInside(code)
  }

  /**
   * In label, in text.
   *
   * ```markdown
   * > | [a]
   *      ^
   * ```
   *
   * @type {State}
   */
  function labelInside(code) {
    if (
      code === null ||
      code === 91 ||
      code === 93 ||
      markdownLineEnding(code) ||
      size++ > 999
    ) {
      effects.exit('chunkString');
      return atBreak(code)
    }
    effects.consume(code);
    if (!seen) seen = !markdownSpace(code);
    return code === 92 ? labelEscape : labelInside
  }

  /**
   * After `\`, at a special character.
   *
   * ```markdown
   * > | [a\*a]
   *        ^
   * ```
   *
   * @type {State}
   */
  function labelEscape(code) {
    if (code === 91 || code === 92 || code === 93) {
      effects.consume(code);
      size++;
      return labelInside
    }
    return labelInside(code)
  }
}

/**
 * @typedef {import('micromark-util-types').Code} Code
 * @typedef {import('micromark-util-types').Effects} Effects
 * @typedef {import('micromark-util-types').State} State
 * @typedef {import('micromark-util-types').TokenType} TokenType
 */

/**
 * Parse titles.
 *
 * ###### Examples
 *
 * ```markdown
 * "a"
 * 'b'
 * (c)
 * "a
 * b"
 * 'a
 *     b'
 * (a\)b)
 * ```
 *
 * @param {Effects} effects
 *   Context.
 * @param {State} ok
 *   State switched to when successful.
 * @param {State} nok
 *   State switched to when unsuccessful.
 * @param {TokenType} type
 *   Type of the whole title (`"a"`, `'b'`, `(c)`).
 * @param {TokenType} markerType
 *   Type for the markers (`"`, `'`, `(`, and `)`).
 * @param {TokenType} stringType
 *   Type for the value (`a`).
 * @returns {State}
 *   Start state.
 */ // eslint-disable-next-line max-params
function factoryTitle(effects, ok, nok, type, markerType, stringType) {
  /** @type {NonNullable<Code>} */
  let marker;
  return start

  /**
   * Start of title.
   *
   * ```markdown
   * > | "a"
   *     ^
   * ```
   *
   * @type {State}
   */
  function start(code) {
    if (code === 34 || code === 39 || code === 40) {
      effects.enter(type);
      effects.enter(markerType);
      effects.consume(code);
      effects.exit(markerType);
      marker = code === 40 ? 41 : code;
      return begin
    }
    return nok(code)
  }

  /**
   * After opening marker.
   *
   * This is also used at the closing marker.
   *
   * ```markdown
   * > | "a"
   *      ^
   * ```
   *
   * @type {State}
   */
  function begin(code) {
    if (code === marker) {
      effects.enter(markerType);
      effects.consume(code);
      effects.exit(markerType);
      effects.exit(type);
      return ok
    }
    effects.enter(stringType);
    return atBreak(code)
  }

  /**
   * At something, before something else.
   *
   * ```markdown
   * > | "a"
   *      ^
   * ```
   *
   * @type {State}
   */
  function atBreak(code) {
    if (code === marker) {
      effects.exit(stringType);
      return begin(marker)
    }
    if (code === null) {
      return nok(code)
    }

    // Note: blank lines can’t exist in content.
    if (markdownLineEnding(code)) {
      // To do: use `space_or_tab_eol_with_options`, connect.
      effects.enter('lineEnding');
      effects.consume(code);
      effects.exit('lineEnding');
      return factorySpace(effects, atBreak, 'linePrefix')
    }
    effects.enter('chunkString', {
      contentType: 'string'
    });
    return inside(code)
  }

  /**
   *
   *
   * @type {State}
   */
  function inside(code) {
    if (code === marker || code === null || markdownLineEnding(code)) {
      effects.exit('chunkString');
      return atBreak(code)
    }
    effects.consume(code);
    return code === 92 ? escape : inside
  }

  /**
   * After `\`, at a special character.
   *
   * ```markdown
   * > | "a\*b"
   *      ^
   * ```
   *
   * @type {State}
   */
  function escape(code) {
    if (code === marker || code === 92) {
      effects.consume(code);
      return inside
    }
    return inside(code)
  }
}

/**
 * @typedef {import('micromark-util-types').Effects} Effects
 * @typedef {import('micromark-util-types').State} State
 */

/**
 * Parse spaces and tabs.
 *
 * There is no `nok` parameter:
 *
 * *   line endings or spaces in markdown are often optional, in which case this
 *     factory can be used and `ok` will be switched to whether spaces were found
 *     or not
 * *   one line ending or space can be detected with
 *     `markdownLineEndingOrSpace(code)` right before using `factoryWhitespace`
 *
 * @param {Effects} effects
 *   Context.
 * @param {State} ok
 *   State switched to when successful.
 * @returns
 *   Start state.
 */
function factoryWhitespace(effects, ok) {
  /** @type {boolean} */
  let seen;
  return start

  /** @type {State} */
  function start(code) {
    if (markdownLineEnding(code)) {
      effects.enter('lineEnding');
      effects.consume(code);
      effects.exit('lineEnding');
      seen = true;
      return start
    }
    if (markdownSpace(code)) {
      return factorySpace(
        effects,
        start,
        seen ? 'linePrefix' : 'lineSuffix'
      )(code)
    }
    return ok(code)
  }
}

/**
 * Normalize an identifier (as found in references, definitions).
 *
 * Collapses markdown whitespace, trim, and then lower- and uppercase.
 *
 * Some characters are considered “uppercase”, such as U+03F4 (`ϴ`), but if their
 * lowercase counterpart (U+03B8 (`θ`)) is uppercased will result in a different
 * uppercase character (U+0398 (`Θ`)).
 * So, to get a canonical form, we perform both lower- and uppercase.
 *
 * Using uppercase last makes sure keys will never interact with default
 * prototypal values (such as `constructor`): nothing in the prototype of
 * `Object` is uppercase.
 *
 * @param {string} value
 *   Identifier to normalize.
 * @returns {string}
 *   Normalized identifier.
 */
function normalizeIdentifier(value) {
  return (
    value
      // Collapse markdown whitespace.
      .replace(/[\t\n\r ]+/g, ' ')
      // Trim.
      .replace(/^ | $/g, '')
      // Some characters are considered “uppercase”, but if their lowercase
      // counterpart is uppercased will result in a different uppercase
      // character.
      // Hence, to get that form, we perform both lower- and uppercase.
      // Upper case makes sure keys will not interact with default prototypal
      // methods: no method is uppercase.
      .toLowerCase()
      .toUpperCase()
  )
}

/**
 * @typedef {import('micromark-util-types').Construct} Construct
 * @typedef {import('micromark-util-types').State} State
 * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext
 * @typedef {import('micromark-util-types').Tokenizer} Tokenizer
 */

/** @type {Construct} */
const definition = {
  name: 'definition',
  tokenize: tokenizeDefinition
};

/** @type {Construct} */
const titleBefore = {
  tokenize: tokenizeTitleBefore,
  partial: true
};

/**
 * @this {TokenizeContext}
 * @type {Tokenizer}
 */
function tokenizeDefinition(effects, ok, nok) {
  const self = this;
  /** @type {string} */
  let identifier;
  return start

  /**
   * At start of a definition.
   *
   * ```markdown
   * > | [a]: b "c"
   *     ^
   * ```
   *
   * @type {State}
   */
  function start(code) {
    // Do not interrupt paragraphs (but do follow definitions).
    // To do: do `interrupt` the way `markdown-rs` does.
    // To do: parse whitespace the way `markdown-rs` does.
    effects.enter('definition');
    return before(code)
  }

  /**
   * After optional whitespace, at `[`.
   *
   * ```markdown
   * > | [a]: b "c"
   *     ^
   * ```
   *
   * @type {State}
   */
  function before(code) {
    // To do: parse whitespace the way `markdown-rs` does.

    return factoryLabel.call(
      self,
      effects,
      labelAfter,
      // Note: we don’t need to reset the way `markdown-rs` does.
      nok,
      'definitionLabel',
      'definitionLabelMarker',
      'definitionLabelString'
    )(code)
  }

  /**
   * After label.
   *
   * ```markdown
   * > | [a]: b "c"
   *        ^
   * ```
   *
   * @type {State}
   */
  function labelAfter(code) {
    identifier = normalizeIdentifier(
      self.sliceSerialize(self.events[self.events.length - 1][1]).slice(1, -1)
    );
    if (code === 58) {
      effects.enter('definitionMarker');
      effects.consume(code);
      effects.exit('definitionMarker');
      return markerAfter
    }
    return nok(code)
  }

  /**
   * After marker.
   *
   * ```markdown
   * > | [a]: b "c"
   *         ^
   * ```
   *
   * @type {State}
   */
  function markerAfter(code) {
    // Note: whitespace is optional.
    return markdownLineEndingOrSpace(code)
      ? factoryWhitespace(effects, destinationBefore)(code)
      : destinationBefore(code)
  }

  /**
   * Before destination.
   *
   * ```markdown
   * > | [a]: b "c"
   *          ^
   * ```
   *
   * @type {State}
   */
  function destinationBefore(code) {
    return factoryDestination(
      effects,
      destinationAfter,
      // Note: we don’t need to reset the way `markdown-rs` does.
      nok,
      'definitionDestination',
      'definitionDestinationLiteral',
      'definitionDestinationLiteralMarker',
      'definitionDestinationRaw',
      'definitionDestinationString'
    )(code)
  }

  /**
   * After destination.
   *
   * ```markdown
   * > | [a]: b "c"
   *           ^
   * ```
   *
   * @type {State}
   */
  function destinationAfter(code) {
    return effects.attempt(titleBefore, after, after)(code)
  }

  /**
   * After definition.
   *
   * ```markdown
   * > | [a]: b
   *           ^
   * > | [a]: b "c"
   *               ^
   * ```
   *
   * @type {State}
   */
  function after(code) {
    return markdownSpace(code)
      ? factorySpace(effects, afterWhitespace, 'whitespace')(code)
      : afterWhitespace(code)
  }

  /**
   * After definition, after optional whitespace.
   *
   * ```markdown
   * > | [a]: b
   *           ^
   * > | [a]: b "c"
   *               ^
   * ```
   *
   * @type {State}
   */
  function afterWhitespace(code) {
    if (code === null || markdownLineEnding(code)) {
      effects.exit('definition');

      // Note: we don’t care about uniqueness.
      // It’s likely that that doesn’t happen very frequently.
      // It is more likely that it wastes precious time.
      self.parser.defined.push(identifier);

      // To do: `markdown-rs` interrupt.
      // // You’d be interrupting.
      // tokenizer.interrupt = true
      return ok(code)
    }
    return nok(code)
  }
}

/**
 * @this {TokenizeContext}
 * @type {Tokenizer}
 */
function tokenizeTitleBefore(effects, ok, nok) {
  return titleBefore

  /**
   * After destination, at whitespace.
   *
   * ```markdown
   * > | [a]: b
   *           ^
   * > | [a]: b "c"
   *           ^
   * ```
   *
   * @type {State}
   */
  function titleBefore(code) {
    return markdownLineEndingOrSpace(code)
      ? factoryWhitespace(effects, beforeMarker)(code)
      : nok(code)
  }

  /**
   * At title.
   *
   * ```markdown
   *   | [a]: b
   * > | "c"
   *     ^
   * ```
   *
   * @type {State}
   */
  function beforeMarker(code) {
    return factoryTitle(
      effects,
      titleAfter,
      nok,
      'definitionTitle',
      'definitionTitleMarker',
      'definitionTitleString'
    )(code)
  }

  /**
   * After title.
   *
   * ```markdown
   * > | [a]: b "c"
   *               ^
   * ```
   *
   * @type {State}
   */
  function titleAfter(code) {
    return markdownSpace(code)
      ? factorySpace(effects, titleAfterOptionalWhitespace, 'whitespace')(code)
      : titleAfterOptionalWhitespace(code)
  }

  /**
   * After title, after optional whitespace.
   *
   * ```markdown
   * > | [a]: b "c"
   *               ^
   * ```
   *
   * @type {State}
   */
  function titleAfterOptionalWhitespace(code) {
    return code === null || markdownLineEnding(code) ? ok(code) : nok(code)
  }
}

/**
 * @typedef {import('micromark-util-types').Construct} Construct
 * @typedef {import('micromark-util-types').State} State
 * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext
 * @typedef {import('micromark-util-types').Tokenizer} Tokenizer
 */

/** @type {Construct} */
const hardBreakEscape = {
  name: 'hardBreakEscape',
  tokenize: tokenizeHardBreakEscape
};

/**
 * @this {TokenizeContext}
 * @type {Tokenizer}
 */
function tokenizeHardBreakEscape(effects, ok, nok) {
  return start

  /**
   * Start of a hard break (escape).
   *
   * ```markdown
   * > | a\
   *      ^
   *   | b
   * ```
   *
   * @type {State}
   */
  function start(code) {
    effects.enter('hardBreakEscape');
    effects.consume(code);
    return after
  }

  /**
   * After `\`, at eol.
   *
   * ```markdown
   * > | a\
   *       ^
   *   | b
   * ```
   *
   *  @type {State}
   */
  function after(code) {
    if (markdownLineEnding(code)) {
      effects.exit('hardBreakEscape');
      return ok(code)
    }
    return nok(code)
  }
}

/**
 * @typedef {import('micromark-util-types').Construct} Construct
 * @typedef {import('micromark-util-types').Resolver} Resolver
 * @typedef {import('micromark-util-types').State} State
 * @typedef {import('micromark-util-types').Token} Token
 * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext
 * @typedef {import('micromark-util-types').Tokenizer} Tokenizer
 */

/** @type {Construct} */
const headingAtx = {
  name: 'headingAtx',
  tokenize: tokenizeHeadingAtx,
  resolve: resolveHeadingAtx
};

/** @type {Resolver} */
function resolveHeadingAtx(events, context) {
  let contentEnd = events.length - 2;
  let contentStart = 3;
  /** @type {Token} */
  let content;
  /** @type {Token} */
  let text;

  // Prefix whitespace, part of the opening.
  if (events[contentStart][1].type === 'whitespace') {
    contentStart += 2;
  }

  // Suffix whitespace, part of the closing.
  if (
    contentEnd - 2 > contentStart &&
    events[contentEnd][1].type === 'whitespace'
  ) {
    contentEnd -= 2;
  }
  if (
    events[contentEnd][1].type === 'atxHeadingSequence' &&
    (contentStart === contentEnd - 1 ||
      (contentEnd - 4 > contentStart &&
        events[contentEnd - 2][1].type === 'whitespace'))
  ) {
    contentEnd -= contentStart + 1 === contentEnd ? 2 : 4;
  }
  if (contentEnd > contentStart) {
    content = {
      type: 'atxHeadingText',
      start: events[contentStart][1].start,
      end: events[contentEnd][1].end
    };
    text = {
      type: 'chunkText',
      start: events[contentStart][1].start,
      end: events[contentEnd][1].end,
      contentType: 'text'
    };
    splice(events, contentStart, contentEnd - contentStart + 1, [
      ['enter', content, context],
      ['enter', text, context],
      ['exit', text, context],
      ['exit', content, context]
    ]);
  }
  return events
}

/**
 * @this {TokenizeContext}
 * @type {Tokenizer}
 */
function tokenizeHeadingAtx(effects, ok, nok) {
  let size = 0;
  return start

  /**
   * Start of a heading (atx).
   *
   * ```markdown
   * > | ## aa
   *     ^
   * ```
   *
   * @type {State}
   */
  function start(code) {
    // To do: parse indent like `markdown-rs`.
    effects.enter('atxHeading');
    return before(code)
  }

  /**
   * After optional whitespace, at `#`.
   *
   * ```markdown
   * > | ## aa
   *     ^
   * ```
   *
   * @type {State}
   */
  function before(code) {
    effects.enter('atxHeadingSequence');
    return sequenceOpen(code)
  }

  /**
   * In opening sequence.
   *
   * ```markdown
   * > | ## aa
   *     ^
   * ```
   *
   * @type {State}
   */
  function sequenceOpen(code) {
    if (code === 35 && size++ < 6) {
      effects.consume(code);
      return sequenceOpen
    }

    // Always at least one `#`.
    if (code === null || markdownLineEndingOrSpace(code)) {
      effects.exit('atxHeadingSequence');
      return atBreak(code)
    }
    return nok(code)
  }

  /**
   * After something, before something else.
   *
   * ```markdown
   * > | ## aa
   *       ^
   * ```
   *
   * @type {State}
   */
  function atBreak(code) {
    if (code === 35) {
      effects.enter('atxHeadingSequence');
      return sequenceFurther(code)
    }
    if (code === null || markdownLineEnding(code)) {
      effects.exit('atxHeading');
      // To do: interrupt like `markdown-rs`.
      // // Feel free to interrupt.
      // tokenizer.interrupt = false
      return ok(code)
    }
    if (markdownSpace(code)) {
      return factorySpace(effects, atBreak, 'whitespace')(code)
    }

    // To do: generate `data` tokens, add the `text` token later.
    // Needs edit map, see: `markdown.rs`.
    effects.enter('atxHeadingText');
    return data(code)
  }

  /**
   * In further sequence (after whitespace).
   *
   * Could be normal “visible” hashes in the heading or a final sequence.
   *
   * ```markdown
   * > | ## aa ##
   *           ^
   * ```
   *
   * @type {State}
   */
  function sequenceFurther(code) {
    if (code === 35) {
      effects.consume(code);
      return sequenceFurther
    }
    effects.exit('atxHeadingSequence');
    return atBreak(code)
  }

  /**
   * In text.
   *
   * ```markdown
   * > | ## aa
   *        ^
   * ```
   *
   * @type {State}
   */
  function data(code) {
    if (code === null || code === 35 || markdownLineEndingOrSpace(code)) {
      effects.exit('atxHeadingText');
      return atBreak(code)
    }
    effects.consume(code);
    return data
  }
}

/**
 * List of lowercase HTML “block” tag names.
 *
 * The list, when parsing HTML (flow), results in more relaxed rules (condition
 * 6).
 * Because they are known blocks, the HTML-like syntax doesn’t have to be
 * strictly parsed.
 * For tag names not in this list, a more strict algorithm (condition 7) is used
 * to detect whether the HTML-like syntax is seen as HTML (flow) or not.
 *
 * This is copied from:
 * <https://spec.commonmark.org/0.30/#html-blocks>.
 *
 * > 👉 **Note**: `search` was added in `CommonMark@0.31`.
 */
const htmlBlockNames = [
  'address',
  'article',
  'aside',
  'base',
  'basefont',
  'blockquote',
  'body',
  'caption',
  'center',
  'col',
  'colgroup',
  'dd',
  'details',
  'dialog',
  'dir',
  'div',
  'dl',
  'dt',
  'fieldset',
  'figcaption',
  'figure',
  'footer',
  'form',
  'frame',
  'frameset',
  'h1',
  'h2',
  'h3',
  'h4',
  'h5',
  'h6',
  'head',
  'header',
  'hr',
  'html',
  'iframe',
  'legend',
  'li',
  'link',
  'main',
  'menu',
  'menuitem',
  'nav',
  'noframes',
  'ol',
  'optgroup',
  'option',
  'p',
  'param',
  'search',
  'section',
  'summary',
  'table',
  'tbody',
  'td',
  'tfoot',
  'th',
  'thead',
  'title',
  'tr',
  'track',
  'ul'
];

/**
 * List of lowercase HTML “raw” tag names.
 *
 * The list, when parsing HTML (flow), results in HTML that can include lines
 * without exiting, until a closing tag also in this list is found (condition
 * 1).
 *
 * This module is copied from:
 * <https://spec.commonmark.org/0.30/#html-blocks>.
 *
 * > 👉 **Note**: `textarea` was added in `CommonMark@0.30`.
 */
const htmlRawNames = ['pre', 'script', 'style', 'textarea'];

/**
 * @typedef {import('micromark-util-types').Code} Code
 * @typedef {import('micromark-util-types').Construct} Construct
 * @typedef {import('micromark-util-types').Resolver} Resolver
 * @typedef {import('micromark-util-types').State} State
 * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext
 * @typedef {import('micromark-util-types').Tokenizer} Tokenizer
 */


/** @type {Construct} */
const htmlFlow = {
  name: 'htmlFlow',
  tokenize: tokenizeHtmlFlow,
  resolveTo: resolveToHtmlFlow,
  concrete: true
};

/** @type {Construct} */
const blankLineBefore = {
  tokenize: tokenizeBlankLineBefore,
  partial: true
};
const nonLazyContinuationStart = {
  tokenize: tokenizeNonLazyContinuationStart,
  partial: true
};

/** @type {Resolver} */
function resolveToHtmlFlow(events) {
  let index = events.length;
  while (index--) {
    if (events[index][0] === 'enter' && events[index][1].type === 'htmlFlow') {
      break
    }
  }
  if (index > 1 && events[index - 2][1].type === 'linePrefix') {
    // Add the prefix start to the HTML token.
    events[index][1].start = events[index - 2][1].start;
    // Add the prefix start to the HTML line token.
    events[index + 1][1].start = events[index - 2][1].start;
    // Remove the line prefix.
    events.splice(index - 2, 2);
  }
  return events
}

/**
 * @this {TokenizeContext}
 * @type {Tokenizer}
 */
function tokenizeHtmlFlow(effects, ok, nok) {
  const self = this;
  /** @type {number} */
  let marker;
  /** @type {boolean} */
  let closingTag;
  /** @type {string} */
  let buffer;
  /** @type {number} */
  let index;
  /** @type {Code} */
  let markerB;
  return start

  /**
   * Start of HTML (flow).
   *
   * ```markdown
   * > | <x />
   *     ^
   * ```
   *
   * @type {State}
   */
  function start(code) {
    // To do: parse indent like `markdown-rs`.
    return before(code)
  }

  /**
   * At `<`, after optional whitespace.
   *
   * ```markdown
   * > | <x />
   *     ^
   * ```
   *
   * @type {State}
   */
  function before(code) {
    effects.enter('htmlFlow');
    effects.enter('htmlFlowData');
    effects.consume(code);
    return open
  }

  /**
   * After `<`, at tag name or other stuff.
   *
   * ```markdown
   * > | <x />
   *      ^
   * > | <!doctype>
   *      ^
   * > | <!--xxx-->
   *      ^
   * ```
   *
   * @type {State}
   */
  function open(code) {
    if (code === 33) {
      effects.consume(code);
      return declarationOpen
    }
    if (code === 47) {
      effects.consume(code);
      closingTag = true;
      return tagCloseStart
    }
    if (code === 63) {
      effects.consume(code);
      marker = 3;
      // To do:
      // tokenizer.concrete = true
      // To do: use `markdown-rs` style interrupt.
      // While we’re in an instruction instead of a declaration, we’re on a `?`
      // right now, so we do need to search for `>`, similar to declarations.
      return self.interrupt ? ok : continuationDeclarationInside
    }

    // ASCII alphabetical.
    if (asciiAlpha(code)) {
      effects.consume(code);
      // @ts-expect-error: not null.
      buffer = String.fromCharCode(code);
      return tagName
    }
    return nok(code)
  }

  /**
   * After `<!`, at declaration, comment, or CDATA.
   *
   * ```markdown
   * > | <!doctype>
   *       ^
   * > | <!--xxx-->
   *       ^
   * > | <![CDATA[>&<]]>
   *       ^
   * ```
   *
   * @type {State}
   */
  function declarationOpen(code) {
    if (code === 45) {
      effects.consume(code);
      marker = 2;
      return commentOpenInside
    }
    if (code === 91) {
      effects.consume(code);
      marker = 5;
      index = 0;
      return cdataOpenInside
    }

    // ASCII alphabetical.
    if (asciiAlpha(code)) {
      effects.consume(code);
      marker = 4;
      // // Do not form containers.
      // tokenizer.concrete = true
      return self.interrupt ? ok : continuationDeclarationInside
    }
    return nok(code)
  }

  /**
   * After `<!-`, inside a comment, at another `-`.
   *
   * ```markdown
   * > | <!--xxx-->
   *        ^
   * ```
   *
   * @type {State}
   */
  function commentOpenInside(code) {
    if (code === 45) {
      effects.consume(code);
      // // Do not form containers.
      // tokenizer.concrete = true
      return self.interrupt ? ok : continuationDeclarationInside
    }
    return nok(code)
  }

  /**
   * After `<![`, inside CDATA, expecting `CDATA[`.
   *
   * ```markdown
   * > | <![CDATA[>&<]]>
   *        ^^^^^^
   * ```
   *
   * @type {State}
   */
  function cdataOpenInside(code) {
    const value = 'CDATA[';
    if (code === value.charCodeAt(index++)) {
      effects.consume(code);
      if (index === value.length) {
        // // Do not form containers.
        // tokenizer.concrete = true
        return self.interrupt ? ok : continuation
      }
      return cdataOpenInside
    }
    return nok(code)
  }

  /**
   * After `</`, in closing tag, at tag name.
   *
   * ```markdown
   * > | </x>
   *       ^
   * ```
   *
   * @type {State}
   */
  function tagCloseStart(code) {
    if (asciiAlpha(code)) {
      effects.consume(code);
      // @ts-expect-error: not null.
      buffer = String.fromCharCode(code);
      return tagName
    }
    return nok(code)
  }

  /**
   * In tag name.
   *
   * ```markdown
   * > | <ab>
   *      ^^
   * > | </ab>
   *       ^^
   * ```
   *
   * @type {State}
   */
  function tagName(code) {
    if (
      code === null ||
      code === 47 ||
      code === 62 ||
      markdownLineEndingOrSpace(code)
    ) {
      const slash = code === 47;
      const name = buffer.toLowerCase();
      if (!slash && !closingTag && htmlRawNames.includes(name)) {
        marker = 1;
        // // Do not form containers.
        // tokenizer.concrete = true
        return self.interrupt ? ok(code) : continuation(code)
      }
      if (htmlBlockNames.includes(buffer.toLowerCase())) {
        marker = 6;
        if (slash) {
          effects.consume(code);
          return basicSelfClosing
        }

        // // Do not form containers.
        // tokenizer.concrete = true
        return self.interrupt ? ok(code) : continuation(code)
      }
      marker = 7;
      // Do not support complete HTML when interrupting.
      return self.interrupt && !self.parser.lazy[self.now().line]
        ? nok(code)
        : closingTag
        ? completeClosingTagAfter(code)
        : completeAttributeNameBefore(code)
    }

    // ASCII alphanumerical and `-`.
    if (code === 45 || asciiAlphanumeric(code)) {
      effects.consume(code);
      buffer += String.fromCharCode(code);
      return tagName
    }
    return nok(code)
  }

  /**
   * After closing slash of a basic tag name.
   *
   * ```markdown
   * > | <div/>
   *          ^
   * ```
   *
   * @type {State}
   */
  function basicSelfClosing(code) {
    if (code === 62) {
      effects.consume(code);
      // // Do not form containers.
      // tokenizer.concrete = true
      return self.interrupt ? ok : continuation
    }
    return nok(code)
  }

  /**
   * After closing slash of a complete tag name.
   *
   * ```markdown
   * > | <x/>
   *        ^
   * ```
   *
   * @type {State}
   */
  function completeClosingTagAfter(code) {
    if (markdownSpace(code)) {
      effects.consume(code);
      return completeClosingTagAfter
    }
    return completeEnd(code)
  }

  /**
   * At an attribute name.
   *
   * At first, this state is used after a complete tag name, after whitespace,
   * where it expects optional attributes or the end of the tag.
   * It is also reused after attributes, when expecting more optional
   * attributes.
   *
   * ```markdown
   * > | <a />
   *        ^
   * > | <a :b>
   *        ^
   * > | <a _b>
   *        ^
   * > | <a b>
   *        ^
   * > | <a >
   *        ^
   * ```
   *
   * @type {State}
   */
  function completeAttributeNameBefore(code) {
    if (code === 47) {
      effects.consume(code);
      return completeEnd
    }

    // ASCII alphanumerical and `:` and `_`.
    if (code === 58 || code === 95 || asciiAlpha(code)) {
      effects.consume(code);
      return completeAttributeName
    }
    if (markdownSpace(code)) {
      effects.consume(code);
      return completeAttributeNameBefore
    }
    return completeEnd(code)
  }

  /**
   * In attribute name.
   *
   * ```markdown
   * > | <a :b>
   *         ^
   * > | <a _b>
   *         ^
   * > | <a b>
   *         ^
   * ```
   *
   * @type {State}
   */
  function completeAttributeName(code) {
    // ASCII alphanumerical and `-`, `.`, `:`, and `_`.
    if (
      code === 45 ||
      code === 46 ||
      code === 58 ||
      code === 95 ||
      asciiAlphanumeric(code)
    ) {
      effects.consume(code);
      return completeAttributeName
    }
    return completeAttributeNameAfter(code)
  }

  /**
   * After attribute name, at an optional initializer, the end of the tag, or
   * whitespace.
   *
   * ```markdown
   * > | <a b>
   *         ^
   * > | <a b=c>
   *         ^
   * ```
   *
   * @type {State}
   */
  function completeAttributeNameAfter(code) {
    if (code === 61) {
      effects.consume(code);
      return completeAttributeValueBefore
    }
    if (markdownSpace(code)) {
      effects.consume(code);
      return completeAttributeNameAfter
    }
    return completeAttributeNameBefore(code)
  }

  /**
   * Before unquoted, double quoted, or single quoted attribute value, allowing
   * whitespace.
   *
   * ```markdown
   * > | <a b=c>
   *          ^
   * > | <a b="c">
   *          ^
   * ```
   *
   * @type {State}
   */
  function completeAttributeValueBefore(code) {
    if (
      code === null ||
      code === 60 ||
      code === 61 ||
      code === 62 ||
      code === 96
    ) {
      return nok(code)
    }
    if (code === 34 || code === 39) {
      effects.consume(code);
      markerB = code;
      return completeAttributeValueQuoted
    }
    if (markdownSpace(code)) {
      effects.consume(code);
      return completeAttributeValueBefore
    }
    return completeAttributeValueUnquoted(code)
  }

  /**
   * In double or single quoted attribute value.
   *
   * ```markdown
   * > | <a b="c">
   *           ^
   * > | <a b='c'>
   *           ^
   * ```
   *
   * @type {State}
   */
  function completeAttributeValueQuoted(code) {
    if (code === markerB) {
      effects.consume(code);
      markerB = null;
      return completeAttributeValueQuotedAfter
    }
    if (code === null || markdownLineEnding(code)) {
      return nok(code)
    }
    effects.consume(code);
    return completeAttributeValueQuoted
  }

  /**
   * In unquoted attribute value.
   *
   * ```markdown
   * > | <a b=c>
   *          ^
   * ```
   *
   * @type {State}
   */
  function completeAttributeValueUnquoted(code) {
    if (
      code === null ||
      code === 34 ||
      code === 39 ||
      code === 47 ||
      code === 60 ||
      code === 61 ||
      code === 62 ||
      code === 96 ||
      markdownLineEndingOrSpace(code)
    ) {
      return completeAttributeNameAfter(code)
    }
    effects.consume(code);
    return completeAttributeValueUnquoted
  }

  /**
   * After double or single quoted attribute value, before whitespace or the
   * end of the tag.
   *
   * ```markdown
   * > | <a b="c">
   *            ^
   * ```
   *
   * @type {State}
   */
  function completeAttributeValueQuotedAfter(code) {
    if (code === 47 || code === 62 || markdownSpace(code)) {
      return completeAttributeNameBefore(code)
    }
    return nok(code)
  }

  /**
   * In certain circumstances of a complete tag where only an `>` is allowed.
   *
   * ```markdown
   * > | <a b="c">
   *             ^
   * ```
   *
   * @type {State}
   */
  function completeEnd(code) {
    if (code === 62) {
      effects.consume(code);
      return completeAfter
    }
    return nok(code)
  }

  /**
   * After `>` in a complete tag.
   *
   * ```markdown
   * > | <x>
   *        ^
   * ```
   *
   * @type {State}
   */
  function completeAfter(code) {
    if (code === null || markdownLineEnding(code)) {
      // // Do not form containers.
      // tokenizer.concrete = true
      return continuation(code)
    }
    if (markdownSpace(code)) {
      effects.consume(code);
      return completeAfter
    }
    return nok(code)
  }

  /**
   * In continuation of any HTML kind.
   *
   * ```markdown
   * > | <!--xxx-->
   *          ^
   * ```
   *
   * @type {State}
   */
  function continuation(code) {
    if (code === 45 && marker === 2) {
      effects.consume(code);
      return continuationCommentInside
    }
    if (code === 60 && marker === 1) {
      effects.consume(code);
      return continuationRawTagOpen
    }
    if (code === 62 && marker === 4) {
      effects.consume(code);
      return continuationClose
    }
    if (code === 63 && marker === 3) {
      effects.consume(code);
      return continuationDeclarationInside
    }
    if (code === 93 && marker === 5) {
      effects.consume(code);
      return continuationCdataInside
    }
    if (markdownLineEnding(code) && (marker === 6 || marker === 7)) {
      effects.exit('htmlFlowData');
      return effects.check(
        blankLineBefore,
        continuationAfter,
        continuationStart
      )(code)
    }
    if (code === null || markdownLineEnding(code)) {
      effects.exit('htmlFlowData');
      return continuationStart(code)
    }
    effects.consume(code);
    return continuation
  }

  /**
   * In continuation, at eol.
   *
   * ```markdown
   * > | <x>
   *        ^
   *   | asd
   * ```
   *
   * @type {State}
   */
  function continuationStart(code) {
    return effects.check(
      nonLazyContinuationStart,
      continuationStartNonLazy,
      continuationAfter
    )(code)
  }

  /**
   * In continuation, at eol, before non-lazy content.
   *
   * ```markdown
   * > | <x>
   *        ^
   *   | asd
   * ```
   *
   * @type {State}
   */
  function continuationStartNonLazy(code) {
    effects.enter('lineEnding');
    effects.consume(code);
    effects.exit('lineEnding');
    return continuationBefore
  }

  /**
   * In continuation, before non-lazy content.
   *
   * ```markdown
   *   | <x>
   * > | asd
   *     ^
   * ```
   *
   * @type {State}
   */
  function continuationBefore(code) {
    if (code === null || markdownLineEnding(code)) {
      return continuationStart(code)
    }
    effects.enter('htmlFlowData');
    return continuation(code)
  }

  /**
   * In comment continuation, after one `-`, expecting another.
   *
   * ```markdown
   * > | <!--xxx-->
   *             ^
   * ```
   *
   * @type {State}
   */
  function continuationCommentInside(code) {
    if (code === 45) {
      effects.consume(code);
      return continuationDeclarationInside
    }
    return continuation(code)
  }

  /**
   * In raw continuation, after `<`, at `/`.
   *
   * ```markdown
   * > | <script>console.log(1)</script>
   *                            ^
   * ```
   *
   * @type {State}
   */
  function continuationRawTagOpen(code) {
    if (code === 47) {
      effects.consume(code);
      buffer = '';
      return continuationRawEndTag
    }
    return continuation(code)
  }

  /**
   * In raw continuation, after `</`, in a raw tag name.
   *
   * ```markdown
   * > | <script>console.log(1)</script>
   *                             ^^^^^^
   * ```
   *
   * @type {State}
   */
  function continuationRawEndTag(code) {
    if (code === 62) {
      const name = buffer.toLowerCase();
      if (htmlRawNames.includes(name)) {
        effects.consume(code);
        return continuationClose
      }
      return continuation(code)
    }
    if (asciiAlpha(code) && buffer.length < 8) {
      effects.consume(code);
      // @ts-expect-error: not null.
      buffer += String.fromCharCode(code);
      return continuationRawEndTag
    }
    return continuation(code)
  }

  /**
   * In cdata continuation, after `]`, expecting `]>`.
   *
   * ```markdown
   * > | <![CDATA[>&<]]>
   *                  ^
   * ```
   *
   * @type {State}
   */
  function continuationCdataInside(code) {
    if (code === 93) {
      effects.consume(code);
      return continuationDeclarationInside
    }
    return continuation(code)
  }

  /**
   * In declaration or instruction continuation, at `>`.
   *
   * ```markdown
   * > | <!-->
   *         ^
   * > | <?>
   *       ^
   * > | <!q>
   *        ^
   * > | <!--ab-->
   *             ^
   * > | <![CDATA[>&<]]>
   *                   ^
   * ```
   *
   * @type {State}
   */
  function continuationDeclarationInside(code) {
    if (code === 62) {
      effects.consume(code);
      return continuationClose
    }

    // More dashes.
    if (code === 45 && marker === 2) {
      effects.consume(code);
      return continuationDeclarationInside
    }
    return continuation(code)
  }

  /**
   * In closed continuation: everything we get until the eol/eof is part of it.
   *
   * ```markdown
   * > | <!doctype>
   *               ^
   * ```
   *
   * @type {State}
   */
  function continuationClose(code) {
    if (code === null || markdownLineEnding(code)) {
      effects.exit('htmlFlowData');
      return continuationAfter(code)
    }
    effects.consume(code);
    return continuationClose
  }

  /**
   * Done.
   *
   * ```markdown
   * > | <!doctype>
   *               ^
   * ```
   *
   * @type {State}
   */
  function continuationAfter(code) {
    effects.exit('htmlFlow');
    // // Feel free to interrupt.
    // tokenizer.interrupt = false
    // // No longer concrete.
    // tokenizer.concrete = false
    return ok(code)
  }
}

/**
 * @this {TokenizeContext}
 * @type {Tokenizer}
 */
function tokenizeNonLazyContinuationStart(effects, ok, nok) {
  const self = this;
  return start

  /**
   * At eol, before continuation.
   *
   * ```markdown
   * > | * ```js
   *            ^
   *   | b
   * ```
   *
   * @type {State}
   */
  function start(code) {
    if (markdownLineEnding(code)) {
      effects.enter('lineEnding');
      effects.consume(code);
      effects.exit('lineEnding');
      return after
    }
    return nok(code)
  }

  /**
   * A continuation.
   *
   * ```markdown
   *   | * ```js
   * > | b
   *     ^
   * ```
   *
   * @type {State}
   */
  function after(code) {
    return self.parser.lazy[self.now().line] ? nok(code) : ok(code)
  }
}

/**
 * @this {TokenizeContext}
 * @type {Tokenizer}
 */
function tokenizeBlankLineBefore(effects, ok, nok) {
  return start

  /**
   * Before eol, expecting blank line.
   *
   * ```markdown
   * > | <div>
   *          ^
   *   |
   * ```
   *
   * @type {State}
   */
  function start(code) {
    effects.enter('lineEnding');
    effects.consume(code);
    effects.exit('lineEnding');
    return effects.attempt(blankLine, ok, nok)
  }
}

/**
 * @typedef {import('micromark-util-types').Code} Code
 * @typedef {import('micromark-util-types').Construct} Construct
 * @typedef {import('micromark-util-types').State} State
 * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext
 * @typedef {import('micromark-util-types').Tokenizer} Tokenizer
 */

/** @type {Construct} */
const htmlText = {
  name: 'htmlText',
  tokenize: tokenizeHtmlText
};

/**
 * @this {TokenizeContext}
 * @type {Tokenizer}
 */
function tokenizeHtmlText(effects, ok, nok) {
  const self = this;
  /** @type {NonNullable<Code> | undefined} */
  let marker;
  /** @type {number} */
  let index;
  /** @type {State} */
  let returnState;
  return start

  /**
   * Start of HTML (text).
   *
   * ```markdown
   * > | a <b> c
   *       ^
   * ```
   *
   * @type {State}
   */
  function start(code) {
    effects.enter('htmlText');
    effects.enter('htmlTextData');
    effects.consume(code);
    return open
  }

  /**
   * After `<`, at tag name or other stuff.
   *
   * ```markdown
   * > | a <b> c
   *        ^
   * > | a <!doctype> c
   *        ^
   * > | a <!--b--> c
   *        ^
   * ```
   *
   * @type {State}
   */
  function open(code) {
    if (code === 33) {
      effects.consume(code);
      return declarationOpen
    }
    if (code === 47) {
      effects.consume(code);
      return tagCloseStart
    }
    if (code === 63) {
      effects.consume(code);
      return instruction
    }

    // ASCII alphabetical.
    if (asciiAlpha(code)) {
      effects.consume(code);
      return tagOpen
    }
    return nok(code)
  }

  /**
   * After `<!`, at declaration, comment, or CDATA.
   *
   * ```markdown
   * > | a <!doctype> c
   *         ^
   * > | a <!--b--> c
   *         ^
   * > | a <![CDATA[>&<]]> c
   *         ^
   * ```
   *
   * @type {State}
   */
  function declarationOpen(code) {
    if (code === 45) {
      effects.consume(code);
      return commentOpenInside
    }
    if (code === 91) {
      effects.consume(code);
      index = 0;
      return cdataOpenInside
    }
    if (asciiAlpha(code)) {
      effects.consume(code);
      return declaration
    }
    return nok(code)
  }

  /**
   * In a comment, after `<!-`, at another `-`.
   *
   * ```markdown
   * > | a <!--b--> c
   *          ^
   * ```
   *
   * @type {State}
   */
  function commentOpenInside(code) {
    if (code === 45) {
      effects.consume(code);
      return commentEnd
    }
    return nok(code)
  }

  /**
   * In comment.
   *
   * ```markdown
   * > | a <!--b--> c
   *           ^
   * ```
   *
   * @type {State}
   */
  function comment(code) {
    if (code === null) {
      return nok(code)
    }
    if (code === 45) {
      effects.consume(code);
      return commentClose
    }
    if (markdownLineEnding(code)) {
      returnState = comment;
      return lineEndingBefore(code)
    }
    effects.consume(code);
    return comment
  }

  /**
   * In comment, after `-`.
   *
   * ```markdown
   * > | a <!--b--> c
   *             ^
   * ```
   *
   * @type {State}
   */
  function commentClose(code) {
    if (code === 45) {
      effects.consume(code);
      return commentEnd
    }
    return comment(code)
  }

  /**
   * In comment, after `--`.
   *
   * ```markdown
   * > | a <!--b--> c
   *              ^
   * ```
   *
   * @type {State}
   */
  function commentEnd(code) {
    return code === 62
      ? end(code)
      : code === 45
      ? commentClose(code)
      : comment(code)
  }

  /**
   * After `<![`, in CDATA, expecting `CDATA[`.
   *
   * ```markdown
   * > | a <![CDATA[>&<]]> b
   *          ^^^^^^
   * ```
   *
   * @type {State}
   */
  function cdataOpenInside(code) {
    const value = 'CDATA[';
    if (code === value.charCodeAt(index++)) {
      effects.consume(code);
      return index === value.length ? cdata : cdataOpenInside
    }
    return nok(code)
  }

  /**
   * In CDATA.
   *
   * ```markdown
   * > | a <![CDATA[>&<]]> b
   *                ^^^
   * ```
   *
   * @type {State}
   */
  function cdata(code) {
    if (code === null) {
      return nok(code)
    }
    if (code === 93) {
      effects.consume(code);
      return cdataClose
    }
    if (markdownLineEnding(code)) {
      returnState = cdata;
      return lineEndingBefore(code)
    }
    effects.consume(code);
    return cdata
  }

  /**
   * In CDATA, after `]`, at another `]`.
   *
   * ```markdown
   * > | a <![CDATA[>&<]]> b
   *                    ^
   * ```
   *
   * @type {State}
   */
  function cdataClose(code) {
    if (code === 93) {
      effects.consume(code);
      return cdataEnd
    }
    return cdata(code)
  }

  /**
   * In CDATA, after `]]`, at `>`.
   *
   * ```markdown
   * > | a <![CDATA[>&<]]> b
   *                     ^
   * ```
   *
   * @type {State}
   */
  function cdataEnd(code) {
    if (code === 62) {
      return end(code)
    }
    if (code === 93) {
      effects.consume(code);
      return cdataEnd
    }
    return cdata(code)
  }

  /**
   * In declaration.
   *
   * ```markdown
   * > | a <!b> c
   *          ^
   * ```
   *
   * @type {State}
   */
  function declaration(code) {
    if (code === null || code === 62) {
      return end(code)
    }
    if (markdownLineEnding(code)) {
      returnState = declaration;
      return lineEndingBefore(code)
    }
    effects.consume(code);
    return declaration
  }

  /**
   * In instruction.
   *
   * ```markdown
   * > | a <?b?> c
   *         ^
   * ```
   *
   * @type {State}
   */
  function instruction(code) {
    if (code === null) {
      return nok(code)
    }
    if (code === 63) {
      effects.consume(code);
      return instructionClose
    }
    if (markdownLineEnding(code)) {
      returnState = instruction;
      return lineEndingBefore(code)
    }
    effects.consume(code);
    return instruction
  }

  /**
   * In instruction, after `?`, at `>`.
   *
   * ```markdown
   * > | a <?b?> c
   *           ^
   * ```
   *
   * @type {State}
   */
  function instructionClose(code) {
    return code === 62 ? end(code) : instruction(code)
  }

  /**
   * After `</`, in closing tag, at tag name.
   *
   * ```markdown
   * > | a </b> c
   *         ^
   * ```
   *
   * @type {State}
   */
  function tagCloseStart(code) {
    // ASCII alphabetical.
    if (asciiAlpha(code)) {
      effects.consume(code);
      return tagClose
    }
    return nok(code)
  }

  /**
   * After `</x`, in a tag name.
   *
   * ```markdown
   * > | a </b> c
   *          ^
   * ```
   *
   * @type {State}
   */
  function tagClose(code) {
    // ASCII alphanumerical and `-`.
    if (code === 45 || asciiAlphanumeric(code)) {
      effects.consume(code);
      return tagClose
    }
    return tagCloseBetween(code)
  }

  /**
   * In closing tag, after tag name.
   *
   * ```markdown
   * > | a </b> c
   *          ^
   * ```
   *
   * @type {State}
   */
  function tagCloseBetween(code) {
    if (markdownLineEnding(code)) {
      returnState = tagCloseBetween;
      return lineEndingBefore(code)
    }
    if (markdownSpace(code)) {
      effects.consume(code);
      return tagCloseBetween
    }
    return end(code)
  }

  /**
   * After `<x`, in opening tag name.
   *
   * ```markdown
   * > | a <b> c
   *         ^
   * ```
   *
   * @type {State}
   */
  function tagOpen(code) {
    // ASCII alphanumerical and `-`.
    if (code === 45 || asciiAlphanumeric(code)) {
      effects.consume(code);
      return tagOpen
    }
    if (code === 47 || code === 62 || markdownLineEndingOrSpace(code)) {
      return tagOpenBetween(code)
    }
    return nok(code)
  }

  /**
   * In opening tag, after tag name.
   *
   * ```markdown
   * > | a <b> c
   *         ^
   * ```
   *
   * @type {State}
   */
  function tagOpenBetween(code) {
    if (code === 47) {
      effects.consume(code);
      return end
    }

    // ASCII alphabetical and `:` and `_`.
    if (code === 58 || code === 95 || asciiAlpha(code)) {
      effects.consume(code);
      return tagOpenAttributeName
    }
    if (markdownLineEnding(code)) {
      returnState = tagOpenBetween;
      return lineEndingBefore(code)
    }
    if (markdownSpace(code)) {
      effects.consume(code);
      return tagOpenBetween
    }
    return end(code)
  }

  /**
   * In attribute name.
   *
   * ```markdown
   * > | a <b c> d
   *          ^
   * ```
   *
   * @type {State}
   */
  function tagOpenAttributeName(code) {
    // ASCII alphabetical and `-`, `.`, `:`, and `_`.
    if (
      code === 45 ||
      code === 46 ||
      code === 58 ||
      code === 95 ||
      asciiAlphanumeric(code)
    ) {
      effects.consume(code);
      return tagOpenAttributeName
    }
    return tagOpenAttributeNameAfter(code)
  }

  /**
   * After attribute name, before initializer, the end of the tag, or
   * whitespace.
   *
   * ```markdown
   * > | a <b c> d
   *           ^
   * ```
   *
   * @type {State}
   */
  function tagOpenAttributeNameAfter(code) {
    if (code === 61) {
      effects.consume(code);
      return tagOpenAttributeValueBefore
    }
    if (markdownLineEnding(code)) {
      returnState = tagOpenAttributeNameAfter;
      return lineEndingBefore(code)
    }
    if (markdownSpace(code)) {
      effects.consume(code);
      return tagOpenAttributeNameAfter
    }
    return tagOpenBetween(code)
  }

  /**
   * Before unquoted, double quoted, or single quoted attribute value, allowing
   * whitespace.
   *
   * ```markdown
   * > | a <b c=d> e
   *            ^
   * ```
   *
   * @type {State}
   */
  function tagOpenAttributeValueBefore(code) {
    if (
      code === null ||
      code === 60 ||
      code === 61 ||
      code === 62 ||
      code === 96
    ) {
      return nok(code)
    }
    if (code === 34 || code === 39) {
      effects.consume(code);
      marker = code;
      return tagOpenAttributeValueQuoted
    }
    if (markdownLineEnding(code)) {
      returnState = tagOpenAttributeValueBefore;
      return lineEndingBefore(code)
    }
    if (markdownSpace(code)) {
      effects.consume(code);
      return tagOpenAttributeValueBefore
    }
    effects.consume(code);
    return tagOpenAttributeValueUnquoted
  }

  /**
   * In double or single quoted attribute value.
   *
   * ```markdown
   * > | a <b c="d"> e
   *             ^
   * ```
   *
   * @type {State}
   */
  function tagOpenAttributeValueQuoted(code) {
    if (code === marker) {
      effects.consume(code);
      marker = undefined;
      return tagOpenAttributeValueQuotedAfter
    }
    if (code === null) {
      return nok(code)
    }
    if (markdownLineEnding(code)) {
      returnState = tagOpenAttributeValueQuoted;
      return lineEndingBefore(code)
    }
    effects.consume(code);
    return tagOpenAttributeValueQuoted
  }

  /**
   * In unquoted attribute value.
   *
   * ```markdown
   * > | a <b c=d> e
   *            ^
   * ```
   *
   * @type {State}
   */
  function tagOpenAttributeValueUnquoted(code) {
    if (
      code === null ||
      code === 34 ||
      code === 39 ||
      code === 60 ||
      code === 61 ||
      code === 96
    ) {
      return nok(code)
    }
    if (code === 47 || code === 62 || markdownLineEndingOrSpace(code)) {
      return tagOpenBetween(code)
    }
    effects.consume(code);
    return tagOpenAttributeValueUnquoted
  }

  /**
   * After double or single quoted attribute value, before whitespace or the end
   * of the tag.
   *
   * ```markdown
   * > | a <b c="d"> e
   *               ^
   * ```
   *
   * @type {State}
   */
  function tagOpenAttributeValueQuotedAfter(code) {
    if (code === 47 || code === 62 || markdownLineEndingOrSpace(code)) {
      return tagOpenBetween(code)
    }
    return nok(code)
  }

  /**
   * In certain circumstances of a tag where only an `>` is allowed.
   *
   * ```markdown
   * > | a <b c="d"> e
   *               ^
   * ```
   *
   * @type {State}
   */
  function end(code) {
    if (code === 62) {
      effects.consume(code);
      effects.exit('htmlTextData');
      effects.exit('htmlText');
      return ok
    }
    return nok(code)
  }

  /**
   * At eol.
   *
   * > 👉 **Note**: we can’t have blank lines in text, so no need to worry about
   * > empty tokens.
   *
   * ```markdown
   * > | a <!--a
   *            ^
   *   | b-->
   * ```
   *
   * @type {State}
   */
  function lineEndingBefore(code) {
    effects.exit('htmlTextData');
    effects.enter('lineEnding');
    effects.consume(code);
    effects.exit('lineEnding');
    return lineEndingAfter
  }

  /**
   * After eol, at optional whitespace.
   *
   * > 👉 **Note**: we can’t have blank lines in text, so no need to worry about
   * > empty tokens.
   *
   * ```markdown
   *   | a <!--a
   * > | b-->
   *     ^
   * ```
   *
   * @type {State}
   */
  function lineEndingAfter(code) {
    // Always populated by defaults.

    return markdownSpace(code)
      ? factorySpace(
          effects,
          lineEndingAfterPrefix,
          'linePrefix',
          self.parser.constructs.disable.null.includes('codeIndented')
            ? undefined
            : 4
        )(code)
      : lineEndingAfterPrefix(code)
  }

  /**
   * After eol, after optional whitespace.
   *
   * > 👉 **Note**: we can’t have blank lines in text, so no need to worry about
   * > empty tokens.
   *
   * ```markdown
   *   | a <!--a
   * > | b-->
   *     ^
   * ```
   *
   * @type {State}
   */
  function lineEndingAfterPrefix(code) {
    effects.enter('htmlTextData');
    return returnState(code)
  }
}

/**
 * @typedef {import('micromark-util-types').Construct} Construct
 * @typedef {import('micromark-util-types').Event} Event
 * @typedef {import('micromark-util-types').Resolver} Resolver
 * @typedef {import('micromark-util-types').State} State
 * @typedef {import('micromark-util-types').Token} Token
 * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext
 * @typedef {import('micromark-util-types').Tokenizer} Tokenizer
 */

/** @type {Construct} */
const labelEnd = {
  name: 'labelEnd',
  tokenize: tokenizeLabelEnd,
  resolveTo: resolveToLabelEnd,
  resolveAll: resolveAllLabelEnd
};

/** @type {Construct} */
const resourceConstruct = {
  tokenize: tokenizeResource
};
/** @type {Construct} */
const referenceFullConstruct = {
  tokenize: tokenizeReferenceFull
};
/** @type {Construct} */
const referenceCollapsedConstruct = {
  tokenize: tokenizeReferenceCollapsed
};

/** @type {Resolver} */
function resolveAllLabelEnd(events) {
  let index = -1;
  while (++index < events.length) {
    const token = events[index][1];
    if (
      token.type === 'labelImage' ||
      token.type === 'labelLink' ||
      token.type === 'labelEnd'
    ) {
      // Remove the marker.
      events.splice(index + 1, token.type === 'labelImage' ? 4 : 2);
      token.type = 'data';
      index++;
    }
  }
  return events
}

/** @type {Resolver} */
function resolveToLabelEnd(events, context) {
  let index = events.length;
  let offset = 0;
  /** @type {Token} */
  let token;
  /** @type {number | undefined} */
  let open;
  /** @type {number | undefined} */
  let close;
  /** @type {Array<Event>} */
  let media;

  // Find an opening.
  while (index--) {
    token = events[index][1];
    if (open) {
      // If we see another link, or inactive link label, we’ve been here before.
      if (
        token.type === 'link' ||
        (token.type === 'labelLink' && token._inactive)
      ) {
        break
      }

      // Mark other link openings as inactive, as we can’t have links in
      // links.
      if (events[index][0] === 'enter' && token.type === 'labelLink') {
        token._inactive = true;
      }
    } else if (close) {
      if (
        events[index][0] === 'enter' &&
        (token.type === 'labelImage' || token.type === 'labelLink') &&
        !token._balanced
      ) {
        open = index;
        if (token.type !== 'labelLink') {
          offset = 2;
          break
        }
      }
    } else if (token.type === 'labelEnd') {
      close = index;
    }
  }
  const group = {
    type: events[open][1].type === 'labelLink' ? 'link' : 'image',
    start: Object.assign({}, events[open][1].start),
    end: Object.assign({}, events[events.length - 1][1].end)
  };
  const label = {
    type: 'label',
    start: Object.assign({}, events[open][1].start),
    end: Object.assign({}, events[close][1].end)
  };
  const text = {
    type: 'labelText',
    start: Object.assign({}, events[open + offset + 2][1].end),
    end: Object.assign({}, events[close - 2][1].start)
  };
  media = [
    ['enter', group, context],
    ['enter', label, context]
  ];

  // Opening marker.
  media = push(media, events.slice(open + 1, open + offset + 3));

  // Text open.
  media = push(media, [['enter', text, context]]);

  // Always populated by defaults.

  // Between.
  media = push(
    media,
    resolveAll(
      context.parser.constructs.insideSpan.null,
      events.slice(open + offset + 4, close - 3),
      context
    )
  );

  // Text close, marker close, label close.
  media = push(media, [
    ['exit', text, context],
    events[close - 2],
    events[close - 1],
    ['exit', label, context]
  ]);

  // Reference, resource, or so.
  media = push(media, events.slice(close + 1));

  // Media close.
  media = push(media, [['exit', group, context]]);
  splice(events, open, events.length, media);
  return events
}

/**
 * @this {TokenizeContext}
 * @type {Tokenizer}
 */
function tokenizeLabelEnd(effects, ok, nok) {
  const self = this;
  let index = self.events.length;
  /** @type {Token} */
  let labelStart;
  /** @type {boolean} */
  let defined;

  // Find an opening.
  while (index--) {
    if (
      (self.events[index][1].type === 'labelImage' ||
        self.events[index][1].type === 'labelLink') &&
      !self.events[index][1]._balanced
    ) {
      labelStart = self.events[index][1];
      break
    }
  }
  return start

  /**
   * Start of label end.
   *
   * ```markdown
   * > | [a](b) c
   *       ^
   * > | [a][b] c
   *       ^
   * > | [a][] b
   *       ^
   * > | [a] b
   * ```
   *
   * @type {State}
   */
  function start(code) {
    // If there is not an okay opening.
    if (!labelStart) {
      return nok(code)
    }

    // If the corresponding label (link) start is marked as inactive,
    // it means we’d be wrapping a link, like this:
    //
    // ```markdown
    // > | a [b [c](d) e](f) g.
    //                  ^
    // ```
    //
    // We can’t have that, so it’s just balanced brackets.
    if (labelStart._inactive) {
      return labelEndNok(code)
    }
    defined = self.parser.defined.includes(
      normalizeIdentifier(
        self.sliceSerialize({
          start: labelStart.end,
          end: self.now()
        })
      )
    );
    effects.enter('labelEnd');
    effects.enter('labelMarker');
    effects.consume(code);
    effects.exit('labelMarker');
    effects.exit('labelEnd');
    return after
  }

  /**
   * After `]`.
   *
   * ```markdown
   * > | [a](b) c
   *       ^
   * > | [a][b] c
   *       ^
   * > | [a][] b
   *       ^
   * > | [a] b
   *       ^
   * ```
   *
   * @type {State}
   */
  function after(code) {
    // Note: `markdown-rs` also parses GFM footnotes here, which for us is in
    // an extension.

    // Resource (`[asd](fgh)`)?
    if (code === 40) {
      return effects.attempt(
        resourceConstruct,
        labelEndOk,
        defined ? labelEndOk : labelEndNok
      )(code)
    }

    // Full (`[asd][fgh]`) or collapsed (`[asd][]`) reference?
    if (code === 91) {
      return effects.attempt(
        referenceFullConstruct,
        labelEndOk,
        defined ? referenceNotFull : labelEndNok
      )(code)
    }

    // Shortcut (`[asd]`) reference?
    return defined ? labelEndOk(code) : labelEndNok(code)
  }

  /**
   * After `]`, at `[`, but not at a full reference.
   *
   * > 👉 **Note**: we only get here if the label is defined.
   *
   * ```markdown
   * > | [a][] b
   *        ^
   * > | [a] b
   *        ^
   * ```
   *
   * @type {State}
   */
  function referenceNotFull(code) {
    return effects.attempt(
      referenceCollapsedConstruct,
      labelEndOk,
      labelEndNok
    )(code)
  }

  /**
   * Done, we found something.
   *
   * ```markdown
   * > | [a](b) c
   *           ^
   * > | [a][b] c
   *           ^
   * > | [a][] b
   *          ^
   * > | [a] b
   *        ^
   * ```
   *
   * @type {State}
   */
  function labelEndOk(code) {
    // Note: `markdown-rs` does a bunch of stuff here.
    return ok(code)
  }

  /**
   * Done, it’s nothing.
   *
   * There was an okay opening, but we didn’t match anything.
   *
   * ```markdown
   * > | [a](b c
   *        ^
   * > | [a][b c
   *        ^
   * > | [a] b
   *        ^
   * ```
   *
   * @type {State}
   */
  function labelEndNok(code) {
    labelStart._balanced = true;
    return nok(code)
  }
}

/**
 * @this {TokenizeContext}
 * @type {Tokenizer}
 */
function tokenizeResource(effects, ok, nok) {
  return resourceStart

  /**
   * At a resource.
   *
   * ```markdown
   * > | [a](b) c
   *        ^
   * ```
   *
   * @type {State}
   */
  function resourceStart(code) {
    effects.enter('resource');
    effects.enter('resourceMarker');
    effects.consume(code);
    effects.exit('resourceMarker');
    return resourceBefore
  }

  /**
   * In resource, after `(`, at optional whitespace.
   *
   * ```markdown
   * > | [a](b) c
   *         ^
   * ```
   *
   * @type {State}
   */
  function resourceBefore(code) {
    return markdownLineEndingOrSpace(code)
      ? factoryWhitespace(effects, resourceOpen)(code)
      : resourceOpen(code)
  }

  /**
   * In resource, after optional whitespace, at `)` or a destination.
   *
   * ```markdown
   * > | [a](b) c
   *         ^
   * ```
   *
   * @type {State}
   */
  function resourceOpen(code) {
    if (code === 41) {
      return resourceEnd(code)
    }
    return factoryDestination(
      effects,
      resourceDestinationAfter,
      resourceDestinationMissing,
      'resourceDestination',
      'resourceDestinationLiteral',
      'resourceDestinationLiteralMarker',
      'resourceDestinationRaw',
      'resourceDestinationString',
      32
    )(code)
  }

  /**
   * In resource, after destination, at optional whitespace.
   *
   * ```markdown
   * > | [a](b) c
   *          ^
   * ```
   *
   * @type {State}
   */
  function resourceDestinationAfter(code) {
    return markdownLineEndingOrSpace(code)
      ? factoryWhitespace(effects, resourceBetween)(code)
      : resourceEnd(code)
  }

  /**
   * At invalid destination.
   *
   * ```markdown
   * > | [a](<<) b
   *         ^
   * ```
   *
   * @type {State}
   */
  function resourceDestinationMissing(code) {
    return nok(code)
  }

  /**
   * In resource, after destination and whitespace, at `(` or title.
   *
   * ```markdown
   * > | [a](b ) c
   *           ^
   * ```
   *
   * @type {State}
   */
  function resourceBetween(code) {
    if (code === 34 || code === 39 || code === 40) {
      return factoryTitle(
        effects,
        resourceTitleAfter,
        nok,
        'resourceTitle',
        'resourceTitleMarker',
        'resourceTitleString'
      )(code)
    }
    return resourceEnd(code)
  }

  /**
   * In resource, after title, at optional whitespace.
   *
   * ```markdown
   * > | [a](b "c") d
   *              ^
   * ```
   *
   * @type {State}
   */
  function resourceTitleAfter(code) {
    return markdownLineEndingOrSpace(code)
      ? factoryWhitespace(effects, resourceEnd)(code)
      : resourceEnd(code)
  }

  /**
   * In resource, at `)`.
   *
   * ```markdown
   * > | [a](b) d
   *          ^
   * ```
   *
   * @type {State}
   */
  function resourceEnd(code) {
    if (code === 41) {
      effects.enter('resourceMarker');
      effects.consume(code);
      effects.exit('resourceMarker');
      effects.exit('resource');
      return ok
    }
    return nok(code)
  }
}

/**
 * @this {TokenizeContext}
 * @type {Tokenizer}
 */
function tokenizeReferenceFull(effects, ok, nok) {
  const self = this;
  return referenceFull

  /**
   * In a reference (full), at the `[`.
   *
   * ```markdown
   * > | [a][b] d
   *        ^
   * ```
   *
   * @type {State}
   */
  function referenceFull(code) {
    return factoryLabel.call(
      self,
      effects,
      referenceFullAfter,
      referenceFullMissing,
      'reference',
      'referenceMarker',
      'referenceString'
    )(code)
  }

  /**
   * In a reference (full), after `]`.
   *
   * ```markdown
   * > | [a][b] d
   *          ^
   * ```
   *
   * @type {State}
   */
  function referenceFullAfter(code) {
    return self.parser.defined.includes(
      normalizeIdentifier(
        self.sliceSerialize(self.events[self.events.length - 1][1]).slice(1, -1)
      )
    )
      ? ok(code)
      : nok(code)
  }

  /**
   * In reference (full) that was missing.
   *
   * ```markdown
   * > | [a][b d
   *        ^
   * ```
   *
   * @type {State}
   */
  function referenceFullMissing(code) {
    return nok(code)
  }
}

/**
 * @this {TokenizeContext}
 * @type {Tokenizer}
 */
function tokenizeReferenceCollapsed(effects, ok, nok) {
  return referenceCollapsedStart

  /**
   * In reference (collapsed), at `[`.
   *
   * > 👉 **Note**: we only get here if the label is defined.
   *
   * ```markdown
   * > | [a][] d
   *        ^
   * ```
   *
   * @type {State}
   */
  function referenceCollapsedStart(code) {
    // We only attempt a collapsed label if there’s a `[`.

    effects.enter('reference');
    effects.enter('referenceMarker');
    effects.consume(code);
    effects.exit('referenceMarker');
    return referenceCollapsedOpen
  }

  /**
   * In reference (collapsed), at `]`.
   *
   * > 👉 **Note**: we only get here if the label is defined.
   *
   * ```markdown
   * > | [a][] d
   *         ^
   * ```
   *
   *  @type {State}
   */
  function referenceCollapsedOpen(code) {
    if (code === 93) {
      effects.enter('referenceMarker');
      effects.consume(code);
      effects.exit('referenceMarker');
      effects.exit('reference');
      return ok
    }
    return nok(code)
  }
}

/**
 * @typedef {import('micromark-util-types').Construct} Construct
 * @typedef {import('micromark-util-types').State} State
 * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext
 * @typedef {import('micromark-util-types').Tokenizer} Tokenizer
 */


/** @type {Construct} */
const labelStartImage = {
  name: 'labelStartImage',
  tokenize: tokenizeLabelStartImage,
  resolveAll: labelEnd.resolveAll
};

/**
 * @this {TokenizeContext}
 * @type {Tokenizer}
 */
function tokenizeLabelStartImage(effects, ok, nok) {
  const self = this;
  return start

  /**
   * Start of label (image) start.
   *
   * ```markdown
   * > | a ![b] c
   *       ^
   * ```
   *
   * @type {State}
   */
  function start(code) {
    effects.enter('labelImage');
    effects.enter('labelImageMarker');
    effects.consume(code);
    effects.exit('labelImageMarker');
    return open
  }

  /**
   * After `!`, at `[`.
   *
   * ```markdown
   * > | a ![b] c
   *        ^
   * ```
   *
   * @type {State}
   */
  function open(code) {
    if (code === 91) {
      effects.enter('labelMarker');
      effects.consume(code);
      effects.exit('labelMarker');
      effects.exit('labelImage');
      return after
    }
    return nok(code)
  }

  /**
   * After `![`.
   *
   * ```markdown
   * > | a ![b] c
   *         ^
   * ```
   *
   * This is needed in because, when GFM footnotes are enabled, images never
   * form when started with a `^`.
   * Instead, links form:
   *
   * ```markdown
   * ![^a](b)
   *
   * ![^a][b]
   *
   * [b]: c
   * ```
   *
   * ```html
   * <p>!<a href=\"b\">^a</a></p>
   * <p>!<a href=\"c\">^a</a></p>
   * ```
   *
   * @type {State}
   */
  function after(code) {
    // To do: use a new field to do this, this is still needed for
    // `micromark-extension-gfm-footnote`, but the `label-start-link`
    // behavior isn’t.
    // Hidden footnotes hook.
    /* c8 ignore next 3 */
    return code === 94 && '_hiddenFootnoteSupport' in self.parser.constructs
      ? nok(code)
      : ok(code)
  }
}

/**
 * @typedef {import('micromark-util-types').Construct} Construct
 * @typedef {import('micromark-util-types').State} State
 * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext
 * @typedef {import('micromark-util-types').Tokenizer} Tokenizer
 */


/** @type {Construct} */
const labelStartLink = {
  name: 'labelStartLink',
  tokenize: tokenizeLabelStartLink,
  resolveAll: labelEnd.resolveAll
};

/**
 * @this {TokenizeContext}
 * @type {Tokenizer}
 */
function tokenizeLabelStartLink(effects, ok, nok) {
  const self = this;
  return start

  /**
   * Start of label (link) start.
   *
   * ```markdown
   * > | a [b] c
   *       ^
   * ```
   *
   * @type {State}
   */
  function start(code) {
    effects.enter('labelLink');
    effects.enter('labelMarker');
    effects.consume(code);
    effects.exit('labelMarker');
    effects.exit('labelLink');
    return after
  }

  /** @type {State} */
  function after(code) {
    // To do: this isn’t needed in `micromark-extension-gfm-footnote`,
    // remove.
    // Hidden footnotes hook.
    /* c8 ignore next 3 */
    return code === 94 && '_hiddenFootnoteSupport' in self.parser.constructs
      ? nok(code)
      : ok(code)
  }
}

/**
 * @typedef {import('micromark-util-types').Construct} Construct
 * @typedef {import('micromark-util-types').State} State
 * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext
 * @typedef {import('micromark-util-types').Tokenizer} Tokenizer
 */

/** @type {Construct} */
const lineEnding = {
  name: 'lineEnding',
  tokenize: tokenizeLineEnding
};

/**
 * @this {TokenizeContext}
 * @type {Tokenizer}
 */
function tokenizeLineEnding(effects, ok) {
  return start

  /** @type {State} */
  function start(code) {
    effects.enter('lineEnding');
    effects.consume(code);
    effects.exit('lineEnding');
    return factorySpace(effects, ok, 'linePrefix')
  }
}

/**
 * @typedef {import('micromark-util-types').Code} Code
 * @typedef {import('micromark-util-types').Construct} Construct
 * @typedef {import('micromark-util-types').State} State
 * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext
 * @typedef {import('micromark-util-types').Tokenizer} Tokenizer
 */

/** @type {Construct} */
const thematicBreak$1 = {
  name: 'thematicBreak',
  tokenize: tokenizeThematicBreak
};

/**
 * @this {TokenizeContext}
 * @type {Tokenizer}
 */
function tokenizeThematicBreak(effects, ok, nok) {
  let size = 0;
  /** @type {NonNullable<Code>} */
  let marker;
  return start

  /**
   * Start of thematic break.
   *
   * ```markdown
   * > | ***
   *     ^
   * ```
   *
   * @type {State}
   */
  function start(code) {
    effects.enter('thematicBreak');
    // To do: parse indent like `markdown-rs`.
    return before(code)
  }

  /**
   * After optional whitespace, at marker.
   *
   * ```markdown
   * > | ***
   *     ^
   * ```
   *
   * @type {State}
   */
  function before(code) {
    marker = code;
    return atBreak(code)
  }

  /**
   * After something, before something else.
   *
   * ```markdown
   * > | ***
   *     ^
   * ```
   *
   * @type {State}
   */
  function atBreak(code) {
    if (code === marker) {
      effects.enter('thematicBreakSequence');
      return sequence(code)
    }
    if (size >= 3 && (code === null || markdownLineEnding(code))) {
      effects.exit('thematicBreak');
      return ok(code)
    }
    return nok(code)
  }

  /**
   * In sequence.
   *
   * ```markdown
   * > | ***
   *     ^
   * ```
   *
   * @type {State}
   */
  function sequence(code) {
    if (code === marker) {
      effects.consume(code);
      size++;
      return sequence
    }
    effects.exit('thematicBreakSequence');
    return markdownSpace(code)
      ? factorySpace(effects, atBreak, 'whitespace')(code)
      : atBreak(code)
  }
}

/**
 * @typedef {import('micromark-util-types').Code} Code
 * @typedef {import('micromark-util-types').Construct} Construct
 * @typedef {import('micromark-util-types').ContainerState} ContainerState
 * @typedef {import('micromark-util-types').Exiter} Exiter
 * @typedef {import('micromark-util-types').State} State
 * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext
 * @typedef {import('micromark-util-types').Tokenizer} Tokenizer
 */


/** @type {Construct} */
const list$1 = {
  name: 'list',
  tokenize: tokenizeListStart,
  continuation: {
    tokenize: tokenizeListContinuation
  },
  exit: tokenizeListEnd
};

/** @type {Construct} */
const listItemPrefixWhitespaceConstruct = {
  tokenize: tokenizeListItemPrefixWhitespace,
  partial: true
};

/** @type {Construct} */
const indentConstruct = {
  tokenize: tokenizeIndent$1,
  partial: true
};

// To do: `markdown-rs` parses list items on their own and later stitches them
// together.

/**
 * @type {Tokenizer}
 * @this {TokenizeContext}
 */
function tokenizeListStart(effects, ok, nok) {
  const self = this;
  const tail = self.events[self.events.length - 1];
  let initialSize =
    tail && tail[1].type === 'linePrefix'
      ? tail[2].sliceSerialize(tail[1], true).length
      : 0;
  let size = 0;
  return start

  /** @type {State} */
  function start(code) {
    const kind =
      self.containerState.type ||
      (code === 42 || code === 43 || code === 45
        ? 'listUnordered'
        : 'listOrdered');
    if (
      kind === 'listUnordered'
        ? !self.containerState.marker || code === self.containerState.marker
        : asciiDigit(code)
    ) {
      if (!self.containerState.type) {
        self.containerState.type = kind;
        effects.enter(kind, {
          _container: true
        });
      }
      if (kind === 'listUnordered') {
        effects.enter('listItemPrefix');
        return code === 42 || code === 45
          ? effects.check(thematicBreak$1, nok, atMarker)(code)
          : atMarker(code)
      }
      if (!self.interrupt || code === 49) {
        effects.enter('listItemPrefix');
        effects.enter('listItemValue');
        return inside(code)
      }
    }
    return nok(code)
  }

  /** @type {State} */
  function inside(code) {
    if (asciiDigit(code) && ++size < 10) {
      effects.consume(code);
      return inside
    }
    if (
      (!self.interrupt || size < 2) &&
      (self.containerState.marker
        ? code === self.containerState.marker
        : code === 41 || code === 46)
    ) {
      effects.exit('listItemValue');
      return atMarker(code)
    }
    return nok(code)
  }

  /**
   * @type {State}
   **/
  function atMarker(code) {
    effects.enter('listItemMarker');
    effects.consume(code);
    effects.exit('listItemMarker');
    self.containerState.marker = self.containerState.marker || code;
    return effects.check(
      blankLine,
      // Can’t be empty when interrupting.
      self.interrupt ? nok : onBlank,
      effects.attempt(
        listItemPrefixWhitespaceConstruct,
        endOfPrefix,
        otherPrefix
      )
    )
  }

  /** @type {State} */
  function onBlank(code) {
    self.containerState.initialBlankLine = true;
    initialSize++;
    return endOfPrefix(code)
  }

  /** @type {State} */
  function otherPrefix(code) {
    if (markdownSpace(code)) {
      effects.enter('listItemPrefixWhitespace');
      effects.consume(code);
      effects.exit('listItemPrefixWhitespace');
      return endOfPrefix
    }
    return nok(code)
  }

  /** @type {State} */
  function endOfPrefix(code) {
    self.containerState.size =
      initialSize +
      self.sliceSerialize(effects.exit('listItemPrefix'), true).length;
    return ok(code)
  }
}

/**
 * @type {Tokenizer}
 * @this {TokenizeContext}
 */
function tokenizeListContinuation(effects, ok, nok) {
  const self = this;
  self.containerState._closeFlow = undefined;
  return effects.check(blankLine, onBlank, notBlank)

  /** @type {State} */
  function onBlank(code) {
    self.containerState.furtherBlankLines =
      self.containerState.furtherBlankLines ||
      self.containerState.initialBlankLine;

    // We have a blank line.
    // Still, try to consume at most the items size.
    return factorySpace(
      effects,
      ok,
      'listItemIndent',
      self.containerState.size + 1
    )(code)
  }

  /** @type {State} */
  function notBlank(code) {
    if (self.containerState.furtherBlankLines || !markdownSpace(code)) {
      self.containerState.furtherBlankLines = undefined;
      self.containerState.initialBlankLine = undefined;
      return notInCurrentItem(code)
    }
    self.containerState.furtherBlankLines = undefined;
    self.containerState.initialBlankLine = undefined;
    return effects.attempt(indentConstruct, ok, notInCurrentItem)(code)
  }

  /** @type {State} */
  function notInCurrentItem(code) {
    // While we do continue, we signal that the flow should be closed.
    self.containerState._closeFlow = true;
    // As we’re closing flow, we’re no longer interrupting.
    self.interrupt = undefined;
    // Always populated by defaults.

    return factorySpace(
      effects,
      effects.attempt(list$1, ok, nok),
      'linePrefix',
      self.parser.constructs.disable.null.includes('codeIndented')
        ? undefined
        : 4
    )(code)
  }
}

/**
 * @type {Tokenizer}
 * @this {TokenizeContext}
 */
function tokenizeIndent$1(effects, ok, nok) {
  const self = this;
  return factorySpace(
    effects,
    afterPrefix,
    'listItemIndent',
    self.containerState.size + 1
  )

  /** @type {State} */
  function afterPrefix(code) {
    const tail = self.events[self.events.length - 1];
    return tail &&
      tail[1].type === 'listItemIndent' &&
      tail[2].sliceSerialize(tail[1], true).length === self.containerState.size
      ? ok(code)
      : nok(code)
  }
}

/**
 * @type {Exiter}
 * @this {TokenizeContext}
 */
function tokenizeListEnd(effects) {
  effects.exit(this.containerState.type);
}

/**
 * @type {Tokenizer}
 * @this {TokenizeContext}
 */
function tokenizeListItemPrefixWhitespace(effects, ok, nok) {
  const self = this;

  // Always populated by defaults.

  return factorySpace(
    effects,
    afterPrefix,
    'listItemPrefixWhitespace',
    self.parser.constructs.disable.null.includes('codeIndented')
      ? undefined
      : 4 + 1
  )

  /** @type {State} */
  function afterPrefix(code) {
    const tail = self.events[self.events.length - 1];
    return !markdownSpace(code) &&
      tail &&
      tail[1].type === 'listItemPrefixWhitespace'
      ? ok(code)
      : nok(code)
  }
}

/**
 * @typedef {import('micromark-util-types').Code} Code
 * @typedef {import('micromark-util-types').Construct} Construct
 * @typedef {import('micromark-util-types').Resolver} Resolver
 * @typedef {import('micromark-util-types').State} State
 * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext
 * @typedef {import('micromark-util-types').Tokenizer} Tokenizer
 */

/** @type {Construct} */
const setextUnderline = {
  name: 'setextUnderline',
  tokenize: tokenizeSetextUnderline,
  resolveTo: resolveToSetextUnderline
};

/** @type {Resolver} */
function resolveToSetextUnderline(events, context) {
  // To do: resolve like `markdown-rs`.
  let index = events.length;
  /** @type {number | undefined} */
  let content;
  /** @type {number | undefined} */
  let text;
  /** @type {number | undefined} */
  let definition;

  // Find the opening of the content.
  // It’ll always exist: we don’t tokenize if it isn’t there.
  while (index--) {
    if (events[index][0] === 'enter') {
      if (events[index][1].type === 'content') {
        content = index;
        break
      }
      if (events[index][1].type === 'paragraph') {
        text = index;
      }
    }
    // Exit
    else {
      if (events[index][1].type === 'content') {
        // Remove the content end (if needed we’ll add it later)
        events.splice(index, 1);
      }
      if (!definition && events[index][1].type === 'definition') {
        definition = index;
      }
    }
  }
  const heading = {
    type: 'setextHeading',
    start: Object.assign({}, events[text][1].start),
    end: Object.assign({}, events[events.length - 1][1].end)
  };

  // Change the paragraph to setext heading text.
  events[text][1].type = 'setextHeadingText';

  // If we have definitions in the content, we’ll keep on having content,
  // but we need move it.
  if (definition) {
    events.splice(text, 0, ['enter', heading, context]);
    events.splice(definition + 1, 0, ['exit', events[content][1], context]);
    events[content][1].end = Object.assign({}, events[definition][1].end);
  } else {
    events[content][1] = heading;
  }

  // Add the heading exit at the end.
  events.push(['exit', heading, context]);
  return events
}

/**
 * @this {TokenizeContext}
 * @type {Tokenizer}
 */
function tokenizeSetextUnderline(effects, ok, nok) {
  const self = this;
  /** @type {NonNullable<Code>} */
  let marker;
  return start

  /**
   * At start of heading (setext) underline.
   *
   * ```markdown
   *   | aa
   * > | ==
   *     ^
   * ```
   *
   * @type {State}
   */
  function start(code) {
    let index = self.events.length;
    /** @type {boolean | undefined} */
    let paragraph;
    // Find an opening.
    while (index--) {
      // Skip enter/exit of line ending, line prefix, and content.
      // We can now either have a definition or a paragraph.
      if (
        self.events[index][1].type !== 'lineEnding' &&
        self.events[index][1].type !== 'linePrefix' &&
        self.events[index][1].type !== 'content'
      ) {
        paragraph = self.events[index][1].type === 'paragraph';
        break
      }
    }

    // To do: handle lazy/pierce like `markdown-rs`.
    // To do: parse indent like `markdown-rs`.
    if (!self.parser.lazy[self.now().line] && (self.interrupt || paragraph)) {
      effects.enter('setextHeadingLine');
      marker = code;
      return before(code)
    }
    return nok(code)
  }

  /**
   * After optional whitespace, at `-` or `=`.
   *
   * ```markdown
   *   | aa
   * > | ==
   *     ^
   * ```
   *
   * @type {State}
   */
  function before(code) {
    effects.enter('setextHeadingLineSequence');
    return inside(code)
  }

  /**
   * In sequence.
   *
   * ```markdown
   *   | aa
   * > | ==
   *     ^
   * ```
   *
   * @type {State}
   */
  function inside(code) {
    if (code === marker) {
      effects.consume(code);
      return inside
    }
    effects.exit('setextHeadingLineSequence');
    return markdownSpace(code)
      ? factorySpace(effects, after, 'lineSuffix')(code)
      : after(code)
  }

  /**
   * After sequence, after optional whitespace.
   *
   * ```markdown
   *   | aa
   * > | ==
   *       ^
   * ```
   *
   * @type {State}
   */
  function after(code) {
    if (code === null || markdownLineEnding(code)) {
      effects.exit('setextHeadingLine');
      return ok(code)
    }
    return nok(code)
  }
}

/**
 * @typedef {import('micromark-util-types').InitialConstruct} InitialConstruct
 * @typedef {import('micromark-util-types').Initializer} Initializer
 * @typedef {import('micromark-util-types').State} State
 * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext
 */

/** @type {InitialConstruct} */
const flow$1 = {
  tokenize: initializeFlow
};

/**
 * @this {TokenizeContext}
 * @type {Initializer}
 */
function initializeFlow(effects) {
  const self = this;
  const initial = effects.attempt(
    // Try to parse a blank line.
    blankLine,
    atBlankEnding,
    // Try to parse initial flow (essentially, only code).
    effects.attempt(
      this.parser.constructs.flowInitial,
      afterConstruct,
      factorySpace(
        effects,
        effects.attempt(
          this.parser.constructs.flow,
          afterConstruct,
          effects.attempt(content, afterConstruct)
        ),
        'linePrefix'
      )
    )
  );
  return initial

  /** @type {State} */
  function atBlankEnding(code) {
    if (code === null) {
      effects.consume(code);
      return
    }
    effects.enter('lineEndingBlank');
    effects.consume(code);
    effects.exit('lineEndingBlank');
    self.currentConstruct = undefined;
    return initial
  }

  /** @type {State} */
  function afterConstruct(code) {
    if (code === null) {
      effects.consume(code);
      return
    }
    effects.enter('lineEnding');
    effects.consume(code);
    effects.exit('lineEnding');
    self.currentConstruct = undefined;
    return initial
  }
}

/**
 * @typedef {import('micromark-util-types').Code} Code
 * @typedef {import('micromark-util-types').InitialConstruct} InitialConstruct
 * @typedef {import('micromark-util-types').Initializer} Initializer
 * @typedef {import('micromark-util-types').Resolver} Resolver
 * @typedef {import('micromark-util-types').State} State
 * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext
 */

const resolver = {
  resolveAll: createResolver()
};
const string$1 = initializeFactory('string');
const text$3 = initializeFactory('text');

/**
 * @param {'string' | 'text'} field
 * @returns {InitialConstruct}
 */
function initializeFactory(field) {
  return {
    tokenize: initializeText,
    resolveAll: createResolver(
      field === 'text' ? resolveAllLineSuffixes : undefined
    )
  }

  /**
   * @this {TokenizeContext}
   * @type {Initializer}
   */
  function initializeText(effects) {
    const self = this;
    const constructs = this.parser.constructs[field];
    const text = effects.attempt(constructs, start, notText);
    return start

    /** @type {State} */
    function start(code) {
      return atBreak(code) ? text(code) : notText(code)
    }

    /** @type {State} */
    function notText(code) {
      if (code === null) {
        effects.consume(code);
        return
      }
      effects.enter('data');
      effects.consume(code);
      return data
    }

    /** @type {State} */
    function data(code) {
      if (atBreak(code)) {
        effects.exit('data');
        return text(code)
      }

      // Data.
      effects.consume(code);
      return data
    }

    /**
     * @param {Code} code
     * @returns {boolean}
     */
    function atBreak(code) {
      if (code === null) {
        return true
      }
      const list = constructs[code];
      let index = -1;
      if (list) {
        // Always populated by defaults.

        while (++index < list.length) {
          const item = list[index];
          if (!item.previous || item.previous.call(self, self.previous)) {
            return true
          }
        }
      }
      return false
    }
  }
}

/**
 * @param {Resolver | undefined} [extraResolver]
 * @returns {Resolver}
 */
function createResolver(extraResolver) {
  return resolveAllText

  /** @type {Resolver} */
  function resolveAllText(events, context) {
    let index = -1;
    /** @type {number | undefined} */
    let enter;

    // A rather boring computation (to merge adjacent `data` events) which
    // improves mm performance by 29%.
    while (++index <= events.length) {
      if (enter === undefined) {
        if (events[index] && events[index][1].type === 'data') {
          enter = index;
          index++;
        }
      } else if (!events[index] || events[index][1].type !== 'data') {
        // Don’t do anything if there is one data token.
        if (index !== enter + 2) {
          events[enter][1].end = events[index - 1][1].end;
          events.splice(enter + 2, index - enter - 2);
          index = enter + 2;
        }
        enter = undefined;
      }
    }
    return extraResolver ? extraResolver(events, context) : events
  }
}

/**
 * A rather ugly set of instructions which again looks at chunks in the input
 * stream.
 * The reason to do this here is that it is *much* faster to parse in reverse.
 * And that we can’t hook into `null` to split the line suffix before an EOF.
 * To do: figure out if we can make this into a clean utility, or even in core.
 * As it will be useful for GFMs literal autolink extension (and maybe even
 * tables?)
 *
 * @type {Resolver}
 */
function resolveAllLineSuffixes(events, context) {
  let eventIndex = 0; // Skip first.

  while (++eventIndex <= events.length) {
    if (
      (eventIndex === events.length ||
        events[eventIndex][1].type === 'lineEnding') &&
      events[eventIndex - 1][1].type === 'data'
    ) {
      const data = events[eventIndex - 1][1];
      const chunks = context.sliceStream(data);
      let index = chunks.length;
      let bufferIndex = -1;
      let size = 0;
      /** @type {boolean | undefined} */
      let tabs;
      while (index--) {
        const chunk = chunks[index];
        if (typeof chunk === 'string') {
          bufferIndex = chunk.length;
          while (chunk.charCodeAt(bufferIndex - 1) === 32) {
            size++;
            bufferIndex--;
          }
          if (bufferIndex) break
          bufferIndex = -1;
        }
        // Number
        else if (chunk === -2) {
          tabs = true;
          size++;
        } else if (chunk === -1) ; else {
          // Replacement character, exit.
          index++;
          break
        }
      }
      if (size) {
        const token = {
          type:
            eventIndex === events.length || tabs || size < 2
              ? 'lineSuffix'
              : 'hardBreakTrailing',
          start: {
            line: data.end.line,
            column: data.end.column - size,
            offset: data.end.offset - size,
            _index: data.start._index + index,
            _bufferIndex: index
              ? bufferIndex
              : data.start._bufferIndex + bufferIndex
          },
          end: Object.assign({}, data.end)
        };
        data.end = Object.assign({}, token.start);
        if (data.start.offset === data.end.offset) {
          Object.assign(data, token);
        } else {
          events.splice(
            eventIndex,
            0,
            ['enter', token, context],
            ['exit', token, context]
          );
          eventIndex += 2;
        }
      }
      eventIndex++;
    }
  }
  return events
}

/**
 * @typedef {import('micromark-util-types').Chunk} Chunk
 * @typedef {import('micromark-util-types').Code} Code
 * @typedef {import('micromark-util-types').Construct} Construct
 * @typedef {import('micromark-util-types').ConstructRecord} ConstructRecord
 * @typedef {import('micromark-util-types').Effects} Effects
 * @typedef {import('micromark-util-types').InitialConstruct} InitialConstruct
 * @typedef {import('micromark-util-types').ParseContext} ParseContext
 * @typedef {import('micromark-util-types').Point} Point
 * @typedef {import('micromark-util-types').State} State
 * @typedef {import('micromark-util-types').Token} Token
 * @typedef {import('micromark-util-types').TokenType} TokenType
 * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext
 */

/**
 * Create a tokenizer.
 * Tokenizers deal with one type of data (e.g., containers, flow, text).
 * The parser is the object dealing with it all.
 * `initialize` works like other constructs, except that only its `tokenize`
 * function is used, in which case it doesn’t receive an `ok` or `nok`.
 * `from` can be given to set the point before the first character, although
 * when further lines are indented, they must be set with `defineSkip`.
 *
 * @param {ParseContext} parser
 * @param {InitialConstruct} initialize
 * @param {Omit<Point, '_bufferIndex' | '_index'> | undefined} [from]
 * @returns {TokenizeContext}
 */
function createTokenizer(parser, initialize, from) {
  /** @type {Point} */
  let point = Object.assign(
    from
      ? Object.assign({}, from)
      : {
          line: 1,
          column: 1,
          offset: 0
        },
    {
      _index: 0,
      _bufferIndex: -1
    }
  );
  /** @type {Record<string, number>} */
  const columnStart = {};
  /** @type {Array<Construct>} */
  const resolveAllConstructs = [];
  /** @type {Array<Chunk>} */
  let chunks = [];
  /** @type {Array<Token>} */
  let stack = [];

  /**
   * Tools used for tokenizing.
   *
   * @type {Effects}
   */
  const effects = {
    consume,
    enter,
    exit,
    attempt: constructFactory(onsuccessfulconstruct),
    check: constructFactory(onsuccessfulcheck),
    interrupt: constructFactory(onsuccessfulcheck, {
      interrupt: true
    })
  };

  /**
   * State and tools for resolving and serializing.
   *
   * @type {TokenizeContext}
   */
  const context = {
    previous: null,
    code: null,
    containerState: {},
    events: [],
    parser,
    sliceStream,
    sliceSerialize,
    now,
    defineSkip,
    write
  };

  /**
   * The state function.
   *
   * @type {State | void}
   */
  let state = initialize.tokenize.call(context, effects);
  if (initialize.resolveAll) {
    resolveAllConstructs.push(initialize);
  }
  return context

  /** @type {TokenizeContext['write']} */
  function write(slice) {
    chunks = push(chunks, slice);
    main();

    // Exit if we’re not done, resolve might change stuff.
    if (chunks[chunks.length - 1] !== null) {
      return []
    }
    addResult(initialize, 0);

    // Otherwise, resolve, and exit.
    context.events = resolveAll(resolveAllConstructs, context.events, context);
    return context.events
  }

  //
  // Tools.
  //

  /** @type {TokenizeContext['sliceSerialize']} */
  function sliceSerialize(token, expandTabs) {
    return serializeChunks(sliceStream(token), expandTabs)
  }

  /** @type {TokenizeContext['sliceStream']} */
  function sliceStream(token) {
    return sliceChunks(chunks, token)
  }

  /** @type {TokenizeContext['now']} */
  function now() {
    // This is a hot path, so we clone manually instead of `Object.assign({}, point)`
    const {line, column, offset, _index, _bufferIndex} = point;
    return {
      line,
      column,
      offset,
      _index,
      _bufferIndex
    }
  }

  /** @type {TokenizeContext['defineSkip']} */
  function defineSkip(value) {
    columnStart[value.line] = value.column;
    accountForPotentialSkip();
  }

  //
  // State management.
  //

  /**
   * Main loop (note that `_index` and `_bufferIndex` in `point` are modified by
   * `consume`).
   * Here is where we walk through the chunks, which either include strings of
   * several characters, or numerical character codes.
   * The reason to do this in a loop instead of a call is so the stack can
   * drain.
   *
   * @returns {void}
   */
  function main() {
    /** @type {number} */
    let chunkIndex;
    while (point._index < chunks.length) {
      const chunk = chunks[point._index];

      // If we’re in a buffer chunk, loop through it.
      if (typeof chunk === 'string') {
        chunkIndex = point._index;
        if (point._bufferIndex < 0) {
          point._bufferIndex = 0;
        }
        while (
          point._index === chunkIndex &&
          point._bufferIndex < chunk.length
        ) {
          go(chunk.charCodeAt(point._bufferIndex));
        }
      } else {
        go(chunk);
      }
    }
  }

  /**
   * Deal with one code.
   *
   * @param {Code} code
   * @returns {void}
   */
  function go(code) {
    state = state(code);
  }

  /** @type {Effects['consume']} */
  function consume(code) {
    if (markdownLineEnding(code)) {
      point.line++;
      point.column = 1;
      point.offset += code === -3 ? 2 : 1;
      accountForPotentialSkip();
    } else if (code !== -1) {
      point.column++;
      point.offset++;
    }

    // Not in a string chunk.
    if (point._bufferIndex < 0) {
      point._index++;
    } else {
      point._bufferIndex++;

      // At end of string chunk.
      // @ts-expect-error Points w/ non-negative `_bufferIndex` reference
      // strings.
      if (point._bufferIndex === chunks[point._index].length) {
        point._bufferIndex = -1;
        point._index++;
      }
    }

    // Expose the previous character.
    context.previous = code;
  }

  /** @type {Effects['enter']} */
  function enter(type, fields) {
    /** @type {Token} */
    // @ts-expect-error Patch instead of assign required fields to help GC.
    const token = fields || {};
    token.type = type;
    token.start = now();
    context.events.push(['enter', token, context]);
    stack.push(token);
    return token
  }

  /** @type {Effects['exit']} */
  function exit(type) {
    const token = stack.pop();
    token.end = now();
    context.events.push(['exit', token, context]);
    return token
  }

  /**
   * Use results.
   *
   * @type {ReturnHandle}
   */
  function onsuccessfulconstruct(construct, info) {
    addResult(construct, info.from);
  }

  /**
   * Discard results.
   *
   * @type {ReturnHandle}
   */
  function onsuccessfulcheck(_, info) {
    info.restore();
  }

  /**
   * Factory to attempt/check/interrupt.
   *
   * @param {ReturnHandle} onreturn
   * @param {{interrupt?: boolean | undefined} | undefined} [fields]
   */
  function constructFactory(onreturn, fields) {
    return hook

    /**
     * Handle either an object mapping codes to constructs, a list of
     * constructs, or a single construct.
     *
     * @param {Array<Construct> | Construct | ConstructRecord} constructs
     * @param {State} returnState
     * @param {State | undefined} [bogusState]
     * @returns {State}
     */
    function hook(constructs, returnState, bogusState) {
      /** @type {Array<Construct>} */
      let listOfConstructs;
      /** @type {number} */
      let constructIndex;
      /** @type {Construct} */
      let currentConstruct;
      /** @type {Info} */
      let info;
      return Array.isArray(constructs) /* c8 ignore next 1 */
        ? handleListOfConstructs(constructs)
        : 'tokenize' in constructs
        ? // @ts-expect-error Looks like a construct.
          handleListOfConstructs([constructs])
        : handleMapOfConstructs(constructs)

      /**
       * Handle a list of construct.
       *
       * @param {ConstructRecord} map
       * @returns {State}
       */
      function handleMapOfConstructs(map) {
        return start

        /** @type {State} */
        function start(code) {
          const def = code !== null && map[code];
          const all = code !== null && map.null;
          const list = [
            // To do: add more extension tests.
            /* c8 ignore next 2 */
            ...(Array.isArray(def) ? def : def ? [def] : []),
            ...(Array.isArray(all) ? all : all ? [all] : [])
          ];
          return handleListOfConstructs(list)(code)
        }
      }

      /**
       * Handle a list of construct.
       *
       * @param {Array<Construct>} list
       * @returns {State}
       */
      function handleListOfConstructs(list) {
        listOfConstructs = list;
        constructIndex = 0;
        if (list.length === 0) {
          return bogusState
        }
        return handleConstruct(list[constructIndex])
      }

      /**
       * Handle a single construct.
       *
       * @param {Construct} construct
       * @returns {State}
       */
      function handleConstruct(construct) {
        return start

        /** @type {State} */
        function start(code) {
          // To do: not needed to store if there is no bogus state, probably?
          // Currently doesn’t work because `inspect` in document does a check
          // w/o a bogus, which doesn’t make sense. But it does seem to help perf
          // by not storing.
          info = store();
          currentConstruct = construct;
          if (!construct.partial) {
            context.currentConstruct = construct;
          }

          // Always populated by defaults.

          if (
            construct.name &&
            context.parser.constructs.disable.null.includes(construct.name)
          ) {
            return nok()
          }
          return construct.tokenize.call(
            // If we do have fields, create an object w/ `context` as its
            // prototype.
            // This allows a “live binding”, which is needed for `interrupt`.
            fields ? Object.assign(Object.create(context), fields) : context,
            effects,
            ok,
            nok
          )(code)
        }
      }

      /** @type {State} */
      function ok(code) {
        onreturn(currentConstruct, info);
        return returnState
      }

      /** @type {State} */
      function nok(code) {
        info.restore();
        if (++constructIndex < listOfConstructs.length) {
          return handleConstruct(listOfConstructs[constructIndex])
        }
        return bogusState
      }
    }
  }

  /**
   * @param {Construct} construct
   * @param {number} from
   * @returns {void}
   */
  function addResult(construct, from) {
    if (construct.resolveAll && !resolveAllConstructs.includes(construct)) {
      resolveAllConstructs.push(construct);
    }
    if (construct.resolve) {
      splice(
        context.events,
        from,
        context.events.length - from,
        construct.resolve(context.events.slice(from), context)
      );
    }
    if (construct.resolveTo) {
      context.events = construct.resolveTo(context.events, context);
    }
  }

  /**
   * Store state.
   *
   * @returns {Info}
   */
  function store() {
    const startPoint = now();
    const startPrevious = context.previous;
    const startCurrentConstruct = context.currentConstruct;
    const startEventsIndex = context.events.length;
    const startStack = Array.from(stack);
    return {
      restore,
      from: startEventsIndex
    }

    /**
     * Restore state.
     *
     * @returns {void}
     */
    function restore() {
      point = startPoint;
      context.previous = startPrevious;
      context.currentConstruct = startCurrentConstruct;
      context.events.length = startEventsIndex;
      stack = startStack;
      accountForPotentialSkip();
    }
  }

  /**
   * Move the current point a bit forward in the line when it’s on a column
   * skip.
   *
   * @returns {void}
   */
  function accountForPotentialSkip() {
    if (point.line in columnStart && point.column < 2) {
      point.column = columnStart[point.line];
      point.offset += columnStart[point.line] - 1;
    }
  }
}

/**
 * Get the chunks from a slice of chunks in the range of a token.
 *
 * @param {Array<Chunk>} chunks
 * @param {Pick<Token, 'end' | 'start'>} token
 * @returns {Array<Chunk>}
 */
function sliceChunks(chunks, token) {
  const startIndex = token.start._index;
  const startBufferIndex = token.start._bufferIndex;
  const endIndex = token.end._index;
  const endBufferIndex = token.end._bufferIndex;
  /** @type {Array<Chunk>} */
  let view;
  if (startIndex === endIndex) {
    // @ts-expect-error `_bufferIndex` is used on string chunks.
    view = [chunks[startIndex].slice(startBufferIndex, endBufferIndex)];
  } else {
    view = chunks.slice(startIndex, endIndex);
    if (startBufferIndex > -1) {
      const head = view[0];
      if (typeof head === 'string') {
        view[0] = head.slice(startBufferIndex);
      } else {
        view.shift();
      }
    }
    if (endBufferIndex > 0) {
      // @ts-expect-error `_bufferIndex` is used on string chunks.
      view.push(chunks[endIndex].slice(0, endBufferIndex));
    }
  }
  return view
}

/**
 * Get the string value of a slice of chunks.
 *
 * @param {Array<Chunk>} chunks
 * @param {boolean | undefined} [expandTabs=false]
 * @returns {string}
 */
function serializeChunks(chunks, expandTabs) {
  let index = -1;
  /** @type {Array<string>} */
  const result = [];
  /** @type {boolean | undefined} */
  let atTab;
  while (++index < chunks.length) {
    const chunk = chunks[index];
    /** @type {string} */
    let value;
    if (typeof chunk === 'string') {
      value = chunk;
    } else
      switch (chunk) {
        case -5: {
          value = '\r';
          break
        }
        case -4: {
          value = '\n';
          break
        }
        case -3: {
          value = '\r' + '\n';
          break
        }
        case -2: {
          value = expandTabs ? ' ' : '\t';
          break
        }
        case -1: {
          if (!expandTabs && atTab) continue
          value = ' ';
          break
        }
        default: {
          // Currently only replacement character.
          value = String.fromCharCode(chunk);
        }
      }
    atTab = chunk === -2;
    result.push(value);
  }
  return result.join('')
}

/**
 * @typedef {import('micromark-util-types').Extension} Extension
 */


/** @satisfies {Extension['document']} */
const document$1 = {
  [42]: list$1,
  [43]: list$1,
  [45]: list$1,
  [48]: list$1,
  [49]: list$1,
  [50]: list$1,
  [51]: list$1,
  [52]: list$1,
  [53]: list$1,
  [54]: list$1,
  [55]: list$1,
  [56]: list$1,
  [57]: list$1,
  [62]: blockQuote
};

/** @satisfies {Extension['contentInitial']} */
const contentInitial = {
  [91]: definition
};

/** @satisfies {Extension['flowInitial']} */
const flowInitial = {
  [-2]: codeIndented,
  [-1]: codeIndented,
  [32]: codeIndented
};

/** @satisfies {Extension['flow']} */
const flow = {
  [35]: headingAtx,
  [42]: thematicBreak$1,
  [45]: [setextUnderline, thematicBreak$1],
  [60]: htmlFlow,
  [61]: setextUnderline,
  [95]: thematicBreak$1,
  [96]: codeFenced,
  [126]: codeFenced
};

/** @satisfies {Extension['string']} */
const string = {
  [38]: characterReference,
  [92]: characterEscape
};

/** @satisfies {Extension['text']} */
const text$2 = {
  [-5]: lineEnding,
  [-4]: lineEnding,
  [-3]: lineEnding,
  [33]: labelStartImage,
  [38]: characterReference,
  [42]: attention,
  [60]: [autolink, htmlText],
  [91]: labelStartLink,
  [92]: [hardBreakEscape, characterEscape],
  [93]: labelEnd,
  [95]: attention,
  [96]: codeText
};

/** @satisfies {Extension['insideSpan']} */
const insideSpan = {
  null: [attention, resolver]
};

/** @satisfies {Extension['attentionMarkers']} */
const attentionMarkers = {
  null: [42, 95]
};

/** @satisfies {Extension['disable']} */
const disable = {
  null: []
};

var defaultConstructs = /*#__PURE__*/Object.freeze({
    __proto__: null,
    attentionMarkers: attentionMarkers,
    contentInitial: contentInitial,
    disable: disable,
    document: document$1,
    flow: flow,
    flowInitial: flowInitial,
    insideSpan: insideSpan,
    string: string,
    text: text$2
});

/**
 * @typedef {import('micromark-util-types').Create} Create
 * @typedef {import('micromark-util-types').FullNormalizedExtension} FullNormalizedExtension
 * @typedef {import('micromark-util-types').InitialConstruct} InitialConstruct
 * @typedef {import('micromark-util-types').ParseContext} ParseContext
 * @typedef {import('micromark-util-types').ParseOptions} ParseOptions
 */


/**
 * @param {ParseOptions | null | undefined} [options]
 * @returns {ParseContext}
 */
function parse$1(options) {
  const settings = options || {};
  const constructs =
    /** @type {FullNormalizedExtension} */
    combineExtensions([defaultConstructs, ...(settings.extensions || [])]);

  /** @type {ParseContext} */
  const parser = {
    defined: [],
    lazy: {},
    constructs,
    content: create(content$1),
    document: create(document$2),
    flow: create(flow$1),
    string: create(string$1),
    text: create(text$3)
  };
  return parser

  /**
   * @param {InitialConstruct} initial
   */
  function create(initial) {
    return creator
    /** @type {Create} */
    function creator(from) {
      return createTokenizer(parser, initial, from)
    }
  }
}

/**
 * @typedef {import('micromark-util-types').Chunk} Chunk
 * @typedef {import('micromark-util-types').Code} Code
 * @typedef {import('micromark-util-types').Encoding} Encoding
 * @typedef {import('micromark-util-types').Value} Value
 */

/**
 * @callback Preprocessor
 * @param {Value} value
 * @param {Encoding | null | undefined} [encoding]
 * @param {boolean | null | undefined} [end=false]
 * @returns {Array<Chunk>}
 */

const search = /[\0\t\n\r]/g;

/**
 * @returns {Preprocessor}
 */
function preprocess() {
  let column = 1;
  let buffer = '';
  /** @type {boolean | undefined} */
  let start = true;
  /** @type {boolean | undefined} */
  let atCarriageReturn;
  return preprocessor

  /** @type {Preprocessor} */
  function preprocessor(value, encoding, end) {
    /** @type {Array<Chunk>} */
    const chunks = [];
    /** @type {RegExpMatchArray | null} */
    let match;
    /** @type {number} */
    let next;
    /** @type {number} */
    let startPosition;
    /** @type {number} */
    let endPosition;
    /** @type {Code} */
    let code;

    // @ts-expect-error `Buffer` does allow an encoding.
    value = buffer + value.toString(encoding);
    startPosition = 0;
    buffer = '';
    if (start) {
      // To do: `markdown-rs` actually parses BOMs (byte order mark).
      if (value.charCodeAt(0) === 65279) {
        startPosition++;
      }
      start = undefined;
    }
    while (startPosition < value.length) {
      search.lastIndex = startPosition;
      match = search.exec(value);
      endPosition =
        match && match.index !== undefined ? match.index : value.length;
      code = value.charCodeAt(endPosition);
      if (!match) {
        buffer = value.slice(startPosition);
        break
      }
      if (code === 10 && startPosition === endPosition && atCarriageReturn) {
        chunks.push(-3);
        atCarriageReturn = undefined;
      } else {
        if (atCarriageReturn) {
          chunks.push(-5);
          atCarriageReturn = undefined;
        }
        if (startPosition < endPosition) {
          chunks.push(value.slice(startPosition, endPosition));
          column += endPosition - startPosition;
        }
        switch (code) {
          case 0: {
            chunks.push(65533);
            column++;
            break
          }
          case 9: {
            next = Math.ceil(column / 4) * 4;
            chunks.push(-2);
            while (column++ < next) chunks.push(-1);
            break
          }
          case 10: {
            chunks.push(-4);
            column = 1;
            break
          }
          default: {
            atCarriageReturn = true;
            column = 1;
          }
        }
      }
      startPosition = endPosition + 1;
    }
    if (end) {
      if (atCarriageReturn) chunks.push(-5);
      if (buffer) chunks.push(buffer);
      chunks.push(null);
    }
    return chunks
  }
}

/**
 * @typedef {import('micromark-util-types').Event} Event
 */


/**
 * @param {Array<Event>} events
 * @returns {Array<Event>}
 */
function postprocess(events) {
  while (!subtokenize(events)) {
    // Empty
  }
  return events
}

/**
 * Turn the number (in string form as either hexa- or plain decimal) coming from
 * a numeric character reference into a character.
 *
 * Sort of like `String.fromCharCode(Number.parseInt(value, base))`, but makes
 * non-characters and control characters safe.
 *
 * @param {string} value
 *   Value to decode.
 * @param {number} base
 *   Numeric base.
 * @returns {string}
 *   Character.
 */
function decodeNumericCharacterReference(value, base) {
  const code = Number.parseInt(value, base);
  if (
    // C0 except for HT, LF, FF, CR, space.
    code < 9 ||
    code === 11 ||
    (code > 13 && code < 32) ||
    // Control character (DEL) of C0, and C1 controls.
    (code > 126 && code < 160) ||
    // Lone high surrogates and low surrogates.
    (code > 55295 && code < 57344) ||
    // Noncharacters.
    (code > 64975 && code < 65008) /* eslint-disable no-bitwise */ ||
    (code & 65535) === 65535 ||
    (code & 65535) === 65534 /* eslint-enable no-bitwise */ ||
    // Out of range
    code > 1114111
  ) {
    return '\uFFFD'
  }
  return String.fromCharCode(code)
}

const characterEscapeOrReference =
  /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi;

/**
 * Decode markdown strings (which occur in places such as fenced code info
 * strings, destinations, labels, and titles).
 *
 * The “string” content type allows character escapes and -references.
 * This decodes those.
 *
 * @param {string} value
 *   Value to decode.
 * @returns {string}
 *   Decoded value.
 */
function decodeString(value) {
  return value.replace(characterEscapeOrReference, decode)
}

/**
 * @param {string} $0
 * @param {string} $1
 * @param {string} $2
 * @returns {string}
 */
function decode($0, $1, $2) {
  if ($1) {
    // Escape.
    return $1
  }

  // Reference.
  const head = $2.charCodeAt(0);
  if (head === 35) {
    const head = $2.charCodeAt(1);
    const hex = head === 120 || head === 88;
    return decodeNumericCharacterReference($2.slice(hex ? 2 : 1), hex ? 16 : 10)
  }
  return decodeNamedCharacterReference($2) || $0
}

/**
 * @typedef {import('micromark-util-types').Encoding} Encoding
 * @typedef {import('micromark-util-types').Event} Event
 * @typedef {import('micromark-util-types').ParseOptions} ParseOptions
 * @typedef {import('micromark-util-types').Token} Token
 * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext
 * @typedef {import('micromark-util-types').Value} Value
 *
 * @typedef {import('unist').Parent} UnistParent
 * @typedef {import('unist').Point} Point
 *
 * @typedef {import('mdast').PhrasingContent} PhrasingContent
 * @typedef {import('mdast').StaticPhrasingContent} StaticPhrasingContent
 * @typedef {import('mdast').Content} Content
 * @typedef {import('mdast').Break} Break
 * @typedef {import('mdast').Blockquote} Blockquote
 * @typedef {import('mdast').Code} Code
 * @typedef {import('mdast').Definition} Definition
 * @typedef {import('mdast').Emphasis} Emphasis
 * @typedef {import('mdast').Heading} Heading
 * @typedef {import('mdast').HTML} HTML
 * @typedef {import('mdast').Image} Image
 * @typedef {import('mdast').ImageReference} ImageReference
 * @typedef {import('mdast').InlineCode} InlineCode
 * @typedef {import('mdast').Link} Link
 * @typedef {import('mdast').LinkReference} LinkReference
 * @typedef {import('mdast').List} List
 * @typedef {import('mdast').ListItem} ListItem
 * @typedef {import('mdast').Paragraph} Paragraph
 * @typedef {import('mdast').Root} Root
 * @typedef {import('mdast').Strong} Strong
 * @typedef {import('mdast').Text} Text
 * @typedef {import('mdast').ThematicBreak} ThematicBreak
 * @typedef {import('mdast').ReferenceType} ReferenceType
 * @typedef {import('../index.js').CompileData} CompileData
 */

const own$6 = {}.hasOwnProperty;

/**
 * @param value
 *   Markdown to parse.
 * @param encoding
 *   Character encoding for when `value` is `Buffer`.
 * @param options
 *   Configuration.
 * @returns
 *   mdast tree.
 */
const fromMarkdown =
  /**
   * @type {(
   *   ((value: Value, encoding: Encoding, options?: Options | null | undefined) => Root) &
   *   ((value: Value, options?: Options | null | undefined) => Root)
   * )}
   */

  /**
   * @param {Value} value
   * @param {Encoding | Options | null | undefined} [encoding]
   * @param {Options | null | undefined} [options]
   * @returns {Root}
   */
  function (value, encoding, options) {
    if (typeof encoding !== 'string') {
      options = encoding;
      encoding = undefined;
    }
    return compiler(options)(
      postprocess(
        parse$1(options).document().write(preprocess()(value, encoding, true))
      )
    )
  };

/**
 * Note this compiler only understand complete buffering, not streaming.
 *
 * @param {Options | null | undefined} [options]
 */
function compiler(options) {
  /** @type {Config} */
  const config = {
    transforms: [],
    canContainEols: ['emphasis', 'fragment', 'heading', 'paragraph', 'strong'],
    enter: {
      autolink: opener(link),
      autolinkProtocol: onenterdata,
      autolinkEmail: onenterdata,
      atxHeading: opener(heading),
      blockQuote: opener(blockQuote),
      characterEscape: onenterdata,
      characterReference: onenterdata,
      codeFenced: opener(codeFlow),
      codeFencedFenceInfo: buffer,
      codeFencedFenceMeta: buffer,
      codeIndented: opener(codeFlow, buffer),
      codeText: opener(codeText, buffer),
      codeTextData: onenterdata,
      data: onenterdata,
      codeFlowValue: onenterdata,
      definition: opener(definition),
      definitionDestinationString: buffer,
      definitionLabelString: buffer,
      definitionTitleString: buffer,
      emphasis: opener(emphasis),
      hardBreakEscape: opener(hardBreak),
      hardBreakTrailing: opener(hardBreak),
      htmlFlow: opener(html, buffer),
      htmlFlowData: onenterdata,
      htmlText: opener(html, buffer),
      htmlTextData: onenterdata,
      image: opener(image),
      label: buffer,
      link: opener(link),
      listItem: opener(listItem),
      listItemValue: onenterlistitemvalue,
      listOrdered: opener(list, onenterlistordered),
      listUnordered: opener(list),
      paragraph: opener(paragraph),
      reference: onenterreference,
      referenceString: buffer,
      resourceDestinationString: buffer,
      resourceTitleString: buffer,
      setextHeading: opener(heading),
      strong: opener(strong),
      thematicBreak: opener(thematicBreak)
    },
    exit: {
      atxHeading: closer(),
      atxHeadingSequence: onexitatxheadingsequence,
      autolink: closer(),
      autolinkEmail: onexitautolinkemail,
      autolinkProtocol: onexitautolinkprotocol,
      blockQuote: closer(),
      characterEscapeValue: onexitdata,
      characterReferenceMarkerHexadecimal: onexitcharacterreferencemarker,
      characterReferenceMarkerNumeric: onexitcharacterreferencemarker,
      characterReferenceValue: onexitcharacterreferencevalue,
      codeFenced: closer(onexitcodefenced),
      codeFencedFence: onexitcodefencedfence,
      codeFencedFenceInfo: onexitcodefencedfenceinfo,
      codeFencedFenceMeta: onexitcodefencedfencemeta,
      codeFlowValue: onexitdata,
      codeIndented: closer(onexitcodeindented),
      codeText: closer(onexitcodetext),
      codeTextData: onexitdata,
      data: onexitdata,
      definition: closer(),
      definitionDestinationString: onexitdefinitiondestinationstring,
      definitionLabelString: onexitdefinitionlabelstring,
      definitionTitleString: onexitdefinitiontitlestring,
      emphasis: closer(),
      hardBreakEscape: closer(onexithardbreak),
      hardBreakTrailing: closer(onexithardbreak),
      htmlFlow: closer(onexithtmlflow),
      htmlFlowData: onexitdata,
      htmlText: closer(onexithtmltext),
      htmlTextData: onexitdata,
      image: closer(onexitimage),
      label: onexitlabel,
      labelText: onexitlabeltext,
      lineEnding: onexitlineending,
      link: closer(onexitlink),
      listItem: closer(),
      listOrdered: closer(),
      listUnordered: closer(),
      paragraph: closer(),
      referenceString: onexitreferencestring,
      resourceDestinationString: onexitresourcedestinationstring,
      resourceTitleString: onexitresourcetitlestring,
      resource: onexitresource,
      setextHeading: closer(onexitsetextheading),
      setextHeadingLineSequence: onexitsetextheadinglinesequence,
      setextHeadingText: onexitsetextheadingtext,
      strong: closer(),
      thematicBreak: closer()
    }
  };
  configure(config, (options || {}).mdastExtensions || []);

  /** @type {CompileData} */
  const data = {};
  return compile

  /**
   * Turn micromark events into an mdast tree.
   *
   * @param {Array<Event>} events
   *   Events.
   * @returns {Root}
   *   mdast tree.
   */
  function compile(events) {
    /** @type {Root} */
    let tree = {
      type: 'root',
      children: []
    };
    /** @type {Omit<CompileContext, 'sliceSerialize'>} */
    const context = {
      stack: [tree],
      tokenStack: [],
      config,
      enter,
      exit,
      buffer,
      resume,
      setData,
      getData
    };
    /** @type {Array<number>} */
    const listStack = [];
    let index = -1;
    while (++index < events.length) {
      // We preprocess lists to add `listItem` tokens, and to infer whether
      // items the list itself are spread out.
      if (
        events[index][1].type === 'listOrdered' ||
        events[index][1].type === 'listUnordered'
      ) {
        if (events[index][0] === 'enter') {
          listStack.push(index);
        } else {
          const tail = listStack.pop();
          index = prepareList(events, tail, index);
        }
      }
    }
    index = -1;
    while (++index < events.length) {
      const handler = config[events[index][0]];
      if (own$6.call(handler, events[index][1].type)) {
        handler[events[index][1].type].call(
          Object.assign(
            {
              sliceSerialize: events[index][2].sliceSerialize
            },
            context
          ),
          events[index][1]
        );
      }
    }

    // Handle tokens still being open.
    if (context.tokenStack.length > 0) {
      const tail = context.tokenStack[context.tokenStack.length - 1];
      const handler = tail[1] || defaultOnError;
      handler.call(context, undefined, tail[0]);
    }

    // Figure out `root` position.
    tree.position = {
      start: point$1(
        events.length > 0
          ? events[0][1].start
          : {
              line: 1,
              column: 1,
              offset: 0
            }
      ),
      end: point$1(
        events.length > 0
          ? events[events.length - 2][1].end
          : {
              line: 1,
              column: 1,
              offset: 0
            }
      )
    };

    // Call transforms.
    index = -1;
    while (++index < config.transforms.length) {
      tree = config.transforms[index](tree) || tree;
    }
    return tree
  }

  /**
   * @param {Array<Event>} events
   * @param {number} start
   * @param {number} length
   * @returns {number}
   */
  function prepareList(events, start, length) {
    let index = start - 1;
    let containerBalance = -1;
    let listSpread = false;
    /** @type {Token | undefined} */
    let listItem;
    /** @type {number | undefined} */
    let lineIndex;
    /** @type {number | undefined} */
    let firstBlankLineIndex;
    /** @type {boolean | undefined} */
    let atMarker;
    while (++index <= length) {
      const event = events[index];
      if (
        event[1].type === 'listUnordered' ||
        event[1].type === 'listOrdered' ||
        event[1].type === 'blockQuote'
      ) {
        if (event[0] === 'enter') {
          containerBalance++;
        } else {
          containerBalance--;
        }
        atMarker = undefined;
      } else if (event[1].type === 'lineEndingBlank') {
        if (event[0] === 'enter') {
          if (
            listItem &&
            !atMarker &&
            !containerBalance &&
            !firstBlankLineIndex
          ) {
            firstBlankLineIndex = index;
          }
          atMarker = undefined;
        }
      } else if (
        event[1].type === 'linePrefix' ||
        event[1].type === 'listItemValue' ||
        event[1].type === 'listItemMarker' ||
        event[1].type === 'listItemPrefix' ||
        event[1].type === 'listItemPrefixWhitespace'
      ) ; else {
        atMarker = undefined;
      }
      if (
        (!containerBalance &&
          event[0] === 'enter' &&
          event[1].type === 'listItemPrefix') ||
        (containerBalance === -1 &&
          event[0] === 'exit' &&
          (event[1].type === 'listUnordered' ||
            event[1].type === 'listOrdered'))
      ) {
        if (listItem) {
          let tailIndex = index;
          lineIndex = undefined;
          while (tailIndex--) {
            const tailEvent = events[tailIndex];
            if (
              tailEvent[1].type === 'lineEnding' ||
              tailEvent[1].type === 'lineEndingBlank'
            ) {
              if (tailEvent[0] === 'exit') continue
              if (lineIndex) {
                events[lineIndex][1].type = 'lineEndingBlank';
                listSpread = true;
              }
              tailEvent[1].type = 'lineEnding';
              lineIndex = tailIndex;
            } else if (
              tailEvent[1].type === 'linePrefix' ||
              tailEvent[1].type === 'blockQuotePrefix' ||
              tailEvent[1].type === 'blockQuotePrefixWhitespace' ||
              tailEvent[1].type === 'blockQuoteMarker' ||
              tailEvent[1].type === 'listItemIndent'
            ) ; else {
              break
            }
          }
          if (
            firstBlankLineIndex &&
            (!lineIndex || firstBlankLineIndex < lineIndex)
          ) {
            listItem._spread = true;
          }

          // Fix position.
          listItem.end = Object.assign(
            {},
            lineIndex ? events[lineIndex][1].start : event[1].end
          );
          events.splice(lineIndex || index, 0, ['exit', listItem, event[2]]);
          index++;
          length++;
        }

        // Create a new list item.
        if (event[1].type === 'listItemPrefix') {
          listItem = {
            type: 'listItem',
            _spread: false,
            start: Object.assign({}, event[1].start),
            // @ts-expect-error: we’ll add `end` in a second.
            end: undefined
          };
          // @ts-expect-error: `listItem` is most definitely defined, TS...
          events.splice(index, 0, ['enter', listItem, event[2]]);
          index++;
          length++;
          firstBlankLineIndex = undefined;
          atMarker = true;
        }
      }
    }
    events[start][1]._spread = listSpread;
    return length
  }

  /**
   * Set data.
   *
   * @template {keyof CompileData} Key
   *   Field type.
   * @param {Key} key
   *   Key of field.
   * @param {CompileData[Key]} [value]
   *   New value.
   * @returns {void}
   *   Nothing.
   */
  function setData(key, value) {
    data[key] = value;
  }

  /**
   * Get data.
   *
   * @template {keyof CompileData} Key
   *   Field type.
   * @param {Key} key
   *   Key of field.
   * @returns {CompileData[Key]}
   *   Value.
   */
  function getData(key) {
    return data[key]
  }

  /**
   * Create an opener handle.
   *
   * @param {(token: Token) => Node} create
   *   Create a node.
   * @param {Handle} [and]
   *   Optional function to also run.
   * @returns {Handle}
   *   Handle.
   */
  function opener(create, and) {
    return open

    /**
     * @this {CompileContext}
     * @param {Token} token
     * @returns {void}
     */
    function open(token) {
      enter.call(this, create(token), token);
      if (and) and.call(this, token);
    }
  }

  /**
   * @this {CompileContext}
   * @returns {void}
   */
  function buffer() {
    this.stack.push({
      type: 'fragment',
      children: []
    });
  }

  /**
   * @template {Node} Kind
   *   Node type.
   * @this {CompileContext}
   *   Context.
   * @param {Kind} node
   *   Node to enter.
   * @param {Token} token
   *   Corresponding token.
   * @param {OnEnterError | undefined} [errorHandler]
   *   Handle the case where this token is open, but it is closed by something else.
   * @returns {Kind}
   *   The given node.
   */
  function enter(node, token, errorHandler) {
    const parent = this.stack[this.stack.length - 1];
    // @ts-expect-error: Assume `Node` can exist as a child of `parent`.
    parent.children.push(node);
    this.stack.push(node);
    this.tokenStack.push([token, errorHandler]);
    // @ts-expect-error: `end` will be patched later.
    node.position = {
      start: point$1(token.start)
    };
    return node
  }

  /**
   * Create a closer handle.
   *
   * @param {Handle} [and]
   *   Optional function to also run.
   * @returns {Handle}
   *   Handle.
   */
  function closer(and) {
    return close

    /**
     * @this {CompileContext}
     * @param {Token} token
     * @returns {void}
     */
    function close(token) {
      if (and) and.call(this, token);
      exit.call(this, token);
    }
  }

  /**
   * @this {CompileContext}
   *   Context.
   * @param {Token} token
   *   Corresponding token.
   * @param {OnExitError | undefined} [onExitError]
   *   Handle the case where another token is open.
   * @returns {Node}
   *   The closed node.
   */
  function exit(token, onExitError) {
    const node = this.stack.pop();
    const open = this.tokenStack.pop();
    if (!open) {
      throw new Error(
        'Cannot close `' +
          token.type +
          '` (' +
          stringifyPosition({
            start: token.start,
            end: token.end
          }) +
          '): it’s not open'
      )
    } else if (open[0].type !== token.type) {
      if (onExitError) {
        onExitError.call(this, token, open[0]);
      } else {
        const handler = open[1] || defaultOnError;
        handler.call(this, token, open[0]);
      }
    }
    node.position.end = point$1(token.end);
    return node
  }

  /**
   * @this {CompileContext}
   * @returns {string}
   */
  function resume() {
    return toString(this.stack.pop())
  }

  //
  // Handlers.
  //

  /**
   * @this {CompileContext}
   * @type {Handle}
   */
  function onenterlistordered() {
    setData('expectingFirstListItemValue', true);
  }

  /**
   * @this {CompileContext}
   * @type {Handle}
   */
  function onenterlistitemvalue(token) {
    if (getData('expectingFirstListItemValue')) {
      const ancestor = this.stack[this.stack.length - 2];
      ancestor.start = Number.parseInt(this.sliceSerialize(token), 10);
      setData('expectingFirstListItemValue');
    }
  }

  /**
   * @this {CompileContext}
   * @type {Handle}
   */
  function onexitcodefencedfenceinfo() {
    const data = this.resume();
    const node = this.stack[this.stack.length - 1];
    node.lang = data;
  }

  /**
   * @this {CompileContext}
   * @type {Handle}
   */
  function onexitcodefencedfencemeta() {
    const data = this.resume();
    const node = this.stack[this.stack.length - 1];
    node.meta = data;
  }

  /**
   * @this {CompileContext}
   * @type {Handle}
   */
  function onexitcodefencedfence() {
    // Exit if this is the closing fence.
    if (getData('flowCodeInside')) return
    this.buffer();
    setData('flowCodeInside', true);
  }

  /**
   * @this {CompileContext}
   * @type {Handle}
   */
  function onexitcodefenced() {
    const data = this.resume();
    const node = this.stack[this.stack.length - 1];
    node.value = data.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, '');
    setData('flowCodeInside');
  }

  /**
   * @this {CompileContext}
   * @type {Handle}
   */
  function onexitcodeindented() {
    const data = this.resume();
    const node = this.stack[this.stack.length - 1];
    node.value = data.replace(/(\r?\n|\r)$/g, '');
  }

  /**
   * @this {CompileContext}
   * @type {Handle}
   */
  function onexitdefinitionlabelstring(token) {
    const label = this.resume();
    const node = this.stack[this.stack.length - 1];
    node.label = label;
    node.identifier = normalizeIdentifier(
      this.sliceSerialize(token)
    ).toLowerCase();
  }

  /**
   * @this {CompileContext}
   * @type {Handle}
   */
  function onexitdefinitiontitlestring() {
    const data = this.resume();
    const node = this.stack[this.stack.length - 1];
    node.title = data;
  }

  /**
   * @this {CompileContext}
   * @type {Handle}
   */
  function onexitdefinitiondestinationstring() {
    const data = this.resume();
    const node = this.stack[this.stack.length - 1];
    node.url = data;
  }

  /**
   * @this {CompileContext}
   * @type {Handle}
   */
  function onexitatxheadingsequence(token) {
    const node = this.stack[this.stack.length - 1];
    if (!node.depth) {
      const depth = this.sliceSerialize(token).length;
      node.depth = depth;
    }
  }

  /**
   * @this {CompileContext}
   * @type {Handle}
   */
  function onexitsetextheadingtext() {
    setData('setextHeadingSlurpLineEnding', true);
  }

  /**
   * @this {CompileContext}
   * @type {Handle}
   */
  function onexitsetextheadinglinesequence(token) {
    const node = this.stack[this.stack.length - 1];
    node.depth = this.sliceSerialize(token).charCodeAt(0) === 61 ? 1 : 2;
  }

  /**
   * @this {CompileContext}
   * @type {Handle}
   */
  function onexitsetextheading() {
    setData('setextHeadingSlurpLineEnding');
  }

  /**
   * @this {CompileContext}
   * @type {Handle}
   */

  function onenterdata(token) {
    const node = this.stack[this.stack.length - 1];
    let tail = node.children[node.children.length - 1];
    if (!tail || tail.type !== 'text') {
      // Add a new text node.
      tail = text();
      // @ts-expect-error: we’ll add `end` later.
      tail.position = {
        start: point$1(token.start)
      };
      // @ts-expect-error: Assume `parent` accepts `text`.
      node.children.push(tail);
    }
    this.stack.push(tail);
  }

  /**
   * @this {CompileContext}
   * @type {Handle}
   */

  function onexitdata(token) {
    const tail = this.stack.pop();
    tail.value += this.sliceSerialize(token);
    tail.position.end = point$1(token.end);
  }

  /**
   * @this {CompileContext}
   * @type {Handle}
   */

  function onexitlineending(token) {
    const context = this.stack[this.stack.length - 1];
    // If we’re at a hard break, include the line ending in there.
    if (getData('atHardBreak')) {
      const tail = context.children[context.children.length - 1];
      tail.position.end = point$1(token.end);
      setData('atHardBreak');
      return
    }
    if (
      !getData('setextHeadingSlurpLineEnding') &&
      config.canContainEols.includes(context.type)
    ) {
      onenterdata.call(this, token);
      onexitdata.call(this, token);
    }
  }

  /**
   * @this {CompileContext}
   * @type {Handle}
   */

  function onexithardbreak() {
    setData('atHardBreak', true);
  }

  /**
   * @this {CompileContext}
   * @type {Handle}
   */

  function onexithtmlflow() {
    const data = this.resume();
    const node = this.stack[this.stack.length - 1];
    node.value = data;
  }

  /**
   * @this {CompileContext}
   * @type {Handle}
   */

  function onexithtmltext() {
    const data = this.resume();
    const node = this.stack[this.stack.length - 1];
    node.value = data;
  }

  /**
   * @this {CompileContext}
   * @type {Handle}
   */

  function onexitcodetext() {
    const data = this.resume();
    const node = this.stack[this.stack.length - 1];
    node.value = data;
  }

  /**
   * @this {CompileContext}
   * @type {Handle}
   */

  function onexitlink() {
    const node = this.stack[this.stack.length - 1];
    // Note: there are also `identifier` and `label` fields on this link node!
    // These are used / cleaned here.
    // To do: clean.
    if (getData('inReference')) {
      /** @type {ReferenceType} */
      const referenceType = getData('referenceType') || 'shortcut';
      node.type += 'Reference';
      // @ts-expect-error: mutate.
      node.referenceType = referenceType;
      // @ts-expect-error: mutate.
      delete node.url;
      delete node.title;
    } else {
      // @ts-expect-error: mutate.
      delete node.identifier;
      // @ts-expect-error: mutate.
      delete node.label;
    }
    setData('referenceType');
  }

  /**
   * @this {CompileContext}
   * @type {Handle}
   */

  function onexitimage() {
    const node = this.stack[this.stack.length - 1];
    // Note: there are also `identifier` and `label` fields on this link node!
    // These are used / cleaned here.
    // To do: clean.
    if (getData('inReference')) {
      /** @type {ReferenceType} */
      const referenceType = getData('referenceType') || 'shortcut';
      node.type += 'Reference';
      // @ts-expect-error: mutate.
      node.referenceType = referenceType;
      // @ts-expect-error: mutate.
      delete node.url;
      delete node.title;
    } else {
      // @ts-expect-error: mutate.
      delete node.identifier;
      // @ts-expect-error: mutate.
      delete node.label;
    }
    setData('referenceType');
  }

  /**
   * @this {CompileContext}
   * @type {Handle}
   */

  function onexitlabeltext(token) {
    const string = this.sliceSerialize(token);
    const ancestor = this.stack[this.stack.length - 2];
    // @ts-expect-error: stash this on the node, as it might become a reference
    // later.
    ancestor.label = decodeString(string);
    // @ts-expect-error: same as above.
    ancestor.identifier = normalizeIdentifier(string).toLowerCase();
  }

  /**
   * @this {CompileContext}
   * @type {Handle}
   */

  function onexitlabel() {
    const fragment = this.stack[this.stack.length - 1];
    const value = this.resume();
    const node = this.stack[this.stack.length - 1];
    // Assume a reference.
    setData('inReference', true);
    if (node.type === 'link') {
      /** @type {Array<StaticPhrasingContent>} */
      // @ts-expect-error: Assume static phrasing content.
      const children = fragment.children;
      node.children = children;
    } else {
      node.alt = value;
    }
  }

  /**
   * @this {CompileContext}
   * @type {Handle}
   */

  function onexitresourcedestinationstring() {
    const data = this.resume();
    const node = this.stack[this.stack.length - 1];
    node.url = data;
  }

  /**
   * @this {CompileContext}
   * @type {Handle}
   */

  function onexitresourcetitlestring() {
    const data = this.resume();
    const node = this.stack[this.stack.length - 1];
    node.title = data;
  }

  /**
   * @this {CompileContext}
   * @type {Handle}
   */

  function onexitresource() {
    setData('inReference');
  }

  /**
   * @this {CompileContext}
   * @type {Handle}
   */

  function onenterreference() {
    setData('referenceType', 'collapsed');
  }

  /**
   * @this {CompileContext}
   * @type {Handle}
   */

  function onexitreferencestring(token) {
    const label = this.resume();
    const node = this.stack[this.stack.length - 1];
    // @ts-expect-error: stash this on the node, as it might become a reference
    // later.
    node.label = label;
    // @ts-expect-error: same as above.
    node.identifier = normalizeIdentifier(
      this.sliceSerialize(token)
    ).toLowerCase();
    setData('referenceType', 'full');
  }

  /**
   * @this {CompileContext}
   * @type {Handle}
   */

  function onexitcharacterreferencemarker(token) {
    setData('characterReferenceType', token.type);
  }

  /**
   * @this {CompileContext}
   * @type {Handle}
   */
  function onexitcharacterreferencevalue(token) {
    const data = this.sliceSerialize(token);
    const type = getData('characterReferenceType');
    /** @type {string} */
    let value;
    if (type) {
      value = decodeNumericCharacterReference(
        data,
        type === 'characterReferenceMarkerNumeric' ? 10 : 16
      );
      setData('characterReferenceType');
    } else {
      const result = decodeNamedCharacterReference(data);
      value = result;
    }
    const tail = this.stack.pop();
    tail.value += value;
    tail.position.end = point$1(token.end);
  }

  /**
   * @this {CompileContext}
   * @type {Handle}
   */
  function onexitautolinkprotocol(token) {
    onexitdata.call(this, token);
    const node = this.stack[this.stack.length - 1];
    node.url = this.sliceSerialize(token);
  }

  /**
   * @this {CompileContext}
   * @type {Handle}
   */
  function onexitautolinkemail(token) {
    onexitdata.call(this, token);
    const node = this.stack[this.stack.length - 1];
    node.url = 'mailto:' + this.sliceSerialize(token);
  }

  //
  // Creaters.
  //

  /** @returns {Blockquote} */
  function blockQuote() {
    return {
      type: 'blockquote',
      children: []
    }
  }

  /** @returns {Code} */
  function codeFlow() {
    return {
      type: 'code',
      lang: null,
      meta: null,
      value: ''
    }
  }

  /** @returns {InlineCode} */
  function codeText() {
    return {
      type: 'inlineCode',
      value: ''
    }
  }

  /** @returns {Definition} */
  function definition() {
    return {
      type: 'definition',
      identifier: '',
      label: null,
      title: null,
      url: ''
    }
  }

  /** @returns {Emphasis} */
  function emphasis() {
    return {
      type: 'emphasis',
      children: []
    }
  }

  /** @returns {Heading} */
  function heading() {
    // @ts-expect-error `depth` will be set later.
    return {
      type: 'heading',
      depth: undefined,
      children: []
    }
  }

  /** @returns {Break} */
  function hardBreak() {
    return {
      type: 'break'
    }
  }

  /** @returns {HTML} */
  function html() {
    return {
      type: 'html',
      value: ''
    }
  }

  /** @returns {Image} */
  function image() {
    return {
      type: 'image',
      title: null,
      url: '',
      alt: null
    }
  }

  /** @returns {Link} */
  function link() {
    return {
      type: 'link',
      title: null,
      url: '',
      children: []
    }
  }

  /**
   * @param {Token} token
   * @returns {List}
   */
  function list(token) {
    return {
      type: 'list',
      ordered: token.type === 'listOrdered',
      start: null,
      spread: token._spread,
      children: []
    }
  }

  /**
   * @param {Token} token
   * @returns {ListItem}
   */
  function listItem(token) {
    return {
      type: 'listItem',
      spread: token._spread,
      checked: null,
      children: []
    }
  }

  /** @returns {Paragraph} */
  function paragraph() {
    return {
      type: 'paragraph',
      children: []
    }
  }

  /** @returns {Strong} */
  function strong() {
    return {
      type: 'strong',
      children: []
    }
  }

  /** @returns {Text} */
  function text() {
    return {
      type: 'text',
      value: ''
    }
  }

  /** @returns {ThematicBreak} */
  function thematicBreak() {
    return {
      type: 'thematicBreak'
    }
  }
}

/**
 * Copy a point-like value.
 *
 * @param {Point} d
 *   Point-like value.
 * @returns {Point}
 *   unist point.
 */
function point$1(d) {
  return {
    line: d.line,
    column: d.column,
    offset: d.offset
  }
}

/**
 * @param {Config} combined
 * @param {Array<Extension | Array<Extension>>} extensions
 * @returns {void}
 */
function configure(combined, extensions) {
  let index = -1;
  while (++index < extensions.length) {
    const value = extensions[index];
    if (Array.isArray(value)) {
      configure(combined, value);
    } else {
      extension(combined, value);
    }
  }
}

/**
 * @param {Config} combined
 * @param {Extension} extension
 * @returns {void}
 */
function extension(combined, extension) {
  /** @type {keyof Extension} */
  let key;
  for (key in extension) {
    if (own$6.call(extension, key)) {
      if (key === 'canContainEols') {
        const right = extension[key];
        if (right) {
          combined[key].push(...right);
        }
      } else if (key === 'transforms') {
        const right = extension[key];
        if (right) {
          combined[key].push(...right);
        }
      } else if (key === 'enter' || key === 'exit') {
        const right = extension[key];
        if (right) {
          Object.assign(combined[key], right);
        }
      }
    }
  }
}

/** @type {OnEnterError} */
function defaultOnError(left, right) {
  if (left) {
    throw new Error(
      'Cannot close `' +
        left.type +
        '` (' +
        stringifyPosition({
          start: left.start,
          end: left.end
        }) +
        '): a different token (`' +
        right.type +
        '`, ' +
        stringifyPosition({
          start: right.start,
          end: right.end
        }) +
        ') is open'
    )
  } else {
    throw new Error(
      'Cannot close document, a token (`' +
        right.type +
        '`, ' +
        stringifyPosition({
          start: right.start,
          end: right.end
        }) +
        ') is still open'
    )
  }
}

/**
 * @typedef {import('mdast').Root} Root
 * @typedef {import('mdast-util-from-markdown').Options} Options
 */


/**
 * @this {import('unified').Processor}
 * @type {import('unified').Plugin<[Options?] | void[], string, Root>}
 */
function remarkParse(options) {
  /** @type {import('unified').ParserFunction<Root>} */
  const parser = (doc) => {
    // Assume options.
    const settings = /** @type {Options} */ (this.data('settings'));

    return fromMarkdown(
      doc,
      Object.assign({}, settings, options, {
        // Note: these options are not in the readme.
        // The goal is for them to be set by plugins on `data` instead of being
        // passed by users.
        extensions: this.data('micromarkExtensions') || [],
        mdastExtensions: this.data('fromMarkdownExtensions') || []
      })
    )
  };

  Object.assign(this, {Parser: parser});
}

/**
 * @typedef {import('hast').Element} Element
 * @typedef {import('mdast').Blockquote} Blockquote
 * @typedef {import('../state.js').State} State
 */

/**
 * Turn an mdast `blockquote` node into hast.
 *
 * @param {State} state
 *   Info passed around.
 * @param {Blockquote} node
 *   mdast node.
 * @returns {Element}
 *   hast node.
 */
function blockquote(state, node) {
  /** @type {Element} */
  const result = {
    type: 'element',
    tagName: 'blockquote',
    properties: {},
    children: state.wrap(state.all(node), true)
  };
  state.patch(node, result);
  return state.applyData(node, result)
}

/**
 * @typedef {import('hast').Element} Element
 * @typedef {import('hast').Text} Text
 * @typedef {import('mdast').Break} Break
 * @typedef {import('../state.js').State} State
 */

/**
 * Turn an mdast `break` node into hast.
 *
 * @param {State} state
 *   Info passed around.
 * @param {Break} node
 *   mdast node.
 * @returns {Array<Element | Text>}
 *   hast element content.
 */
function hardBreak(state, node) {
  /** @type {Element} */
  const result = {type: 'element', tagName: 'br', properties: {}, children: []};
  state.patch(node, result);
  return [state.applyData(node, result), {type: 'text', value: '\n'}]
}

/**
 * @typedef {import('hast').Element} Element
 * @typedef {import('hast').Properties} Properties
 * @typedef {import('mdast').Code} Code
 * @typedef {import('../state.js').State} State

 */

/**
 * Turn an mdast `code` node into hast.
 *
 * @param {State} state
 *   Info passed around.
 * @param {Code} node
 *   mdast node.
 * @returns {Element}
 *   hast node.
 */
function code$1(state, node) {
  const value = node.value ? node.value + '\n' : '';
  // To do: next major, use `node.lang` w/o regex, the splitting’s been going
  // on for years in remark now.
  const lang = node.lang ? node.lang.match(/^[^ \t]+(?=[ \t]|$)/) : null;
  /** @type {Properties} */
  const properties = {};

  if (lang) {
    properties.className = ['language-' + lang];
  }

  // Create `<code>`.
  /** @type {Element} */
  let result = {
    type: 'element',
    tagName: 'code',
    properties,
    children: [{type: 'text', value}]
  };

  if (node.meta) {
    result.data = {meta: node.meta};
  }

  state.patch(node, result);
  result = state.applyData(node, result);

  // Create `<pre>`.
  result = {type: 'element', tagName: 'pre', properties: {}, children: [result]};
  state.patch(node, result);
  return result
}

/**
 * @typedef {import('hast').Element} Element
 * @typedef {import('mdast').Delete} Delete
 * @typedef {import('../state.js').State} State

 */

/**
 * Turn an mdast `delete` node into hast.
 *
 * @param {State} state
 *   Info passed around.
 * @param {Delete} node
 *   mdast node.
 * @returns {Element}
 *   hast node.
 */
function strikethrough(state, node) {
  /** @type {Element} */
  const result = {
    type: 'element',
    tagName: 'del',
    properties: {},
    children: state.all(node)
  };
  state.patch(node, result);
  return state.applyData(node, result)
}

/**
 * @typedef {import('hast').Element} Element
 * @typedef {import('mdast').Emphasis} Emphasis
 * @typedef {import('../state.js').State} State
 */

/**
 * Turn an mdast `emphasis` node into hast.
 *
 * @param {State} state
 *   Info passed around.
 * @param {Emphasis} node
 *   mdast node.
 * @returns {Element}
 *   hast node.
 */
function emphasis(state, node) {
  /** @type {Element} */
  const result = {
    type: 'element',
    tagName: 'em',
    properties: {},
    children: state.all(node)
  };
  state.patch(node, result);
  return state.applyData(node, result)
}

/**
 * Normalize a URL.
 *
 * Encode unsafe characters with percent-encoding, skipping already encoded
 * sequences.
 *
 * @param {string} value
 *   URI to normalize.
 * @returns {string}
 *   Normalized URI.
 */
function normalizeUri(value) {
  /** @type {Array<string>} */
  const result = [];
  let index = -1;
  let start = 0;
  let skip = 0;
  while (++index < value.length) {
    const code = value.charCodeAt(index);
    /** @type {string} */
    let replace = '';

    // A correct percent encoded value.
    if (
      code === 37 &&
      asciiAlphanumeric(value.charCodeAt(index + 1)) &&
      asciiAlphanumeric(value.charCodeAt(index + 2))
    ) {
      skip = 2;
    }
    // ASCII.
    else if (code < 128) {
      if (!/[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(code))) {
        replace = String.fromCharCode(code);
      }
    }
    // Astral.
    else if (code > 55295 && code < 57344) {
      const next = value.charCodeAt(index + 1);

      // A correct surrogate pair.
      if (code < 56320 && next > 56319 && next < 57344) {
        replace = String.fromCharCode(code, next);
        skip = 1;
      }
      // Lone surrogate.
      else {
        replace = '\uFFFD';
      }
    }
    // Unicode.
    else {
      replace = String.fromCharCode(code);
    }
    if (replace) {
      result.push(value.slice(start, index), encodeURIComponent(replace));
      start = index + skip + 1;
      replace = '';
    }
    if (skip) {
      index += skip;
      skip = 0;
    }
  }
  return result.join('') + value.slice(start)
}

/**
 * @typedef {import('mdast').FootnoteReference} FootnoteReference
 * @typedef {import('hast').Element} Element
 * @typedef {import('../state.js').State} State
 */


/**
 * Turn an mdast `footnoteReference` node into hast.
 *
 * @param {State} state
 *   Info passed around.
 * @param {FootnoteReference} node
 *   mdast node.
 * @returns {Element}
 *   hast node.
 */
function footnoteReference$1(state, node) {
  const id = String(node.identifier).toUpperCase();
  const safeId = normalizeUri(id.toLowerCase());
  const index = state.footnoteOrder.indexOf(id);
  /** @type {number} */
  let counter;

  if (index === -1) {
    state.footnoteOrder.push(id);
    state.footnoteCounts[id] = 1;
    counter = state.footnoteOrder.length;
  } else {
    state.footnoteCounts[id]++;
    counter = index + 1;
  }

  const reuseCounter = state.footnoteCounts[id];

  /** @type {Element} */
  const link = {
    type: 'element',
    tagName: 'a',
    properties: {
      href: '#' + state.clobberPrefix + 'fn-' + safeId,
      id:
        state.clobberPrefix +
        'fnref-' +
        safeId +
        (reuseCounter > 1 ? '-' + reuseCounter : ''),
      dataFootnoteRef: true,
      ariaDescribedBy: ['footnote-label']
    },
    children: [{type: 'text', value: String(counter)}]
  };
  state.patch(node, link);

  /** @type {Element} */
  const sup = {
    type: 'element',
    tagName: 'sup',
    properties: {},
    children: [link]
  };
  state.patch(node, sup);
  return state.applyData(node, sup)
}

/**
 * @typedef {import('hast').Element} Element
 * @typedef {import('mdast').Footnote} Footnote
 * @typedef {import('../state.js').State} State
 */


// To do: when both:
// * <https://github.com/micromark/micromark-extension-footnote>
// * <https://github.com/syntax-tree/mdast-util-footnote>
// …are archived, remove this (also from mdast).
// These inline notes are not used in GFM.

/**
 * Turn an mdast `footnote` node into hast.
 *
 * @param {State} state
 *   Info passed around.
 * @param {Footnote} node
 *   mdast node.
 * @returns {Element}
 *   hast node.
 */
function footnote(state, node) {
  const footnoteById = state.footnoteById;
  let no = 1;

  while (no in footnoteById) no++;

  const identifier = String(no);

  footnoteById[identifier] = {
    type: 'footnoteDefinition',
    identifier,
    children: [{type: 'paragraph', children: node.children}],
    position: node.position
  };

  return footnoteReference$1(state, {
    type: 'footnoteReference',
    identifier,
    position: node.position
  })
}

/**
 * @typedef {import('hast').Element} Element
 * @typedef {import('mdast').Heading} Heading
 * @typedef {import('../state.js').State} State
 */

/**
 * Turn an mdast `heading` node into hast.
 *
 * @param {State} state
 *   Info passed around.
 * @param {Heading} node
 *   mdast node.
 * @returns {Element}
 *   hast node.
 */
function heading(state, node) {
  /** @type {Element} */
  const result = {
    type: 'element',
    tagName: 'h' + node.depth,
    properties: {},
    children: state.all(node)
  };
  state.patch(node, result);
  return state.applyData(node, result)
}

/**
 * @typedef {import('hast').Element} Element
 * @typedef {import('mdast').HTML} Html
 * @typedef {import('../state.js').State} State
 * @typedef {import('../../index.js').Raw} Raw
 */

/**
 * Turn an mdast `html` node into hast (`raw` node in dangerous mode, otherwise
 * nothing).
 *
 * @param {State} state
 *   Info passed around.
 * @param {Html} node
 *   mdast node.
 * @returns {Raw | Element | null}
 *   hast node.
 */
function html$2(state, node) {
  if (state.dangerous) {
    /** @type {Raw} */
    const result = {type: 'raw', value: node.value};
    state.patch(node, result);
    return state.applyData(node, result)
  }

  // To do: next major: return `undefined`.
  return null
}

/**
 * @typedef {import('hast').ElementContent} ElementContent
 *
 * @typedef {import('mdast').Content} Content
 * @typedef {import('mdast').Reference} Reference
 * @typedef {import('mdast').Root} Root
 *
 * @typedef {import('./state.js').State} State
 */

/**
 * @typedef {Root | Content} Nodes
 * @typedef {Extract<Nodes, Reference>} References
 */

// To do: next major: always return array.

/**
 * Return the content of a reference without definition as plain text.
 *
 * @param {State} state
 *   Info passed around.
 * @param {References} node
 *   Reference node (image, link).
 * @returns {ElementContent | Array<ElementContent>}
 *   hast content.
 */
function revert(state, node) {
  const subtype = node.referenceType;
  let suffix = ']';

  if (subtype === 'collapsed') {
    suffix += '[]';
  } else if (subtype === 'full') {
    suffix += '[' + (node.label || node.identifier) + ']';
  }

  if (node.type === 'imageReference') {
    return {type: 'text', value: '![' + node.alt + suffix}
  }

  const contents = state.all(node);
  const head = contents[0];

  if (head && head.type === 'text') {
    head.value = '[' + head.value;
  } else {
    contents.unshift({type: 'text', value: '['});
  }

  const tail = contents[contents.length - 1];

  if (tail && tail.type === 'text') {
    tail.value += suffix;
  } else {
    contents.push({type: 'text', value: suffix});
  }

  return contents
}

/**
 * @typedef {import('hast').ElementContent} ElementContent
 * @typedef {import('hast').Element} Element
 * @typedef {import('hast').Properties} Properties
 * @typedef {import('mdast').ImageReference} ImageReference
 * @typedef {import('../state.js').State} State
 */


/**
 * Turn an mdast `imageReference` node into hast.
 *
 * @param {State} state
 *   Info passed around.
 * @param {ImageReference} node
 *   mdast node.
 * @returns {ElementContent | Array<ElementContent>}
 *   hast node.
 */
function imageReference(state, node) {
  const def = state.definition(node.identifier);

  if (!def) {
    return revert(state, node)
  }

  /** @type {Properties} */
  const properties = {src: normalizeUri(def.url || ''), alt: node.alt};

  if (def.title !== null && def.title !== undefined) {
    properties.title = def.title;
  }

  /** @type {Element} */
  const result = {type: 'element', tagName: 'img', properties, children: []};
  state.patch(node, result);
  return state.applyData(node, result)
}

/**
 * @typedef {import('hast').Element} Element
 * @typedef {import('hast').Properties} Properties
 * @typedef {import('mdast').Image} Image
 * @typedef {import('../state.js').State} State
 */


/**
 * Turn an mdast `image` node into hast.
 *
 * @param {State} state
 *   Info passed around.
 * @param {Image} node
 *   mdast node.
 * @returns {Element}
 *   hast node.
 */
function image(state, node) {
  /** @type {Properties} */
  const properties = {src: normalizeUri(node.url)};

  if (node.alt !== null && node.alt !== undefined) {
    properties.alt = node.alt;
  }

  if (node.title !== null && node.title !== undefined) {
    properties.title = node.title;
  }

  /** @type {Element} */
  const result = {type: 'element', tagName: 'img', properties, children: []};
  state.patch(node, result);
  return state.applyData(node, result)
}

/**
 * @typedef {import('hast').Element} Element
 * @typedef {import('hast').Text} Text
 * @typedef {import('mdast').InlineCode} InlineCode
 * @typedef {import('../state.js').State} State
 */

/**
 * Turn an mdast `inlineCode` node into hast.
 *
 * @param {State} state
 *   Info passed around.
 * @param {InlineCode} node
 *   mdast node.
 * @returns {Element}
 *   hast node.
 */
function inlineCode$1(state, node) {
  /** @type {Text} */
  const text = {type: 'text', value: node.value.replace(/\r?\n|\r/g, ' ')};
  state.patch(node, text);

  /** @type {Element} */
  const result = {
    type: 'element',
    tagName: 'code',
    properties: {},
    children: [text]
  };
  state.patch(node, result);
  return state.applyData(node, result)
}

/**
 * @typedef {import('hast').Element} Element
 * @typedef {import('hast').ElementContent} ElementContent
 * @typedef {import('hast').Properties} Properties
 * @typedef {import('mdast').LinkReference} LinkReference
 * @typedef {import('../state.js').State} State
 */


/**
 * Turn an mdast `linkReference` node into hast.
 *
 * @param {State} state
 *   Info passed around.
 * @param {LinkReference} node
 *   mdast node.
 * @returns {ElementContent | Array<ElementContent>}
 *   hast node.
 */
function linkReference(state, node) {
  const def = state.definition(node.identifier);

  if (!def) {
    return revert(state, node)
  }

  /** @type {Properties} */
  const properties = {href: normalizeUri(def.url || '')};

  if (def.title !== null && def.title !== undefined) {
    properties.title = def.title;
  }

  /** @type {Element} */
  const result = {
    type: 'element',
    tagName: 'a',
    properties,
    children: state.all(node)
  };
  state.patch(node, result);
  return state.applyData(node, result)
}

/**
 * @typedef {import('hast').Element} Element
 * @typedef {import('hast').Properties} Properties
 * @typedef {import('mdast').Link} Link
 * @typedef {import('../state.js').State} State
 */


/**
 * Turn an mdast `link` node into hast.
 *
 * @param {State} state
 *   Info passed around.
 * @param {Link} node
 *   mdast node.
 * @returns {Element}
 *   hast node.
 */
function link(state, node) {
  /** @type {Properties} */
  const properties = {href: normalizeUri(node.url)};

  if (node.title !== null && node.title !== undefined) {
    properties.title = node.title;
  }

  /** @type {Element} */
  const result = {
    type: 'element',
    tagName: 'a',
    properties,
    children: state.all(node)
  };
  state.patch(node, result);
  return state.applyData(node, result)
}

/**
 * @typedef {import('hast').Element} Element
 * @typedef {import('hast').ElementContent} ElementContent
 * @typedef {import('hast').Properties} Properties
 * @typedef {import('mdast').Content} Content
 * @typedef {import('mdast').ListItem} ListItem
 * @typedef {import('mdast').Parent} Parent
 * @typedef {import('mdast').Root} Root
 * @typedef {import('../state.js').State} State
 */

/**
 * @typedef {Root | Content} Nodes
 * @typedef {Extract<Nodes, Parent>} Parents
 */

/**
 * Turn an mdast `listItem` node into hast.
 *
 * @param {State} state
 *   Info passed around.
 * @param {ListItem} node
 *   mdast node.
 * @param {Parents | null | undefined} parent
 *   Parent of `node`.
 * @returns {Element}
 *   hast node.
 */
function listItem$1(state, node, parent) {
  const results = state.all(node);
  const loose = parent ? listLoose(parent) : listItemLoose(node);
  /** @type {Properties} */
  const properties = {};
  /** @type {Array<ElementContent>} */
  const children = [];

  if (typeof node.checked === 'boolean') {
    const head = results[0];
    /** @type {Element} */
    let paragraph;

    if (head && head.type === 'element' && head.tagName === 'p') {
      paragraph = head;
    } else {
      paragraph = {type: 'element', tagName: 'p', properties: {}, children: []};
      results.unshift(paragraph);
    }

    if (paragraph.children.length > 0) {
      paragraph.children.unshift({type: 'text', value: ' '});
    }

    paragraph.children.unshift({
      type: 'element',
      tagName: 'input',
      properties: {type: 'checkbox', checked: node.checked, disabled: true},
      children: []
    });

    // According to github-markdown-css, this class hides bullet.
    // See: <https://github.com/sindresorhus/github-markdown-css>.
    properties.className = ['task-list-item'];
  }

  let index = -1;

  while (++index < results.length) {
    const child = results[index];

    // Add eols before nodes, except if this is a loose, first paragraph.
    if (
      loose ||
      index !== 0 ||
      child.type !== 'element' ||
      child.tagName !== 'p'
    ) {
      children.push({type: 'text', value: '\n'});
    }

    if (child.type === 'element' && child.tagName === 'p' && !loose) {
      children.push(...child.children);
    } else {
      children.push(child);
    }
  }

  const tail = results[results.length - 1];

  // Add a final eol.
  if (tail && (loose || tail.type !== 'element' || tail.tagName !== 'p')) {
    children.push({type: 'text', value: '\n'});
  }

  /** @type {Element} */
  const result = {type: 'element', tagName: 'li', properties, children};
  state.patch(node, result);
  return state.applyData(node, result)
}

/**
 * @param {Parents} node
 * @return {Boolean}
 */
function listLoose(node) {
  let loose = false;
  if (node.type === 'list') {
    loose = node.spread || false;
    const children = node.children;
    let index = -1;

    while (!loose && ++index < children.length) {
      loose = listItemLoose(children[index]);
    }
  }

  return loose
}

/**
 * @param {ListItem} node
 * @return {Boolean}
 */
function listItemLoose(node) {
  const spread = node.spread;

  return spread === undefined || spread === null
    ? node.children.length > 1
    : spread
}

/**
 * @typedef {import('hast').Element} Element
 * @typedef {import('hast').Properties} Properties
 * @typedef {import('mdast').List} List
 * @typedef {import('../state.js').State} State
 */

/**
 * Turn an mdast `list` node into hast.
 *
 * @param {State} state
 *   Info passed around.
 * @param {List} node
 *   mdast node.
 * @returns {Element}
 *   hast node.
 */
function list(state, node) {
  /** @type {Properties} */
  const properties = {};
  const results = state.all(node);
  let index = -1;

  if (typeof node.start === 'number' && node.start !== 1) {
    properties.start = node.start;
  }

  // Like GitHub, add a class for custom styling.
  while (++index < results.length) {
    const child = results[index];

    if (
      child.type === 'element' &&
      child.tagName === 'li' &&
      child.properties &&
      Array.isArray(child.properties.className) &&
      child.properties.className.includes('task-list-item')
    ) {
      properties.className = ['contains-task-list'];
      break
    }
  }

  /** @type {Element} */
  const result = {
    type: 'element',
    tagName: node.ordered ? 'ol' : 'ul',
    properties,
    children: state.wrap(results, true)
  };
  state.patch(node, result);
  return state.applyData(node, result)
}

/**
 * @typedef {import('hast').Element} Element
 * @typedef {import('mdast').Paragraph} Paragraph
 * @typedef {import('../state.js').State} State
 */

/**
 * Turn an mdast `paragraph` node into hast.
 *
 * @param {State} state
 *   Info passed around.
 * @param {Paragraph} node
 *   mdast node.
 * @returns {Element}
 *   hast node.
 */
function paragraph(state, node) {
  /** @type {Element} */
  const result = {
    type: 'element',
    tagName: 'p',
    properties: {},
    children: state.all(node)
  };
  state.patch(node, result);
  return state.applyData(node, result)
}

/**
 * @typedef {import('hast').Root} HastRoot
 * @typedef {import('hast').Element} HastElement
 * @typedef {import('mdast').Root} MdastRoot
 * @typedef {import('../state.js').State} State
 */

/**
 * Turn an mdast `root` node into hast.
 *
 * @param {State} state
 *   Info passed around.
 * @param {MdastRoot} node
 *   mdast node.
 * @returns {HastRoot | HastElement}
 *   hast node.
 */
function root(state, node) {
  /** @type {HastRoot} */
  const result = {type: 'root', children: state.wrap(state.all(node))};
  state.patch(node, result);
  return state.applyData(node, result)
}

/**
 * @typedef {import('hast').Element} Element
 * @typedef {import('mdast').Strong} Strong
 * @typedef {import('../state.js').State} State
 */

/**
 * Turn an mdast `strong` node into hast.
 *
 * @param {State} state
 *   Info passed around.
 * @param {Strong} node
 *   mdast node.
 * @returns {Element}
 *   hast node.
 */
function strong(state, node) {
  /** @type {Element} */
  const result = {
    type: 'element',
    tagName: 'strong',
    properties: {},
    children: state.all(node)
  };
  state.patch(node, result);
  return state.applyData(node, result)
}

/**
 * @typedef {import('unist').Position} Position
 * @typedef {import('unist').Node} Node
 * @typedef {import('unist').Point} Point
 */

/**
 * @typedef NodeLike
 * @property {string} type
 * @property {PositionLike | null | undefined} [position]
 *
 * @typedef PositionLike
 * @property {PointLike | null | undefined} [start]
 * @property {PointLike | null | undefined} [end]
 *
 * @typedef PointLike
 * @property {number | null | undefined} [line]
 * @property {number | null | undefined} [column]
 * @property {number | null | undefined} [offset]
 */

/**
 * Get the starting point of `node`.
 *
 * @param node
 *   Node.
 * @returns
 *   Point.
 */
const pointStart = point('start');

/**
 * Get the ending point of `node`.
 *
 * @param node
 *   Node.
 * @returns
 *   Point.
 */
const pointEnd = point('end');

/**
 * Get the positional info of `node`.
 *
 * @param {NodeLike | Node | null | undefined} [node]
 *   Node.
 * @returns {Position}
 *   Position.
 */
function position(node) {
  return {start: pointStart(node), end: pointEnd(node)}
}

/**
 * Get the positional info of `node`.
 *
 * @param {'start' | 'end'} type
 *   Side.
 * @returns
 *   Getter.
 */
function point(type) {
  return point

  /**
   * Get the point info of `node` at a bound side.
   *
   * @param {NodeLike | Node | null | undefined} [node]
   * @returns {Point}
   */
  function point(node) {
    const point = (node && node.position && node.position[type]) || {};

    // To do: next major: don’t return points when invalid.
    return {
      // @ts-expect-error: in practice, null is allowed.
      line: point.line || null,
      // @ts-expect-error: in practice, null is allowed.
      column: point.column || null,
      // @ts-expect-error: in practice, null is allowed.
      offset: point.offset > -1 ? point.offset : null
    }
  }
}

/**
 * @typedef {import('hast').Element} Element
 * @typedef {import('mdast').Table} Table
 * @typedef {import('../state.js').State} State
 */


/**
 * Turn an mdast `table` node into hast.
 *
 * @param {State} state
 *   Info passed around.
 * @param {Table} node
 *   mdast node.
 * @returns {Element}
 *   hast node.
 */
function table(state, node) {
  const rows = state.all(node);
  const firstRow = rows.shift();
  /** @type {Array<Element>} */
  const tableContent = [];

  if (firstRow) {
    /** @type {Element} */
    const head = {
      type: 'element',
      tagName: 'thead',
      properties: {},
      children: state.wrap([firstRow], true)
    };
    state.patch(node.children[0], head);
    tableContent.push(head);
  }

  if (rows.length > 0) {
    /** @type {Element} */
    const body = {
      type: 'element',
      tagName: 'tbody',
      properties: {},
      children: state.wrap(rows, true)
    };

    const start = pointStart(node.children[1]);
    const end = pointEnd(node.children[node.children.length - 1]);
    if (start.line && end.line) body.position = {start, end};
    tableContent.push(body);
  }

  /** @type {Element} */
  const result = {
    type: 'element',
    tagName: 'table',
    properties: {},
    children: state.wrap(tableContent, true)
  };
  state.patch(node, result);
  return state.applyData(node, result)
}

/**
 * @typedef {import('hast').Properties} Properties
 * @typedef {import('hast').Element} Element
 * @typedef {import('hast').ElementContent} ElementContent
 * @typedef {import('mdast').Content} Content
 * @typedef {import('mdast').Parent} Parent
 * @typedef {import('mdast').Root} Root
 * @typedef {import('mdast').TableRow} TableRow
 * @typedef {import('../state.js').State} State
 */

/**
 * @typedef {Root | Content} Nodes
 * @typedef {Extract<Nodes, Parent>} Parents
 */

/**
 * Turn an mdast `tableRow` node into hast.
 *
 * @param {State} state
 *   Info passed around.
 * @param {TableRow} node
 *   mdast node.
 * @param {Parents | null | undefined} parent
 *   Parent of `node`.
 * @returns {Element}
 *   hast node.
 */
function tableRow(state, node, parent) {
  const siblings = parent ? parent.children : undefined;
  // Generate a body row when without parent.
  const rowIndex = siblings ? siblings.indexOf(node) : 1;
  const tagName = rowIndex === 0 ? 'th' : 'td';
  const align = parent && parent.type === 'table' ? parent.align : undefined;
  const length = align ? align.length : node.children.length;
  let cellIndex = -1;
  /** @type {Array<ElementContent>} */
  const cells = [];

  while (++cellIndex < length) {
    // Note: can also be undefined.
    const cell = node.children[cellIndex];
    /** @type {Properties} */
    const properties = {};
    const alignValue = align ? align[cellIndex] : undefined;

    if (alignValue) {
      properties.align = alignValue;
    }

    /** @type {Element} */
    let result = {type: 'element', tagName, properties, children: []};

    if (cell) {
      result.children = state.all(cell);
      state.patch(cell, result);
      result = state.applyData(node, result);
    }

    cells.push(result);
  }

  /** @type {Element} */
  const result = {
    type: 'element',
    tagName: 'tr',
    properties: {},
    children: state.wrap(cells, true)
  };
  state.patch(node, result);
  return state.applyData(node, result)
}

/**
 * @typedef {import('hast').Element} Element
 * @typedef {import('mdast').TableCell} TableCell
 * @typedef {import('../state.js').State} State
 */

/**
 * Turn an mdast `tableCell` node into hast.
 *
 * @param {State} state
 *   Info passed around.
 * @param {TableCell} node
 *   mdast node.
 * @returns {Element}
 *   hast node.
 */
function tableCell(state, node) {
  // Note: this function is normally not called: see `table-row` for how rows
  // and their cells are compiled.
  /** @type {Element} */
  const result = {
    type: 'element',
    tagName: 'td', // Assume body cell.
    properties: {},
    children: state.all(node)
  };
  state.patch(node, result);
  return state.applyData(node, result)
}

const tab = 9; /* `\t` */
const space = 32; /* ` ` */

/**
 * Remove initial and final spaces and tabs at the line breaks in `value`.
 * Does not trim initial and final spaces and tabs of the value itself.
 *
 * @param {string} value
 *   Value to trim.
 * @returns {string}
 *   Trimmed value.
 */
function trimLines(value) {
  const source = String(value);
  const search = /\r?\n|\r/g;
  let match = search.exec(source);
  let last = 0;
  /** @type {Array<string>} */
  const lines = [];

  while (match) {
    lines.push(
      trimLine(source.slice(last, match.index), last > 0, true),
      match[0]
    );

    last = match.index + match[0].length;
    match = search.exec(source);
  }

  lines.push(trimLine(source.slice(last), last > 0, false));

  return lines.join('')
}

/**
 * @param {string} value
 *   Line to trim.
 * @param {boolean} start
 *   Whether to trim the start of the line.
 * @param {boolean} end
 *   Whether to trim the end of the line.
 * @returns {string}
 *   Trimmed line.
 */
function trimLine(value, start, end) {
  let startIndex = 0;
  let endIndex = value.length;

  if (start) {
    let code = value.codePointAt(startIndex);

    while (code === tab || code === space) {
      startIndex++;
      code = value.codePointAt(startIndex);
    }
  }

  if (end) {
    let code = value.codePointAt(endIndex - 1);

    while (code === tab || code === space) {
      endIndex--;
      code = value.codePointAt(endIndex - 1);
    }
  }

  return endIndex > startIndex ? value.slice(startIndex, endIndex) : ''
}

/**
 * @typedef {import('hast').Element} HastElement
 * @typedef {import('hast').Text} HastText
 * @typedef {import('mdast').Text} MdastText
 * @typedef {import('../state.js').State} State
 */


/**
 * Turn an mdast `text` node into hast.
 *
 * @param {State} state
 *   Info passed around.
 * @param {MdastText} node
 *   mdast node.
 * @returns {HastText | HastElement}
 *   hast node.
 */
function text$1(state, node) {
  /** @type {HastText} */
  const result = {type: 'text', value: trimLines(String(node.value))};
  state.patch(node, result);
  return state.applyData(node, result)
}

/**
 * @typedef {import('hast').Element} Element
 * @typedef {import('mdast').ThematicBreak} ThematicBreak
 * @typedef {import('../state.js').State} State
 */

/**
 * Turn an mdast `thematicBreak` node into hast.
 *
 * @param {State} state
 *   Info passed around.
 * @param {ThematicBreak} node
 *   mdast node.
 * @returns {Element}
 *   hast node.
 */
function thematicBreak(state, node) {
  /** @type {Element} */
  const result = {
    type: 'element',
    tagName: 'hr',
    properties: {},
    children: []
  };
  state.patch(node, result);
  return state.applyData(node, result)
}

/**
 * Default handlers for nodes.
 */
const handlers = {
  blockquote,
  break: hardBreak,
  code: code$1,
  delete: strikethrough,
  emphasis,
  footnoteReference: footnoteReference$1,
  footnote,
  heading,
  html: html$2,
  imageReference,
  image,
  inlineCode: inlineCode$1,
  linkReference,
  link,
  listItem: listItem$1,
  list,
  paragraph,
  root,
  strong,
  table,
  tableCell,
  tableRow,
  text: text$1,
  thematicBreak,
  toml: ignore,
  yaml: ignore,
  definition: ignore,
  footnoteDefinition: ignore
};

// Return nothing for nodes that are ignored.
function ignore() {
  // To do: next major: return `undefined`.
  return null
}

/**
 * @typedef {import('unist').Node} Node
 * @typedef {import('unist').Parent} Parent
 */


/**
 * Generate an assertion from a test.
 *
 * Useful if you’re going to test many nodes, for example when creating a
 * utility where something else passes a compatible test.
 *
 * The created function is a bit faster because it expects valid input only:
 * a `node`, `index`, and `parent`.
 *
 * @param test
 *   *   when nullish, checks if `node` is a `Node`.
 *   *   when `string`, works like passing `(node) => node.type === test`.
 *   *   when `function` checks if function passed the node is true.
 *   *   when `object`, checks that all keys in test are in node, and that they have (strictly) equal values.
 *   *   when `array`, checks if any one of the subtests pass.
 * @returns
 *   An assertion.
 */
const convert =
  /**
   * @type {(
   *   (<Kind extends Node>(test: PredicateTest<Kind>) => AssertPredicate<Kind>) &
   *   ((test?: Test) => AssertAnything)
   * )}
   */
  (
    /**
     * @param {Test} [test]
     * @returns {AssertAnything}
     */
    function (test) {
      if (test === undefined || test === null) {
        return ok
      }

      if (typeof test === 'string') {
        return typeFactory(test)
      }

      if (typeof test === 'object') {
        return Array.isArray(test) ? anyFactory(test) : propsFactory(test)
      }

      if (typeof test === 'function') {
        return castFactory(test)
      }

      throw new Error('Expected function, string, or object as test')
    }
  );

/**
 * @param {Array<string | Props | TestFunctionAnything>} tests
 * @returns {AssertAnything}
 */
function anyFactory(tests) {
  /** @type {Array<AssertAnything>} */
  const checks = [];
  let index = -1;

  while (++index < tests.length) {
    checks[index] = convert(tests[index]);
  }

  return castFactory(any)

  /**
   * @this {unknown}
   * @param {Array<unknown>} parameters
   * @returns {boolean}
   */
  function any(...parameters) {
    let index = -1;

    while (++index < checks.length) {
      if (checks[index].call(this, ...parameters)) return true
    }

    return false
  }
}

/**
 * Turn an object into a test for a node with a certain fields.
 *
 * @param {Props} check
 * @returns {AssertAnything}
 */
function propsFactory(check) {
  return castFactory(all)

  /**
   * @param {Node} node
   * @returns {boolean}
   */
  function all(node) {
    /** @type {string} */
    let key;

    for (key in check) {
      // @ts-expect-error: hush, it sure works as an index.
      if (node[key] !== check[key]) return false
    }

    return true
  }
}

/**
 * Turn a string into a test for a node with a certain type.
 *
 * @param {string} check
 * @returns {AssertAnything}
 */
function typeFactory(check) {
  return castFactory(type)

  /**
   * @param {Node} node
   */
  function type(node) {
    return node && node.type === check
  }
}

/**
 * Turn a custom test into a test for a node that passes that test.
 *
 * @param {TestFunctionAnything} check
 * @returns {AssertAnything}
 */
function castFactory(check) {
  return assertion

  /**
   * @this {unknown}
   * @param {unknown} node
   * @param {Array<unknown>} parameters
   * @returns {boolean}
   */
  function assertion(node, ...parameters) {
    return Boolean(
      node &&
        typeof node === 'object' &&
        'type' in node &&
        // @ts-expect-error: fine.
        Boolean(check.call(this, node, ...parameters))
    )
  }
}

function ok() {
  return true
}

/**
 * @param {string} d
 * @returns {string}
 */
function color(d) {
  return d
}

/**
 * @typedef {import('unist').Node} Node
 * @typedef {import('unist').Parent} Parent
 * @typedef {import('unist-util-is').Test} Test
 */


/**
 * Continue traversing as normal.
 */
const CONTINUE = true;

/**
 * Stop traversing immediately.
 */
const EXIT = false;

/**
 * Do not traverse this node’s children.
 */
const SKIP = 'skip';

/**
 * Visit nodes, with ancestral information.
 *
 * This algorithm performs *depth-first* *tree traversal* in *preorder*
 * (**NLR**) or if `reverse` is given, in *reverse preorder* (**NRL**).
 *
 * You can choose for which nodes `visitor` is called by passing a `test`.
 * For complex tests, you should test yourself in `visitor`, as it will be
 * faster and will have improved type information.
 *
 * Walking the tree is an intensive task.
 * Make use of the return values of the visitor when possible.
 * Instead of walking a tree multiple times, walk it once, use `unist-util-is`
 * to check if a node matches, and then perform different operations.
 *
 * You can change the tree.
 * See `Visitor` for more info.
 *
 * @param tree
 *   Tree to traverse.
 * @param test
 *   `unist-util-is`-compatible test
 * @param visitor
 *   Handle each node.
 * @param reverse
 *   Traverse in reverse preorder (NRL) instead of the default preorder (NLR).
 * @returns
 *   Nothing.
 */
const visitParents =
  /**
   * @type {(
   *   (<Tree extends Node, Check extends Test>(tree: Tree, test: Check, visitor: BuildVisitor<Tree, Check>, reverse?: boolean | null | undefined) => void) &
   *   (<Tree extends Node>(tree: Tree, visitor: BuildVisitor<Tree>, reverse?: boolean | null | undefined) => void)
   * )}
   */
  (
    /**
     * @param {Node} tree
     * @param {Test} test
     * @param {Visitor<Node>} visitor
     * @param {boolean | null | undefined} [reverse]
     * @returns {void}
     */
    function (tree, test, visitor, reverse) {
      if (typeof test === 'function' && typeof visitor !== 'function') {
        reverse = visitor;
        // @ts-expect-error no visitor given, so `visitor` is test.
        visitor = test;
        test = null;
      }

      const is = convert(test);
      const step = reverse ? -1 : 1;

      factory(tree, undefined, [])();

      /**
       * @param {Node} node
       * @param {number | undefined} index
       * @param {Array<Parent>} parents
       */
      function factory(node, index, parents) {
        /** @type {Record<string, unknown>} */
        // @ts-expect-error: hush
        const value = node && typeof node === 'object' ? node : {};

        if (typeof value.type === 'string') {
          const name =
            // `hast`
            typeof value.tagName === 'string'
              ? value.tagName
              : // `xast`
              typeof value.name === 'string'
              ? value.name
              : undefined;

          Object.defineProperty(visit, 'name', {
            value:
              'node (' + color(node.type + (name ? '<' + name + '>' : '')) + ')'
          });
        }

        return visit

        function visit() {
          /** @type {ActionTuple} */
          let result = [];
          /** @type {ActionTuple} */
          let subresult;
          /** @type {number} */
          let offset;
          /** @type {Array<Parent>} */
          let grandparents;

          if (!test || is(node, index, parents[parents.length - 1] || null)) {
            result = toResult(visitor(node, parents));

            if (result[0] === EXIT) {
              return result
            }
          }

          // @ts-expect-error looks like a parent.
          if (node.children && result[0] !== SKIP) {
            // @ts-expect-error looks like a parent.
            offset = (reverse ? node.children.length : -1) + step;
            // @ts-expect-error looks like a parent.
            grandparents = parents.concat(node);

            // @ts-expect-error looks like a parent.
            while (offset > -1 && offset < node.children.length) {
              // @ts-expect-error looks like a parent.
              subresult = factory(node.children[offset], offset, grandparents)();

              if (subresult[0] === EXIT) {
                return subresult
              }

              offset =
                typeof subresult[1] === 'number' ? subresult[1] : offset + step;
            }
          }

          return result
        }
      }
    }
  );

/**
 * Turn a return value into a clean result.
 *
 * @param {VisitorResult} value
 *   Valid return values from visitors.
 * @returns {ActionTuple}
 *   Clean result.
 */
function toResult(value) {
  if (Array.isArray(value)) {
    return value
  }

  if (typeof value === 'number') {
    return [CONTINUE, value]
  }

  return [value]
}

/**
 * @typedef {import('unist').Node} Node
 * @typedef {import('unist').Parent} Parent
 * @typedef {import('unist-util-is').Test} Test
 * @typedef {import('unist-util-visit-parents').VisitorResult} VisitorResult
 */


/**
 * Visit nodes.
 *
 * This algorithm performs *depth-first* *tree traversal* in *preorder*
 * (**NLR**) or if `reverse` is given, in *reverse preorder* (**NRL**).
 *
 * You can choose for which nodes `visitor` is called by passing a `test`.
 * For complex tests, you should test yourself in `visitor`, as it will be
 * faster and will have improved type information.
 *
 * Walking the tree is an intensive task.
 * Make use of the return values of the visitor when possible.
 * Instead of walking a tree multiple times, walk it once, use `unist-util-is`
 * to check if a node matches, and then perform different operations.
 *
 * You can change the tree.
 * See `Visitor` for more info.
 *
 * @param tree
 *   Tree to traverse.
 * @param test
 *   `unist-util-is`-compatible test
 * @param visitor
 *   Handle each node.
 * @param reverse
 *   Traverse in reverse preorder (NRL) instead of the default preorder (NLR).
 * @returns
 *   Nothing.
 */
const visit =
  /**
   * @type {(
   *   (<Tree extends Node, Check extends Test>(tree: Tree, test: Check, visitor: BuildVisitor<Tree, Check>, reverse?: boolean | null | undefined) => void) &
   *   (<Tree extends Node>(tree: Tree, visitor: BuildVisitor<Tree>, reverse?: boolean | null | undefined) => void)
   * )}
   */
  (
    /**
     * @param {Node} tree
     * @param {Test} test
     * @param {Visitor} visitor
     * @param {boolean | null | undefined} [reverse]
     * @returns {void}
     */
    function (tree, test, visitor, reverse) {
      if (typeof test === 'function' && typeof visitor !== 'function') {
        reverse = visitor;
        visitor = test;
        test = null;
      }

      visitParents(tree, test, overload, reverse);

      /**
       * @param {Node} node
       * @param {Array<Parent>} parents
       */
      function overload(node, parents) {
        const parent = parents[parents.length - 1];
        return visitor(
          node,
          parent ? parent.children.indexOf(node) : null,
          parent
        )
      }
    }
  );

/**
 * @typedef PointLike
 * @property {number | null | undefined} [line]
 * @property {number | null | undefined} [column]
 * @property {number | null | undefined} [offset]
 *
 * @typedef PositionLike
 * @property {PointLike | null | undefined} [start]
 * @property {PointLike | null | undefined} [end]
 *
 * @typedef NodeLike
 * @property {PositionLike | null | undefined} [position]
 */

/**
 * Check if `node` is generated.
 *
 * @param {NodeLike | null | undefined} [node]
 *   Node to check.
 * @returns {boolean}
 *   Whether `node` is generated (does not have positional info).
 */
function generated(node) {
  return (
    !node ||
    !node.position ||
    !node.position.start ||
    !node.position.start.line ||
    !node.position.start.column ||
    !node.position.end ||
    !node.position.end.line ||
    !node.position.end.column
  )
}

/**
 * @typedef {import('mdast').Root} Root
 * @typedef {import('mdast').Content} Content
 * @typedef {import('mdast').Definition} Definition
 */


const own$5 = {}.hasOwnProperty;

/**
 * Find definitions in `tree`.
 *
 * Uses CommonMark precedence, which means that earlier definitions are
 * preferred over duplicate later definitions.
 *
 * @param {Node} tree
 *   Tree to check.
 * @returns {GetDefinition}
 *   Getter.
 */
function definitions(tree) {
  /** @type {Record<string, Definition>} */
  const cache = Object.create(null);

  if (!tree || !tree.type) {
    throw new Error('mdast-util-definitions expected node')
  }

  visit(tree, 'definition', (definition) => {
    const id = clean(definition.identifier);
    if (id && !own$5.call(cache, id)) {
      cache[id] = definition;
    }
  });

  return definition

  /** @type {GetDefinition} */
  function definition(identifier) {
    const id = clean(identifier);
    // To do: next major: return `undefined` when not found.
    return id && own$5.call(cache, id) ? cache[id] : null
  }
}

/**
 * @param {string | null | undefined} [value]
 * @returns {string}
 */
function clean(value) {
  return String(value || '').toUpperCase()
}

/**
 * @typedef {import('hast').Content} HastContent
 * @typedef {import('hast').Element} HastElement
 * @typedef {import('hast').ElementContent} HastElementContent
 * @typedef {import('hast').Properties} HastProperties
 * @typedef {import('hast').Root} HastRoot
 * @typedef {import('hast').Text} HastText
 *
 * @typedef {import('mdast').Content} MdastContent
 * @typedef {import('mdast').Definition} MdastDefinition
 * @typedef {import('mdast').FootnoteDefinition} MdastFootnoteDefinition
 * @typedef {import('mdast').Parent} MdastParent
 * @typedef {import('mdast').Root} MdastRoot
 */


const own$4 = {}.hasOwnProperty;

/**
 * Create `state` from an mdast tree.
 *
 * @param {MdastNodes} tree
 *   mdast node to transform.
 * @param {Options | null | undefined} [options]
 *   Configuration.
 * @returns {State}
 *   `state` function.
 */
function createState(tree, options) {
  const settings = options || {};
  const dangerous = settings.allowDangerousHtml || false;
  /** @type {Record<string, MdastFootnoteDefinition>} */
  const footnoteById = {};

  // To do: next major: add `options` to state, remove:
  // `dangerous`, `clobberPrefix`, `footnoteLabel`, `footnoteLabelTagName`,
  // `footnoteLabelProperties`, `footnoteBackLabel`, `passThrough`,
  // `unknownHandler`.

  // To do: next major: move to `state.options.allowDangerousHtml`.
  state.dangerous = dangerous;
  // To do: next major: move to `state.options`.
  state.clobberPrefix =
    settings.clobberPrefix === undefined || settings.clobberPrefix === null
      ? 'user-content-'
      : settings.clobberPrefix;
  // To do: next major: move to `state.options`.
  state.footnoteLabel = settings.footnoteLabel || 'Footnotes';
  // To do: next major: move to `state.options`.
  state.footnoteLabelTagName = settings.footnoteLabelTagName || 'h2';
  // To do: next major: move to `state.options`.
  state.footnoteLabelProperties = settings.footnoteLabelProperties || {
    className: ['sr-only']
  };
  // To do: next major: move to `state.options`.
  state.footnoteBackLabel = settings.footnoteBackLabel || 'Back to content';
  // To do: next major: move to `state.options`.
  state.unknownHandler = settings.unknownHandler;
  // To do: next major: move to `state.options`.
  state.passThrough = settings.passThrough;

  state.handlers = {...handlers, ...settings.handlers};

  // To do: next major: replace utility with `definitionById` object, so we
  // only walk once (as we need footnotes too).
  state.definition = definitions(tree);
  state.footnoteById = footnoteById;
  /** @type {Array<string>} */
  state.footnoteOrder = [];
  /** @type {Record<string, number>} */
  state.footnoteCounts = {};

  state.patch = patch;
  state.applyData = applyData;
  state.one = oneBound;
  state.all = allBound;
  state.wrap = wrap;
  // To do: next major: remove `augment`.
  state.augment = augment;

  visit(tree, 'footnoteDefinition', (definition) => {
    const id = String(definition.identifier).toUpperCase();

    // Mimick CM behavior of link definitions.
    // See: <https://github.com/syntax-tree/mdast-util-definitions/blob/8290999/index.js#L26>.
    if (!own$4.call(footnoteById, id)) {
      footnoteById[id] = definition;
    }
  });

  // @ts-expect-error Hush, it’s fine!
  return state

  /**
   * Finalise the created `right`, a hast node, from `left`, an mdast node.
   *
   * @param {MdastNodeWithData | PositionLike | null | undefined} left
   * @param {HastElementContent} right
   * @returns {HastElementContent}
   */
  /* c8 ignore start */
  // To do: next major: remove.
  function augment(left, right) {
    // Handle `data.hName`, `data.hProperties, `data.hChildren`.
    if (left && 'data' in left && left.data) {
      /** @type {MdastData} */
      const data = left.data;

      if (data.hName) {
        if (right.type !== 'element') {
          right = {
            type: 'element',
            tagName: '',
            properties: {},
            children: []
          };
        }

        right.tagName = data.hName;
      }

      if (right.type === 'element' && data.hProperties) {
        right.properties = {...right.properties, ...data.hProperties};
      }

      if ('children' in right && right.children && data.hChildren) {
        right.children = data.hChildren;
      }
    }

    if (left) {
      const ctx = 'type' in left ? left : {position: left};

      if (!generated(ctx)) {
        // @ts-expect-error: fine.
        right.position = {start: pointStart(ctx), end: pointEnd(ctx)};
      }
    }

    return right
  }
  /* c8 ignore stop */

  /**
   * Create an element for `node`.
   *
   * @type {HFunctionProps}
   */
  /* c8 ignore start */
  // To do: next major: remove.
  function state(node, tagName, props, children) {
    if (Array.isArray(props)) {
      children = props;
      props = {};
    }

    // @ts-expect-error augmenting an element yields an element.
    return augment(node, {
      type: 'element',
      tagName,
      properties: props || {},
      children: children || []
    })
  }
  /* c8 ignore stop */

  /**
   * Transform an mdast node into a hast node.
   *
   * @param {MdastNodes} node
   *   mdast node.
   * @param {MdastParents | null | undefined} [parent]
   *   Parent of `node`.
   * @returns {HastElementContent | Array<HastElementContent> | null | undefined}
   *   Resulting hast node.
   */
  function oneBound(node, parent) {
    // @ts-expect-error: that’s a state :)
    return one(state, node, parent)
  }

  /**
   * Transform the children of an mdast node into hast nodes.
   *
   * @param {MdastNodes} parent
   *   mdast node to compile
   * @returns {Array<HastElementContent>}
   *   Resulting hast nodes.
   */
  function allBound(parent) {
    // @ts-expect-error: that’s a state :)
    return all(state, parent)
  }
}

/**
 * Copy a node’s positional info.
 *
 * @param {MdastNodes} from
 *   mdast node to copy from.
 * @param {HastNodes} to
 *   hast node to copy into.
 * @returns {void}
 *   Nothing.
 */
function patch(from, to) {
  if (from.position) to.position = position(from);
}

/**
 * Honor the `data` of `from` and maybe generate an element instead of `to`.
 *
 * @template {HastNodes} Type
 *   Node type.
 * @param {MdastNodes} from
 *   mdast node to use data from.
 * @param {Type} to
 *   hast node to change.
 * @returns {Type | HastElement}
 *   Nothing.
 */
function applyData(from, to) {
  /** @type {Type | HastElement} */
  let result = to;

  // Handle `data.hName`, `data.hProperties, `data.hChildren`.
  if (from && from.data) {
    const hName = from.data.hName;
    const hChildren = from.data.hChildren;
    const hProperties = from.data.hProperties;

    if (typeof hName === 'string') {
      // Transforming the node resulted in an element with a different name
      // than wanted:
      if (result.type === 'element') {
        result.tagName = hName;
      }
      // Transforming the node resulted in a non-element, which happens for
      // raw, text, and root nodes (unless custom handlers are passed).
      // The intent is likely to keep the content around (otherwise: pass
      // `hChildren`).
      else {
        result = {
          type: 'element',
          tagName: hName,
          properties: {},
          children: []
        };

        // To do: next major: take the children from the `root`, or inject the
        // raw/text/comment or so into the element?
        // if ('children' in node) {
        //   // @ts-expect-error: assume `children` are allowed in elements.
        //   result.children = node.children
        // } else {
        //   // @ts-expect-error: assume `node` is allowed in elements.
        //   result.children.push(node)
        // }
      }
    }

    if (result.type === 'element' && hProperties) {
      result.properties = {...result.properties, ...hProperties};
    }

    if (
      'children' in result &&
      result.children &&
      hChildren !== null &&
      hChildren !== undefined
    ) {
      // @ts-expect-error: assume valid children are defined.
      result.children = hChildren;
    }
  }

  return result
}

/**
 * Transform an mdast node into a hast node.
 *
 * @param {State} state
 *   Info passed around.
 * @param {MdastNodes} node
 *   mdast node.
 * @param {MdastParents | null | undefined} [parent]
 *   Parent of `node`.
 * @returns {HastElementContent | Array<HastElementContent> | null | undefined}
 *   Resulting hast node.
 */
// To do: next major: do not expose, keep bound.
function one(state, node, parent) {
  const type = node && node.type;

  // Fail on non-nodes.
  if (!type) {
    throw new Error('Expected node, got `' + node + '`')
  }

  if (own$4.call(state.handlers, type)) {
    return state.handlers[type](state, node, parent)
  }

  if (state.passThrough && state.passThrough.includes(type)) {
    // To do: next major: deep clone.
    // @ts-expect-error: types of passed through nodes are expected to be added manually.
    return 'children' in node ? {...node, children: all(state, node)} : node
  }

  if (state.unknownHandler) {
    return state.unknownHandler(state, node, parent)
  }

  return defaultUnknownHandler(state, node)
}

/**
 * Transform the children of an mdast node into hast nodes.
 *
 * @param {State} state
 *   Info passed around.
 * @param {MdastNodes} parent
 *   mdast node to compile
 * @returns {Array<HastElementContent>}
 *   Resulting hast nodes.
 */
// To do: next major: do not expose, keep bound.
function all(state, parent) {
  /** @type {Array<HastElementContent>} */
  const values = [];

  if ('children' in parent) {
    const nodes = parent.children;
    let index = -1;
    while (++index < nodes.length) {
      const result = one(state, nodes[index], parent);

      // To do: see if we van clean this? Can we merge texts?
      if (result) {
        if (index && nodes[index - 1].type === 'break') {
          if (!Array.isArray(result) && result.type === 'text') {
            result.value = result.value.replace(/^\s+/, '');
          }

          if (!Array.isArray(result) && result.type === 'element') {
            const head = result.children[0];

            if (head && head.type === 'text') {
              head.value = head.value.replace(/^\s+/, '');
            }
          }
        }

        if (Array.isArray(result)) {
          values.push(...result);
        } else {
          values.push(result);
        }
      }
    }
  }

  return values
}

/**
 * Transform an unknown node.
 *
 * @param {State} state
 *   Info passed around.
 * @param {MdastNodes} node
 *   Unknown mdast node.
 * @returns {HastText | HastElement}
 *   Resulting hast node.
 */
function defaultUnknownHandler(state, node) {
  const data = node.data || {};
  /** @type {HastText | HastElement} */
  const result =
    'value' in node &&
    !(own$4.call(data, 'hProperties') || own$4.call(data, 'hChildren'))
      ? {type: 'text', value: node.value}
      : {
          type: 'element',
          tagName: 'div',
          properties: {},
          children: all(state, node)
        };

  state.patch(node, result);
  return state.applyData(node, result)
}

/**
 * Wrap `nodes` with line endings between each node.
 *
 * @template {HastContent} Type
 *   Node type.
 * @param {Array<Type>} nodes
 *   List of nodes to wrap.
 * @param {boolean | null | undefined} [loose=false]
 *   Whether to add line endings at start and end.
 * @returns {Array<Type | HastText>}
 *   Wrapped nodes.
 */
function wrap(nodes, loose) {
  /** @type {Array<Type | HastText>} */
  const result = [];
  let index = -1;

  if (loose) {
    result.push({type: 'text', value: '\n'});
  }

  while (++index < nodes.length) {
    if (index) result.push({type: 'text', value: '\n'});
    result.push(nodes[index]);
  }

  if (loose && nodes.length > 0) {
    result.push({type: 'text', value: '\n'});
  }

  return result
}

/**
 * @typedef {import('hast').Element} Element
 * @typedef {import('hast').ElementContent} ElementContent
 *
 * @typedef {import('./state.js').State} State
 */


/**
 * Generate a hast footer for called footnote definitions.
 *
 * @param {State} state
 *   Info passed around.
 * @returns {Element | undefined}
 *   `section` element or `undefined`.
 */
function footer(state) {
  /** @type {Array<ElementContent>} */
  const listItems = [];
  let index = -1;

  while (++index < state.footnoteOrder.length) {
    const def = state.footnoteById[state.footnoteOrder[index]];

    if (!def) {
      continue
    }

    const content = state.all(def);
    const id = String(def.identifier).toUpperCase();
    const safeId = normalizeUri(id.toLowerCase());
    let referenceIndex = 0;
    /** @type {Array<ElementContent>} */
    const backReferences = [];

    while (++referenceIndex <= state.footnoteCounts[id]) {
      /** @type {Element} */
      const backReference = {
        type: 'element',
        tagName: 'a',
        properties: {
          href:
            '#' +
            state.clobberPrefix +
            'fnref-' +
            safeId +
            (referenceIndex > 1 ? '-' + referenceIndex : ''),
          dataFootnoteBackref: true,
          className: ['data-footnote-backref'],
          ariaLabel: state.footnoteBackLabel
        },
        children: [{type: 'text', value: '↩'}]
      };

      if (referenceIndex > 1) {
        backReference.children.push({
          type: 'element',
          tagName: 'sup',
          children: [{type: 'text', value: String(referenceIndex)}]
        });
      }

      if (backReferences.length > 0) {
        backReferences.push({type: 'text', value: ' '});
      }

      backReferences.push(backReference);
    }

    const tail = content[content.length - 1];

    if (tail && tail.type === 'element' && tail.tagName === 'p') {
      const tailTail = tail.children[tail.children.length - 1];
      if (tailTail && tailTail.type === 'text') {
        tailTail.value += ' ';
      } else {
        tail.children.push({type: 'text', value: ' '});
      }

      tail.children.push(...backReferences);
    } else {
      content.push(...backReferences);
    }

    /** @type {Element} */
    const listItem = {
      type: 'element',
      tagName: 'li',
      properties: {id: state.clobberPrefix + 'fn-' + safeId},
      children: state.wrap(content, true)
    };

    state.patch(def, listItem);

    listItems.push(listItem);
  }

  if (listItems.length === 0) {
    return
  }

  return {
    type: 'element',
    tagName: 'section',
    properties: {dataFootnotes: true, className: ['footnotes']},
    children: [
      {
        type: 'element',
        tagName: state.footnoteLabelTagName,
        properties: {
          // To do: use structured clone.
          ...JSON.parse(JSON.stringify(state.footnoteLabelProperties)),
          id: 'footnote-label'
        },
        children: [{type: 'text', value: state.footnoteLabel}]
      },
      {type: 'text', value: '\n'},
      {
        type: 'element',
        tagName: 'ol',
        properties: {},
        children: state.wrap(listItems, true)
      },
      {type: 'text', value: '\n'}
    ]
  }
}

/**
 * @typedef {import('hast').Content} HastContent
 * @typedef {import('hast').Root} HastRoot
 *
 * @typedef {import('mdast').Content} MdastContent
 * @typedef {import('mdast').Root} MdastRoot
 *
 * @typedef {import('./state.js').Options} Options
 */


/**
 * Transform mdast to hast.
 *
 * ##### Notes
 *
 * ###### HTML
 *
 * Raw HTML is available in mdast as `html` nodes and can be embedded in hast
 * as semistandard `raw` nodes.
 * Most utilities ignore `raw` nodes but two notable ones don’t:
 *
 * *   `hast-util-to-html` also has an option `allowDangerousHtml` which will
 *     output the raw HTML.
 *     This is typically discouraged as noted by the option name but is useful
 *     if you completely trust authors
 * *   `hast-util-raw` can handle the raw embedded HTML strings by parsing them
 *     into standard hast nodes (`element`, `text`, etc).
 *     This is a heavy task as it needs a full HTML parser, but it is the only
 *     way to support untrusted content
 *
 * ###### Footnotes
 *
 * Many options supported here relate to footnotes.
 * Footnotes are not specified by CommonMark, which we follow by default.
 * They are supported by GitHub, so footnotes can be enabled in markdown with
 * `mdast-util-gfm`.
 *
 * The options `footnoteBackLabel` and `footnoteLabel` define natural language
 * that explains footnotes, which is hidden for sighted users but shown to
 * assistive technology.
 * When your page is not in English, you must define translated values.
 *
 * Back references use ARIA attributes, but the section label itself uses a
 * heading that is hidden with an `sr-only` class.
 * To show it to sighted users, define different attributes in
 * `footnoteLabelProperties`.
 *
 * ###### Clobbering
 *
 * Footnotes introduces a problem, as it links footnote calls to footnote
 * definitions on the page through `id` attributes generated from user content,
 * which results in DOM clobbering.
 *
 * DOM clobbering is this:
 *
 * ```html
 * <p id=x></p>
 * <script>alert(x) // `x` now refers to the DOM `p#x` element</script>
 * ```
 *
 * Elements by their ID are made available by browsers on the `window` object,
 * which is a security risk.
 * Using a prefix solves this problem.
 *
 * More information on how to handle clobbering and the prefix is explained in
 * Example: headings (DOM clobbering) in `rehype-sanitize`.
 *
 * ###### Unknown nodes
 *
 * Unknown nodes are nodes with a type that isn’t in `handlers` or `passThrough`.
 * The default behavior for unknown nodes is:
 *
 * *   when the node has a `value` (and doesn’t have `data.hName`,
 *     `data.hProperties`, or `data.hChildren`, see later), create a hast `text`
 *     node
 * *   otherwise, create a `<div>` element (which could be changed with
 *     `data.hName`), with its children mapped from mdast to hast as well
 *
 * This behavior can be changed by passing an `unknownHandler`.
 *
 * @param {MdastNodes} tree
 *   mdast tree.
 * @param {Options | null | undefined} [options]
 *   Configuration.
 * @returns {HastNodes | null | undefined}
 *   hast tree.
 */
// To do: next major: always return a single `root`.
function toHast(tree, options) {
  const state = createState(tree, options);
  const node = state.one(tree, null);
  const foot = footer(state);

  if (foot) {
    // @ts-expect-error If there’s a footer, there were definitions, meaning block
    // content.
    // So assume `node` is a parent node.
    node.children.push({type: 'text', value: '\n'}, foot);
  }

  // To do: next major: always return root?
  return Array.isArray(node) ? {type: 'root', children: node} : node
}

/**
 * @typedef {import('hast').Root} HastRoot
 * @typedef {import('mdast').Root} MdastRoot
 * @typedef {import('mdast-util-to-hast').Options} Options
 * @typedef {import('unified').Processor<any, any, any, any>} Processor
 *
 * @typedef {import('mdast-util-to-hast')} DoNotTouchAsThisImportIncludesRawInTree
 */


// Note: the `<MdastRoot, HastRoot>` overload doesn’t seem to work :'(

/**
 * Plugin that turns markdown into HTML to support rehype.
 *
 * *   If a destination processor is given, that processor runs with a new HTML
 *     (hast) tree (bridge-mode).
 *     As the given processor runs with a hast tree, and rehype plugins support
 *     hast, that means rehype plugins can be used with the given processor.
 *     The hast tree is discarded in the end.
 *     It’s highly unlikely that you want to do this.
 * *   The common case is to not pass a destination processor, in which case the
 *     current processor continues running with a new HTML (hast) tree
 *     (mutate-mode).
 *     As the current processor continues with a hast tree, and rehype plugins
 *     support hast, that means rehype plugins can be used after
 *     `remark-rehype`.
 *     It’s likely that this is what you want to do.
 *
 * @param destination
 *   Optional unified processor.
 * @param options
 *   Options passed to `mdast-util-to-hast`.
 */
const remarkRehype =
  /** @type {(import('unified').Plugin<[Processor, Options?]|[null|undefined, Options?]|[Options]|[], MdastRoot>)} */
  (
    function (destination, options) {
      return destination && 'run' in destination
        ? bridge(destination, options)
        : mutate(destination || options)
    }
  );

/**
 * Bridge-mode.
 * Runs the destination with the new hast tree.
 *
 * @type {import('unified').Plugin<[Processor, Options?], MdastRoot>}
 */
function bridge(destination, options) {
  return (node, file, next) => {
    destination.run(toHast(node, options), file, (error) => {
      next(error);
    });
  }
}

/**
 * Mutate-mode.
 * Further plugins run on the hast tree.
 *
 * @type {import('unified').Plugin<[Options?]|void[], MdastRoot, HastRoot>}
 */
function mutate(options) {
  // @ts-expect-error: assume a corresponding node is returned by `toHast`.
  return (node) => toHast(node, options)
}

var propTypes = {exports: {}};

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var ReactPropTypesSecret_1;
var hasRequiredReactPropTypesSecret;

function requireReactPropTypesSecret () {
	if (hasRequiredReactPropTypesSecret) return ReactPropTypesSecret_1;
	hasRequiredReactPropTypesSecret = 1;

	var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

	ReactPropTypesSecret_1 = ReactPropTypesSecret;
	return ReactPropTypesSecret_1;
}

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var factoryWithThrowingShims;
var hasRequiredFactoryWithThrowingShims;

function requireFactoryWithThrowingShims () {
	if (hasRequiredFactoryWithThrowingShims) return factoryWithThrowingShims;
	hasRequiredFactoryWithThrowingShims = 1;

	var ReactPropTypesSecret = requireReactPropTypesSecret();

	function emptyFunction() {}
	function emptyFunctionWithReset() {}
	emptyFunctionWithReset.resetWarningCache = emptyFunction;

	factoryWithThrowingShims = function() {
	  function shim(props, propName, componentName, location, propFullName, secret) {
	    if (secret === ReactPropTypesSecret) {
	      // It is still safe when called from React.
	      return;
	    }
	    var err = new Error(
	      'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
	      'Use PropTypes.checkPropTypes() to call them. ' +
	      'Read more at http://fb.me/use-check-prop-types'
	    );
	    err.name = 'Invariant Violation';
	    throw err;
	  }	  shim.isRequired = shim;
	  function getShim() {
	    return shim;
	  }	  // Important!
	  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.
	  var ReactPropTypes = {
	    array: shim,
	    bigint: shim,
	    bool: shim,
	    func: shim,
	    number: shim,
	    object: shim,
	    string: shim,
	    symbol: shim,

	    any: shim,
	    arrayOf: getShim,
	    element: shim,
	    elementType: shim,
	    instanceOf: getShim,
	    node: shim,
	    objectOf: getShim,
	    oneOf: getShim,
	    oneOfType: getShim,
	    shape: getShim,
	    exact: getShim,

	    checkPropTypes: emptyFunctionWithReset,
	    resetWarningCache: emptyFunction
	  };

	  ReactPropTypes.PropTypes = ReactPropTypes;

	  return ReactPropTypes;
	};
	return factoryWithThrowingShims;
}

{
  // By explicitly using `prop-types` you are opting into new production behavior.
  // http://fb.me/prop-types-in-prod
  propTypes.exports = requireFactoryWithThrowingShims()();
}

var propTypesExports = propTypes.exports;
var PropTypes = /*@__PURE__*/getDefaultExportFromCjs(propTypesExports);

/**
 * @typedef {import('./info.js').Info} Info
 * @typedef {Record<string, Info>} Properties
 * @typedef {Record<string, string>} Normal
 */

class Schema {
  /**
   * @constructor
   * @param {Properties} property
   * @param {Normal} normal
   * @param {string} [space]
   */
  constructor(property, normal, space) {
    this.property = property;
    this.normal = normal;
    if (space) {
      this.space = space;
    }
  }
}

/** @type {Properties} */
Schema.prototype.property = {};
/** @type {Normal} */
Schema.prototype.normal = {};
/** @type {string|null} */
Schema.prototype.space = null;

/**
 * @typedef {import('./schema.js').Properties} Properties
 * @typedef {import('./schema.js').Normal} Normal
 */


/**
 * @param {Schema[]} definitions
 * @param {string} [space]
 * @returns {Schema}
 */
function merge(definitions, space) {
  /** @type {Properties} */
  const property = {};
  /** @type {Normal} */
  const normal = {};
  let index = -1;

  while (++index < definitions.length) {
    Object.assign(property, definitions[index].property);
    Object.assign(normal, definitions[index].normal);
  }

  return new Schema(property, normal, space)
}

/**
 * @param {string} value
 * @returns {string}
 */
function normalize(value) {
  return value.toLowerCase()
}

class Info {
  /**
   * @constructor
   * @param {string} property
   * @param {string} attribute
   */
  constructor(property, attribute) {
    /** @type {string} */
    this.property = property;
    /** @type {string} */
    this.attribute = attribute;
  }
}

/** @type {string|null} */
Info.prototype.space = null;
Info.prototype.boolean = false;
Info.prototype.booleanish = false;
Info.prototype.overloadedBoolean = false;
Info.prototype.number = false;
Info.prototype.commaSeparated = false;
Info.prototype.spaceSeparated = false;
Info.prototype.commaOrSpaceSeparated = false;
Info.prototype.mustUseProperty = false;
Info.prototype.defined = false;

let powers = 0;

const boolean = increment();
const booleanish = increment();
const overloadedBoolean = increment();
const number = increment();
const spaceSeparated = increment();
const commaSeparated = increment();
const commaOrSpaceSeparated = increment();

function increment() {
  return 2 ** ++powers
}

var types = /*#__PURE__*/Object.freeze({
    __proto__: null,
    boolean: boolean,
    booleanish: booleanish,
    commaOrSpaceSeparated: commaOrSpaceSeparated,
    commaSeparated: commaSeparated,
    number: number,
    overloadedBoolean: overloadedBoolean,
    spaceSeparated: spaceSeparated
});

/** @type {Array<keyof types>} */
// @ts-expect-error: hush.
const checks = Object.keys(types);

class DefinedInfo extends Info {
  /**
   * @constructor
   * @param {string} property
   * @param {string} attribute
   * @param {number|null} [mask]
   * @param {string} [space]
   */
  constructor(property, attribute, mask, space) {
    let index = -1;

    super(property, attribute);

    mark(this, 'space', space);

    if (typeof mask === 'number') {
      while (++index < checks.length) {
        const check = checks[index];
        mark(this, checks[index], (mask & types[check]) === types[check]);
      }
    }
  }
}

DefinedInfo.prototype.defined = true;

/**
 * @param {DefinedInfo} values
 * @param {string} key
 * @param {unknown} value
 */
function mark(values, key, value) {
  if (value) {
    // @ts-expect-error: assume `value` matches the expected value of `key`.
    values[key] = value;
  }
}

/**
 * @typedef {import('./schema.js').Properties} Properties
 * @typedef {import('./schema.js').Normal} Normal
 *
 * @typedef {Record<string, string>} Attributes
 *
 * @typedef {Object} Definition
 * @property {Record<string, number|null>} properties
 * @property {(attributes: Attributes, property: string) => string} transform
 * @property {string} [space]
 * @property {Attributes} [attributes]
 * @property {Array<string>} [mustUseProperty]
 */


const own$3 = {}.hasOwnProperty;

/**
 * @param {Definition} definition
 * @returns {Schema}
 */
function create(definition) {
  /** @type {Properties} */
  const property = {};
  /** @type {Normal} */
  const normal = {};
  /** @type {string} */
  let prop;

  for (prop in definition.properties) {
    if (own$3.call(definition.properties, prop)) {
      const value = definition.properties[prop];
      const info = new DefinedInfo(
        prop,
        definition.transform(definition.attributes || {}, prop),
        value,
        definition.space
      );

      if (
        definition.mustUseProperty &&
        definition.mustUseProperty.includes(prop)
      ) {
        info.mustUseProperty = true;
      }

      property[prop] = info;

      normal[normalize(prop)] = prop;
      normal[normalize(info.attribute)] = prop;
    }
  }

  return new Schema(property, normal, definition.space)
}

const xlink = create({
  space: 'xlink',
  transform(_, prop) {
    return 'xlink:' + prop.slice(5).toLowerCase()
  },
  properties: {
    xLinkActuate: null,
    xLinkArcRole: null,
    xLinkHref: null,
    xLinkRole: null,
    xLinkShow: null,
    xLinkTitle: null,
    xLinkType: null
  }
});

const xml = create({
  space: 'xml',
  transform(_, prop) {
    return 'xml:' + prop.slice(3).toLowerCase()
  },
  properties: {xmlLang: null, xmlBase: null, xmlSpace: null}
});

/**
 * @param {Record<string, string>} attributes
 * @param {string} attribute
 * @returns {string}
 */
function caseSensitiveTransform(attributes, attribute) {
  return attribute in attributes ? attributes[attribute] : attribute
}

/**
 * @param {Record<string, string>} attributes
 * @param {string} property
 * @returns {string}
 */
function caseInsensitiveTransform(attributes, property) {
  return caseSensitiveTransform(attributes, property.toLowerCase())
}

const xmlns = create({
  space: 'xmlns',
  attributes: {xmlnsxlink: 'xmlns:xlink'},
  transform: caseInsensitiveTransform,
  properties: {xmlns: null, xmlnsXLink: null}
});

const aria = create({
  transform(_, prop) {
    return prop === 'role' ? prop : 'aria-' + prop.slice(4).toLowerCase()
  },
  properties: {
    ariaActiveDescendant: null,
    ariaAtomic: booleanish,
    ariaAutoComplete: null,
    ariaBusy: booleanish,
    ariaChecked: booleanish,
    ariaColCount: number,
    ariaColIndex: number,
    ariaColSpan: number,
    ariaControls: spaceSeparated,
    ariaCurrent: null,
    ariaDescribedBy: spaceSeparated,
    ariaDetails: null,
    ariaDisabled: booleanish,
    ariaDropEffect: spaceSeparated,
    ariaErrorMessage: null,
    ariaExpanded: booleanish,
    ariaFlowTo: spaceSeparated,
    ariaGrabbed: booleanish,
    ariaHasPopup: null,
    ariaHidden: booleanish,
    ariaInvalid: null,
    ariaKeyShortcuts: null,
    ariaLabel: null,
    ariaLabelledBy: spaceSeparated,
    ariaLevel: number,
    ariaLive: null,
    ariaModal: booleanish,
    ariaMultiLine: booleanish,
    ariaMultiSelectable: booleanish,
    ariaOrientation: null,
    ariaOwns: spaceSeparated,
    ariaPlaceholder: null,
    ariaPosInSet: number,
    ariaPressed: booleanish,
    ariaReadOnly: booleanish,
    ariaRelevant: null,
    ariaRequired: booleanish,
    ariaRoleDescription: spaceSeparated,
    ariaRowCount: number,
    ariaRowIndex: number,
    ariaRowSpan: number,
    ariaSelected: booleanish,
    ariaSetSize: number,
    ariaSort: null,
    ariaValueMax: number,
    ariaValueMin: number,
    ariaValueNow: number,
    ariaValueText: null,
    role: null
  }
});

const html$1 = create({
  space: 'html',
  attributes: {
    acceptcharset: 'accept-charset',
    classname: 'class',
    htmlfor: 'for',
    httpequiv: 'http-equiv'
  },
  transform: caseInsensitiveTransform,
  mustUseProperty: ['checked', 'multiple', 'muted', 'selected'],
  properties: {
    // Standard Properties.
    abbr: null,
    accept: commaSeparated,
    acceptCharset: spaceSeparated,
    accessKey: spaceSeparated,
    action: null,
    allow: null,
    allowFullScreen: boolean,
    allowPaymentRequest: boolean,
    allowUserMedia: boolean,
    alt: null,
    as: null,
    async: boolean,
    autoCapitalize: null,
    autoComplete: spaceSeparated,
    autoFocus: boolean,
    autoPlay: boolean,
    blocking: spaceSeparated,
    capture: null,
    charSet: null,
    checked: boolean,
    cite: null,
    className: spaceSeparated,
    cols: number,
    colSpan: null,
    content: null,
    contentEditable: booleanish,
    controls: boolean,
    controlsList: spaceSeparated,
    coords: number | commaSeparated,
    crossOrigin: null,
    data: null,
    dateTime: null,
    decoding: null,
    default: boolean,
    defer: boolean,
    dir: null,
    dirName: null,
    disabled: boolean,
    download: overloadedBoolean,
    draggable: booleanish,
    encType: null,
    enterKeyHint: null,
    fetchPriority: null,
    form: null,
    formAction: null,
    formEncType: null,
    formMethod: null,
    formNoValidate: boolean,
    formTarget: null,
    headers: spaceSeparated,
    height: number,
    hidden: boolean,
    high: number,
    href: null,
    hrefLang: null,
    htmlFor: spaceSeparated,
    httpEquiv: spaceSeparated,
    id: null,
    imageSizes: null,
    imageSrcSet: null,
    inert: boolean,
    inputMode: null,
    integrity: null,
    is: null,
    isMap: boolean,
    itemId: null,
    itemProp: spaceSeparated,
    itemRef: spaceSeparated,
    itemScope: boolean,
    itemType: spaceSeparated,
    kind: null,
    label: null,
    lang: null,
    language: null,
    list: null,
    loading: null,
    loop: boolean,
    low: number,
    manifest: null,
    max: null,
    maxLength: number,
    media: null,
    method: null,
    min: null,
    minLength: number,
    multiple: boolean,
    muted: boolean,
    name: null,
    nonce: null,
    noModule: boolean,
    noValidate: boolean,
    onAbort: null,
    onAfterPrint: null,
    onAuxClick: null,
    onBeforeMatch: null,
    onBeforePrint: null,
    onBeforeToggle: null,
    onBeforeUnload: null,
    onBlur: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onContextLost: null,
    onContextMenu: null,
    onContextRestored: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFormData: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLanguageChange: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadEnd: null,
    onLoadStart: null,
    onMessage: null,
    onMessageError: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRejectionHandled: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onScrollEnd: null,
    onSecurityPolicyViolation: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onSlotChange: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnhandledRejection: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onWheel: null,
    open: boolean,
    optimum: number,
    pattern: null,
    ping: spaceSeparated,
    placeholder: null,
    playsInline: boolean,
    popover: null,
    popoverTarget: null,
    popoverTargetAction: null,
    poster: null,
    preload: null,
    readOnly: boolean,
    referrerPolicy: null,
    rel: spaceSeparated,
    required: boolean,
    reversed: boolean,
    rows: number,
    rowSpan: number,
    sandbox: spaceSeparated,
    scope: null,
    scoped: boolean,
    seamless: boolean,
    selected: boolean,
    shadowRootClonable: boolean,
    shadowRootDelegatesFocus: boolean,
    shadowRootMode: null,
    shape: null,
    size: number,
    sizes: null,
    slot: null,
    span: number,
    spellCheck: booleanish,
    src: null,
    srcDoc: null,
    srcLang: null,
    srcSet: null,
    start: number,
    step: null,
    style: null,
    tabIndex: number,
    target: null,
    title: null,
    translate: null,
    type: null,
    typeMustMatch: boolean,
    useMap: null,
    value: booleanish,
    width: number,
    wrap: null,
    writingSuggestions: null,

    // Legacy.
    // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis
    align: null, // Several. Use CSS `text-align` instead,
    aLink: null, // `<body>`. Use CSS `a:active {color}` instead
    archive: spaceSeparated, // `<object>`. List of URIs to archives
    axis: null, // `<td>` and `<th>`. Use `scope` on `<th>`
    background: null, // `<body>`. Use CSS `background-image` instead
    bgColor: null, // `<body>` and table elements. Use CSS `background-color` instead
    border: number, // `<table>`. Use CSS `border-width` instead,
    borderColor: null, // `<table>`. Use CSS `border-color` instead,
    bottomMargin: number, // `<body>`
    cellPadding: null, // `<table>`
    cellSpacing: null, // `<table>`
    char: null, // Several table elements. When `align=char`, sets the character to align on
    charOff: null, // Several table elements. When `char`, offsets the alignment
    classId: null, // `<object>`
    clear: null, // `<br>`. Use CSS `clear` instead
    code: null, // `<object>`
    codeBase: null, // `<object>`
    codeType: null, // `<object>`
    color: null, // `<font>` and `<hr>`. Use CSS instead
    compact: boolean, // Lists. Use CSS to reduce space between items instead
    declare: boolean, // `<object>`
    event: null, // `<script>`
    face: null, // `<font>`. Use CSS instead
    frame: null, // `<table>`
    frameBorder: null, // `<iframe>`. Use CSS `border` instead
    hSpace: number, // `<img>` and `<object>`
    leftMargin: number, // `<body>`
    link: null, // `<body>`. Use CSS `a:link {color: *}` instead
    longDesc: null, // `<frame>`, `<iframe>`, and `<img>`. Use an `<a>`
    lowSrc: null, // `<img>`. Use a `<picture>`
    marginHeight: number, // `<body>`
    marginWidth: number, // `<body>`
    noResize: boolean, // `<frame>`
    noHref: boolean, // `<area>`. Use no href instead of an explicit `nohref`
    noShade: boolean, // `<hr>`. Use background-color and height instead of borders
    noWrap: boolean, // `<td>` and `<th>`
    object: null, // `<applet>`
    profile: null, // `<head>`
    prompt: null, // `<isindex>`
    rev: null, // `<link>`
    rightMargin: number, // `<body>`
    rules: null, // `<table>`
    scheme: null, // `<meta>`
    scrolling: booleanish, // `<frame>`. Use overflow in the child context
    standby: null, // `<object>`
    summary: null, // `<table>`
    text: null, // `<body>`. Use CSS `color` instead
    topMargin: number, // `<body>`
    valueType: null, // `<param>`
    version: null, // `<html>`. Use a doctype.
    vAlign: null, // Several. Use CSS `vertical-align` instead
    vLink: null, // `<body>`. Use CSS `a:visited {color}` instead
    vSpace: number, // `<img>` and `<object>`

    // Non-standard Properties.
    allowTransparency: null,
    autoCorrect: null,
    autoSave: null,
    disablePictureInPicture: boolean,
    disableRemotePlayback: boolean,
    prefix: null,
    property: null,
    results: number,
    security: null,
    unselectable: null
  }
});

const svg$1 = create({
  space: 'svg',
  attributes: {
    accentHeight: 'accent-height',
    alignmentBaseline: 'alignment-baseline',
    arabicForm: 'arabic-form',
    baselineShift: 'baseline-shift',
    capHeight: 'cap-height',
    className: 'class',
    clipPath: 'clip-path',
    clipRule: 'clip-rule',
    colorInterpolation: 'color-interpolation',
    colorInterpolationFilters: 'color-interpolation-filters',
    colorProfile: 'color-profile',
    colorRendering: 'color-rendering',
    crossOrigin: 'crossorigin',
    dataType: 'datatype',
    dominantBaseline: 'dominant-baseline',
    enableBackground: 'enable-background',
    fillOpacity: 'fill-opacity',
    fillRule: 'fill-rule',
    floodColor: 'flood-color',
    floodOpacity: 'flood-opacity',
    fontFamily: 'font-family',
    fontSize: 'font-size',
    fontSizeAdjust: 'font-size-adjust',
    fontStretch: 'font-stretch',
    fontStyle: 'font-style',
    fontVariant: 'font-variant',
    fontWeight: 'font-weight',
    glyphName: 'glyph-name',
    glyphOrientationHorizontal: 'glyph-orientation-horizontal',
    glyphOrientationVertical: 'glyph-orientation-vertical',
    hrefLang: 'hreflang',
    horizAdvX: 'horiz-adv-x',
    horizOriginX: 'horiz-origin-x',
    horizOriginY: 'horiz-origin-y',
    imageRendering: 'image-rendering',
    letterSpacing: 'letter-spacing',
    lightingColor: 'lighting-color',
    markerEnd: 'marker-end',
    markerMid: 'marker-mid',
    markerStart: 'marker-start',
    navDown: 'nav-down',
    navDownLeft: 'nav-down-left',
    navDownRight: 'nav-down-right',
    navLeft: 'nav-left',
    navNext: 'nav-next',
    navPrev: 'nav-prev',
    navRight: 'nav-right',
    navUp: 'nav-up',
    navUpLeft: 'nav-up-left',
    navUpRight: 'nav-up-right',
    onAbort: 'onabort',
    onActivate: 'onactivate',
    onAfterPrint: 'onafterprint',
    onBeforePrint: 'onbeforeprint',
    onBegin: 'onbegin',
    onCancel: 'oncancel',
    onCanPlay: 'oncanplay',
    onCanPlayThrough: 'oncanplaythrough',
    onChange: 'onchange',
    onClick: 'onclick',
    onClose: 'onclose',
    onCopy: 'oncopy',
    onCueChange: 'oncuechange',
    onCut: 'oncut',
    onDblClick: 'ondblclick',
    onDrag: 'ondrag',
    onDragEnd: 'ondragend',
    onDragEnter: 'ondragenter',
    onDragExit: 'ondragexit',
    onDragLeave: 'ondragleave',
    onDragOver: 'ondragover',
    onDragStart: 'ondragstart',
    onDrop: 'ondrop',
    onDurationChange: 'ondurationchange',
    onEmptied: 'onemptied',
    onEnd: 'onend',
    onEnded: 'onended',
    onError: 'onerror',
    onFocus: 'onfocus',
    onFocusIn: 'onfocusin',
    onFocusOut: 'onfocusout',
    onHashChange: 'onhashchange',
    onInput: 'oninput',
    onInvalid: 'oninvalid',
    onKeyDown: 'onkeydown',
    onKeyPress: 'onkeypress',
    onKeyUp: 'onkeyup',
    onLoad: 'onload',
    onLoadedData: 'onloadeddata',
    onLoadedMetadata: 'onloadedmetadata',
    onLoadStart: 'onloadstart',
    onMessage: 'onmessage',
    onMouseDown: 'onmousedown',
    onMouseEnter: 'onmouseenter',
    onMouseLeave: 'onmouseleave',
    onMouseMove: 'onmousemove',
    onMouseOut: 'onmouseout',
    onMouseOver: 'onmouseover',
    onMouseUp: 'onmouseup',
    onMouseWheel: 'onmousewheel',
    onOffline: 'onoffline',
    onOnline: 'ononline',
    onPageHide: 'onpagehide',
    onPageShow: 'onpageshow',
    onPaste: 'onpaste',
    onPause: 'onpause',
    onPlay: 'onplay',
    onPlaying: 'onplaying',
    onPopState: 'onpopstate',
    onProgress: 'onprogress',
    onRateChange: 'onratechange',
    onRepeat: 'onrepeat',
    onReset: 'onreset',
    onResize: 'onresize',
    onScroll: 'onscroll',
    onSeeked: 'onseeked',
    onSeeking: 'onseeking',
    onSelect: 'onselect',
    onShow: 'onshow',
    onStalled: 'onstalled',
    onStorage: 'onstorage',
    onSubmit: 'onsubmit',
    onSuspend: 'onsuspend',
    onTimeUpdate: 'ontimeupdate',
    onToggle: 'ontoggle',
    onUnload: 'onunload',
    onVolumeChange: 'onvolumechange',
    onWaiting: 'onwaiting',
    onZoom: 'onzoom',
    overlinePosition: 'overline-position',
    overlineThickness: 'overline-thickness',
    paintOrder: 'paint-order',
    panose1: 'panose-1',
    pointerEvents: 'pointer-events',
    referrerPolicy: 'referrerpolicy',
    renderingIntent: 'rendering-intent',
    shapeRendering: 'shape-rendering',
    stopColor: 'stop-color',
    stopOpacity: 'stop-opacity',
    strikethroughPosition: 'strikethrough-position',
    strikethroughThickness: 'strikethrough-thickness',
    strokeDashArray: 'stroke-dasharray',
    strokeDashOffset: 'stroke-dashoffset',
    strokeLineCap: 'stroke-linecap',
    strokeLineJoin: 'stroke-linejoin',
    strokeMiterLimit: 'stroke-miterlimit',
    strokeOpacity: 'stroke-opacity',
    strokeWidth: 'stroke-width',
    tabIndex: 'tabindex',
    textAnchor: 'text-anchor',
    textDecoration: 'text-decoration',
    textRendering: 'text-rendering',
    transformOrigin: 'transform-origin',
    typeOf: 'typeof',
    underlinePosition: 'underline-position',
    underlineThickness: 'underline-thickness',
    unicodeBidi: 'unicode-bidi',
    unicodeRange: 'unicode-range',
    unitsPerEm: 'units-per-em',
    vAlphabetic: 'v-alphabetic',
    vHanging: 'v-hanging',
    vIdeographic: 'v-ideographic',
    vMathematical: 'v-mathematical',
    vectorEffect: 'vector-effect',
    vertAdvY: 'vert-adv-y',
    vertOriginX: 'vert-origin-x',
    vertOriginY: 'vert-origin-y',
    wordSpacing: 'word-spacing',
    writingMode: 'writing-mode',
    xHeight: 'x-height',
    // These were camelcased in Tiny. Now lowercased in SVG 2
    playbackOrder: 'playbackorder',
    timelineBegin: 'timelinebegin'
  },
  transform: caseSensitiveTransform,
  properties: {
    about: commaOrSpaceSeparated,
    accentHeight: number,
    accumulate: null,
    additive: null,
    alignmentBaseline: null,
    alphabetic: number,
    amplitude: number,
    arabicForm: null,
    ascent: number,
    attributeName: null,
    attributeType: null,
    azimuth: number,
    bandwidth: null,
    baselineShift: null,
    baseFrequency: null,
    baseProfile: null,
    bbox: null,
    begin: null,
    bias: number,
    by: null,
    calcMode: null,
    capHeight: number,
    className: spaceSeparated,
    clip: null,
    clipPath: null,
    clipPathUnits: null,
    clipRule: null,
    color: null,
    colorInterpolation: null,
    colorInterpolationFilters: null,
    colorProfile: null,
    colorRendering: null,
    content: null,
    contentScriptType: null,
    contentStyleType: null,
    crossOrigin: null,
    cursor: null,
    cx: null,
    cy: null,
    d: null,
    dataType: null,
    defaultAction: null,
    descent: number,
    diffuseConstant: number,
    direction: null,
    display: null,
    dur: null,
    divisor: number,
    dominantBaseline: null,
    download: boolean,
    dx: null,
    dy: null,
    edgeMode: null,
    editable: null,
    elevation: number,
    enableBackground: null,
    end: null,
    event: null,
    exponent: number,
    externalResourcesRequired: null,
    fill: null,
    fillOpacity: number,
    fillRule: null,
    filter: null,
    filterRes: null,
    filterUnits: null,
    floodColor: null,
    floodOpacity: null,
    focusable: null,
    focusHighlight: null,
    fontFamily: null,
    fontSize: null,
    fontSizeAdjust: null,
    fontStretch: null,
    fontStyle: null,
    fontVariant: null,
    fontWeight: null,
    format: null,
    fr: null,
    from: null,
    fx: null,
    fy: null,
    g1: commaSeparated,
    g2: commaSeparated,
    glyphName: commaSeparated,
    glyphOrientationHorizontal: null,
    glyphOrientationVertical: null,
    glyphRef: null,
    gradientTransform: null,
    gradientUnits: null,
    handler: null,
    hanging: number,
    hatchContentUnits: null,
    hatchUnits: null,
    height: null,
    href: null,
    hrefLang: null,
    horizAdvX: number,
    horizOriginX: number,
    horizOriginY: number,
    id: null,
    ideographic: number,
    imageRendering: null,
    initialVisibility: null,
    in: null,
    in2: null,
    intercept: number,
    k: number,
    k1: number,
    k2: number,
    k3: number,
    k4: number,
    kernelMatrix: commaOrSpaceSeparated,
    kernelUnitLength: null,
    keyPoints: null, // SEMI_COLON_SEPARATED
    keySplines: null, // SEMI_COLON_SEPARATED
    keyTimes: null, // SEMI_COLON_SEPARATED
    kerning: null,
    lang: null,
    lengthAdjust: null,
    letterSpacing: null,
    lightingColor: null,
    limitingConeAngle: number,
    local: null,
    markerEnd: null,
    markerMid: null,
    markerStart: null,
    markerHeight: null,
    markerUnits: null,
    markerWidth: null,
    mask: null,
    maskContentUnits: null,
    maskUnits: null,
    mathematical: null,
    max: null,
    media: null,
    mediaCharacterEncoding: null,
    mediaContentEncodings: null,
    mediaSize: number,
    mediaTime: null,
    method: null,
    min: null,
    mode: null,
    name: null,
    navDown: null,
    navDownLeft: null,
    navDownRight: null,
    navLeft: null,
    navNext: null,
    navPrev: null,
    navRight: null,
    navUp: null,
    navUpLeft: null,
    navUpRight: null,
    numOctaves: null,
    observer: null,
    offset: null,
    onAbort: null,
    onActivate: null,
    onAfterPrint: null,
    onBeforePrint: null,
    onBegin: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnd: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFocusIn: null,
    onFocusOut: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadStart: null,
    onMessage: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onMouseWheel: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRepeat: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onShow: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onZoom: null,
    opacity: null,
    operator: null,
    order: null,
    orient: null,
    orientation: null,
    origin: null,
    overflow: null,
    overlay: null,
    overlinePosition: number,
    overlineThickness: number,
    paintOrder: null,
    panose1: null,
    path: null,
    pathLength: number,
    patternContentUnits: null,
    patternTransform: null,
    patternUnits: null,
    phase: null,
    ping: spaceSeparated,
    pitch: null,
    playbackOrder: null,
    pointerEvents: null,
    points: null,
    pointsAtX: number,
    pointsAtY: number,
    pointsAtZ: number,
    preserveAlpha: null,
    preserveAspectRatio: null,
    primitiveUnits: null,
    propagate: null,
    property: commaOrSpaceSeparated,
    r: null,
    radius: null,
    referrerPolicy: null,
    refX: null,
    refY: null,
    rel: commaOrSpaceSeparated,
    rev: commaOrSpaceSeparated,
    renderingIntent: null,
    repeatCount: null,
    repeatDur: null,
    requiredExtensions: commaOrSpaceSeparated,
    requiredFeatures: commaOrSpaceSeparated,
    requiredFonts: commaOrSpaceSeparated,
    requiredFormats: commaOrSpaceSeparated,
    resource: null,
    restart: null,
    result: null,
    rotate: null,
    rx: null,
    ry: null,
    scale: null,
    seed: null,
    shapeRendering: null,
    side: null,
    slope: null,
    snapshotTime: null,
    specularConstant: number,
    specularExponent: number,
    spreadMethod: null,
    spacing: null,
    startOffset: null,
    stdDeviation: null,
    stemh: null,
    stemv: null,
    stitchTiles: null,
    stopColor: null,
    stopOpacity: null,
    strikethroughPosition: number,
    strikethroughThickness: number,
    string: null,
    stroke: null,
    strokeDashArray: commaOrSpaceSeparated,
    strokeDashOffset: null,
    strokeLineCap: null,
    strokeLineJoin: null,
    strokeMiterLimit: number,
    strokeOpacity: number,
    strokeWidth: null,
    style: null,
    surfaceScale: number,
    syncBehavior: null,
    syncBehaviorDefault: null,
    syncMaster: null,
    syncTolerance: null,
    syncToleranceDefault: null,
    systemLanguage: commaOrSpaceSeparated,
    tabIndex: number,
    tableValues: null,
    target: null,
    targetX: number,
    targetY: number,
    textAnchor: null,
    textDecoration: null,
    textRendering: null,
    textLength: null,
    timelineBegin: null,
    title: null,
    transformBehavior: null,
    type: null,
    typeOf: commaOrSpaceSeparated,
    to: null,
    transform: null,
    transformOrigin: null,
    u1: null,
    u2: null,
    underlinePosition: number,
    underlineThickness: number,
    unicode: null,
    unicodeBidi: null,
    unicodeRange: null,
    unitsPerEm: number,
    values: null,
    vAlphabetic: number,
    vMathematical: number,
    vectorEffect: null,
    vHanging: number,
    vIdeographic: number,
    version: null,
    vertAdvY: number,
    vertOriginX: number,
    vertOriginY: number,
    viewBox: null,
    viewTarget: null,
    visibility: null,
    width: null,
    widths: null,
    wordSpacing: null,
    writingMode: null,
    x: null,
    x1: null,
    x2: null,
    xChannelSelector: null,
    xHeight: number,
    y: null,
    y1: null,
    y2: null,
    yChannelSelector: null,
    z: null,
    zoomAndPan: null
  }
});

/**
 * @typedef {import('./util/schema.js').Schema} Schema
 */


const valid = /^data[-\w.:]+$/i;
const dash = /-[a-z]/g;
const cap = /[A-Z]/g;

/**
 * @param {Schema} schema
 * @param {string} value
 * @returns {Info}
 */
function find(schema, value) {
  const normal = normalize(value);
  let prop = value;
  let Type = Info;

  if (normal in schema.normal) {
    return schema.property[schema.normal[normal]]
  }

  if (normal.length > 4 && normal.slice(0, 4) === 'data' && valid.test(value)) {
    // Attribute or property.
    if (value.charAt(4) === '-') {
      // Turn it into a property.
      const rest = value.slice(5).replace(dash, camelcase);
      prop = 'data' + rest.charAt(0).toUpperCase() + rest.slice(1);
    } else {
      // Turn it into an attribute.
      const rest = value.slice(4);

      if (!dash.test(rest)) {
        let dashes = rest.replace(cap, kebab);

        if (dashes.charAt(0) !== '-') {
          dashes = '-' + dashes;
        }

        value = 'data' + dashes;
      }
    }

    Type = DefinedInfo;
  }

  return new Type(prop, value)
}

/**
 * @param {string} $0
 * @returns {string}
 */
function kebab($0) {
  return '-' + $0.toLowerCase()
}

/**
 * @param {string} $0
 * @returns {string}
 */
function camelcase($0) {
  return $0.charAt(1).toUpperCase()
}

/**
 * `hast` is close to `React`, but differs in a couple of cases.
 *
 * To get a React property from a hast property, check if it is in
 * `hastToReact`, if it is, then use the corresponding value,
 * otherwise, use the hast property.
 *
 * @type {Record<string, string>}
 */
const hastToReact = {
  classId: 'classID',
  dataType: 'datatype',
  itemId: 'itemID',
  strokeDashArray: 'strokeDasharray',
  strokeDashOffset: 'strokeDashoffset',
  strokeLineCap: 'strokeLinecap',
  strokeLineJoin: 'strokeLinejoin',
  strokeMiterLimit: 'strokeMiterlimit',
  typeOf: 'typeof',
  xLinkActuate: 'xlinkActuate',
  xLinkArcRole: 'xlinkArcrole',
  xLinkHref: 'xlinkHref',
  xLinkRole: 'xlinkRole',
  xLinkShow: 'xlinkShow',
  xLinkTitle: 'xlinkTitle',
  xLinkType: 'xlinkType',
  xmlnsXLink: 'xmlnsXlink'
};

/**
 * @typedef {import('./lib/util/info.js').Info} Info
 * @typedef {import('./lib/util/schema.js').Schema} Schema
 */

const html = merge([xml, xlink, xmlns, aria, html$1], 'html');
const svg = merge([xml, xlink, xmlns, aria, svg$1], 'svg');

/**
 * @typedef {import('unist').Node} Node
 * @typedef {import('hast').Root} Root
 * @typedef {import('hast').Element} Element
 *
 * @callback AllowElement
 * @param {Element} element
 * @param {number} index
 * @param {Element|Root} parent
 * @returns {boolean|undefined}
 *
 * @typedef Options
 * @property {Array<string>} [allowedElements]
 * @property {Array<string>} [disallowedElements=[]]
 * @property {AllowElement} [allowElement]
 * @property {boolean} [unwrapDisallowed=false]
 */

/**
 * @type {import('unified').Plugin<[Options], Root>}
 */
function rehypeFilter(options) {
  if (options.allowedElements && options.disallowedElements) {
    throw new TypeError(
      'Only one of `allowedElements` and `disallowedElements` should be defined'
    )
  }

  if (
    options.allowedElements ||
    options.disallowedElements ||
    options.allowElement
  ) {
    return (tree) => {
      visit(tree, 'element', (node, index, parent_) => {
        const parent = /** @type {Element|Root} */ (parent_);
        /** @type {boolean|undefined} */
        let remove;

        if (options.allowedElements) {
          remove = !options.allowedElements.includes(node.tagName);
        } else if (options.disallowedElements) {
          remove = options.disallowedElements.includes(node.tagName);
        }

        if (!remove && options.allowElement && typeof index === 'number') {
          remove = !options.allowElement(node, index, parent);
        }

        if (remove && typeof index === 'number') {
          if (options.unwrapDisallowed && node.children) {
            parent.children.splice(index, 1, ...node.children);
          } else {
            parent.children.splice(index, 1);
          }

          return index
        }

        return undefined
      });
    }
  }
}

var reactIs = {exports: {}};

var reactIs_production_min = {};

/**
 * @license React
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var hasRequiredReactIs_production_min;

function requireReactIs_production_min () {
	if (hasRequiredReactIs_production_min) return reactIs_production_min;
	hasRequiredReactIs_production_min = 1;
var b=Symbol.for("react.element"),c=Symbol.for("react.portal"),d=Symbol.for("react.fragment"),e=Symbol.for("react.strict_mode"),f=Symbol.for("react.profiler"),g=Symbol.for("react.provider"),h=Symbol.for("react.context"),k=Symbol.for("react.server_context"),l=Symbol.for("react.forward_ref"),m=Symbol.for("react.suspense"),n=Symbol.for("react.suspense_list"),p=Symbol.for("react.memo"),q=Symbol.for("react.lazy"),t=Symbol.for("react.offscreen"),u;u=Symbol.for("react.module.reference");
	function v(a){if("object"===typeof a&&null!==a){var r=a.$$typeof;switch(r){case b:switch(a=a.type,a){case d:case f:case e:case m:case n:return a;default:switch(a=a&&a.$$typeof,a){case k:case h:case l:case q:case p:case g:return a;default:return r}}case c:return r}}}reactIs_production_min.ContextConsumer=h;reactIs_production_min.ContextProvider=g;reactIs_production_min.Element=b;reactIs_production_min.ForwardRef=l;reactIs_production_min.Fragment=d;reactIs_production_min.Lazy=q;reactIs_production_min.Memo=p;reactIs_production_min.Portal=c;reactIs_production_min.Profiler=f;reactIs_production_min.StrictMode=e;reactIs_production_min.Suspense=m;
	reactIs_production_min.SuspenseList=n;reactIs_production_min.isAsyncMode=function(){return !1};reactIs_production_min.isConcurrentMode=function(){return !1};reactIs_production_min.isContextConsumer=function(a){return v(a)===h};reactIs_production_min.isContextProvider=function(a){return v(a)===g};reactIs_production_min.isElement=function(a){return "object"===typeof a&&null!==a&&a.$$typeof===b};reactIs_production_min.isForwardRef=function(a){return v(a)===l};reactIs_production_min.isFragment=function(a){return v(a)===d};reactIs_production_min.isLazy=function(a){return v(a)===q};reactIs_production_min.isMemo=function(a){return v(a)===p};
	reactIs_production_min.isPortal=function(a){return v(a)===c};reactIs_production_min.isProfiler=function(a){return v(a)===f};reactIs_production_min.isStrictMode=function(a){return v(a)===e};reactIs_production_min.isSuspense=function(a){return v(a)===m};reactIs_production_min.isSuspenseList=function(a){return v(a)===n};
	reactIs_production_min.isValidElementType=function(a){return "string"===typeof a||"function"===typeof a||a===d||a===f||a===e||a===m||a===n||a===t||"object"===typeof a&&null!==a&&(a.$$typeof===q||a.$$typeof===p||a.$$typeof===g||a.$$typeof===h||a.$$typeof===l||a.$$typeof===u||void 0!==a.getModuleId)?!0:!1};reactIs_production_min.typeOf=v;
	return reactIs_production_min;
}

{
  reactIs.exports = requireReactIs_production_min();
}

var reactIsExports = reactIs.exports;
var ReactIs = /*@__PURE__*/getDefaultExportFromCjs(reactIsExports);

/**
 * Check if the given value is *inter-element whitespace*.
 *
 * @param {unknown} thing
 *   Thing to check (typically `Node` or `string`).
 * @returns {boolean}
 *   Whether the `value` is inter-element whitespace (`boolean`): consisting of
 *   zero or more of space, tab (`\t`), line feed (`\n`), carriage return
 *   (`\r`), or form feed (`\f`).
 *   If a node is passed it must be a `Text` node, whose `value` field is
 *   checked.
 */
function whitespace(thing) {
  /** @type {string} */
  const value =
    // @ts-expect-error looks like a node.
    thing && typeof thing === 'object' && thing.type === 'text'
      ? // @ts-expect-error looks like a text.
        thing.value || ''
      : thing;

  // HTML whitespace expression.
  // See <https://infra.spec.whatwg.org/#ascii-whitespace>.
  return typeof value === 'string' && value.replace(/[ \t\n\f\r]/g, '') === ''
}

/**
 * Parse space-separated tokens to an array of strings.
 *
 * @param {string} value
 *   Space-separated tokens.
 * @returns {Array<string>}
 *   List of tokens.
 */

/**
 * Serialize an array of strings as space separated-tokens.
 *
 * @param {Array<string|number>} values
 *   List of tokens.
 * @returns {string}
 *   Space-separated tokens.
 */
function stringify$1(values) {
  return values.join(' ').trim()
}

/**
 * @typedef Options
 *   Configuration for `stringify`.
 * @property {boolean} [padLeft=true]
 *   Whether to pad a space before a token.
 * @property {boolean} [padRight=false]
 *   Whether to pad a space after a token.
 */


/**
 * Serialize an array of strings or numbers to comma-separated tokens.
 *
 * @param {Array<string|number>} values
 *   List of tokens.
 * @param {Options} [options]
 *   Configuration for `stringify` (optional).
 * @returns {string}
 *   Comma-separated tokens.
 */
function stringify(values, options) {
  const settings = {};

  // Ensure the last empty entry is seen.
  const input = values[values.length - 1] === '' ? [...values, ''] : values;

  return input
    .join(
      (settings.padRight ? ' ' : '') +
        ',' +
        (settings.padLeft === false ? '' : ' ')
    )
    .trim()
}

var styleToObject = {exports: {}};

// http://www.w3.org/TR/CSS21/grammar.html
// https://github.com/visionmedia/css-parse/pull/49#issuecomment-30088027
var COMMENT_REGEX = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g;

var NEWLINE_REGEX = /\n/g;
var WHITESPACE_REGEX = /^\s*/;

// declaration
var PROPERTY_REGEX = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/;
var COLON_REGEX = /^:\s*/;
var VALUE_REGEX = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/;
var SEMICOLON_REGEX = /^[;\s]*/;

// https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/String/Trim#Polyfill
var TRIM_REGEX = /^\s+|\s+$/g;

// strings
var NEWLINE = '\n';
var FORWARD_SLASH = '/';
var ASTERISK = '*';
var EMPTY_STRING = '';

// types
var TYPE_COMMENT = 'comment';
var TYPE_DECLARATION = 'declaration';

/**
 * @param {String} style
 * @param {Object} [options]
 * @return {Object[]}
 * @throws {TypeError}
 * @throws {Error}
 */
var inlineStyleParser = function(style, options) {
  if (typeof style !== 'string') {
    throw new TypeError('First argument must be a string');
  }

  if (!style) return [];

  options = options || {};

  /**
   * Positional.
   */
  var lineno = 1;
  var column = 1;

  /**
   * Update lineno and column based on `str`.
   *
   * @param {String} str
   */
  function updatePosition(str) {
    var lines = str.match(NEWLINE_REGEX);
    if (lines) lineno += lines.length;
    var i = str.lastIndexOf(NEWLINE);
    column = ~i ? str.length - i : column + str.length;
  }

  /**
   * Mark position and patch `node.position`.
   *
   * @return {Function}
   */
  function position() {
    var start = { line: lineno, column: column };
    return function(node) {
      node.position = new Position(start);
      whitespace();
      return node;
    };
  }

  /**
   * Store position information for a node.
   *
   * @constructor
   * @property {Object} start
   * @property {Object} end
   * @property {undefined|String} source
   */
  function Position(start) {
    this.start = start;
    this.end = { line: lineno, column: column };
    this.source = options.source;
  }

  /**
   * Non-enumerable source string.
   */
  Position.prototype.content = style;

  /**
   * Error `msg`.
   *
   * @param {String} msg
   * @throws {Error}
   */
  function error(msg) {
    var err = new Error(
      options.source + ':' + lineno + ':' + column + ': ' + msg
    );
    err.reason = msg;
    err.filename = options.source;
    err.line = lineno;
    err.column = column;
    err.source = style;

    if (options.silent) ; else {
      throw err;
    }
  }

  /**
   * Match `re` and return captures.
   *
   * @param {RegExp} re
   * @return {undefined|Array}
   */
  function match(re) {
    var m = re.exec(style);
    if (!m) return;
    var str = m[0];
    updatePosition(str);
    style = style.slice(str.length);
    return m;
  }

  /**
   * Parse whitespace.
   */
  function whitespace() {
    match(WHITESPACE_REGEX);
  }

  /**
   * Parse comments.
   *
   * @param {Object[]} [rules]
   * @return {Object[]}
   */
  function comments(rules) {
    var c;
    rules = rules || [];
    while ((c = comment())) {
      if (c !== false) {
        rules.push(c);
      }
    }
    return rules;
  }

  /**
   * Parse comment.
   *
   * @return {Object}
   * @throws {Error}
   */
  function comment() {
    var pos = position();
    if (FORWARD_SLASH != style.charAt(0) || ASTERISK != style.charAt(1)) return;

    var i = 2;
    while (
      EMPTY_STRING != style.charAt(i) &&
      (ASTERISK != style.charAt(i) || FORWARD_SLASH != style.charAt(i + 1))
    ) {
      ++i;
    }
    i += 2;

    if (EMPTY_STRING === style.charAt(i - 1)) {
      return error('End of comment missing');
    }

    var str = style.slice(2, i - 2);
    column += 2;
    updatePosition(str);
    style = style.slice(i);
    column += 2;

    return pos({
      type: TYPE_COMMENT,
      comment: str
    });
  }

  /**
   * Parse declaration.
   *
   * @return {Object}
   * @throws {Error}
   */
  function declaration() {
    var pos = position();

    // prop
    var prop = match(PROPERTY_REGEX);
    if (!prop) return;
    comment();

    // :
    if (!match(COLON_REGEX)) return error("property missing ':'");

    // val
    var val = match(VALUE_REGEX);

    var ret = pos({
      type: TYPE_DECLARATION,
      property: trim(prop[0].replace(COMMENT_REGEX, EMPTY_STRING)),
      value: val
        ? trim(val[0].replace(COMMENT_REGEX, EMPTY_STRING))
        : EMPTY_STRING
    });

    // ;
    match(SEMICOLON_REGEX);

    return ret;
  }

  /**
   * Parse declarations.
   *
   * @return {Object[]}
   */
  function declarations() {
    var decls = [];

    comments(decls);

    // declarations
    var decl;
    while ((decl = declaration())) {
      if (decl !== false) {
        decls.push(decl);
        comments(decls);
      }
    }

    return decls;
  }

  whitespace();
  return declarations();
};

/**
 * Trim `str`.
 *
 * @param {String} str
 * @return {String}
 */
function trim(str) {
  return str ? str.replace(TRIM_REGEX, EMPTY_STRING) : EMPTY_STRING;
}

var parse = inlineStyleParser;

/**
 * Parses inline style to object.
 *
 * @example
 * // returns { 'line-height': '42' }
 * StyleToObject('line-height: 42;');
 *
 * @param  {String}      style      - The inline style.
 * @param  {Function}    [iterator] - The iterator function.
 * @return {null|Object}
 */
function StyleToObject(style, iterator) {
  var output = null;
  if (!style || typeof style !== 'string') {
    return output;
  }

  var declaration;
  var declarations = parse(style);
  var hasIterator = typeof iterator === 'function';
  var property;
  var value;

  for (var i = 0, len = declarations.length; i < len; i++) {
    declaration = declarations[i];
    property = declaration.property;
    value = declaration.value;

    if (hasIterator) {
      iterator(property, value, declaration);
    } else if (value) {
      output || (output = {});
      output[property] = value;
    }
  }

  return output;
}

styleToObject.exports = StyleToObject;
styleToObject.exports.default = StyleToObject; // ESM support

var styleToObjectExports = styleToObject.exports;
var StyleToObject$1 = /*@__PURE__*/getDefaultExportFromCjs(styleToObjectExports);

/**
 * @template T
 * @typedef {import('react').ComponentType<T>} ComponentType<T>
 */


const own$2 = {}.hasOwnProperty;

// The table-related elements that must not contain whitespace text according
// to React.
const tableElements = new Set(['table', 'thead', 'tbody', 'tfoot', 'tr']);

/**
 * @param {Context} context
 * @param {Element|Root} node
 */
function childrenToReact(context, node) {
  /** @type {Array<ReactNode>} */
  const children = [];
  let childIndex = -1;
  /** @type {Comment|Doctype|Element|Raw|Text} */
  let child;

  while (++childIndex < node.children.length) {
    child = node.children[childIndex];

    if (child.type === 'element') {
      children.push(toReact(context, child, childIndex, node));
    } else if (child.type === 'text') {
      // Currently, a warning is triggered by react for *any* white space in
      // tables.
      // So we drop it.
      // See: <https://github.com/facebook/react/pull/7081>.
      // See: <https://github.com/facebook/react/pull/7515>.
      // See: <https://github.com/remarkjs/remark-react/issues/64>.
      // See: <https://github.com/remarkjs/react-markdown/issues/576>.
      if (
        node.type !== 'element' ||
        !tableElements.has(node.tagName) ||
        !whitespace(child)
      ) {
        children.push(child.value);
      }
    } else if (child.type === 'raw' && !context.options.skipHtml) {
      // Default behavior is to show (encoded) HTML.
      children.push(child.value);
    }
  }

  return children
}

/**
 * @param {Context} context
 * @param {Element} node
 * @param {number} index
 * @param {Element|Root} parent
 */
function toReact(context, node, index, parent) {
  const options = context.options;
  const transform =
    options.transformLinkUri === undefined
      ? uriTransformer
      : options.transformLinkUri;
  const parentSchema = context.schema;
  /** @type {ReactMarkdownNames} */
  // @ts-expect-error assume a known HTML/SVG element.
  const name = node.tagName;
  /** @type {Record<string, unknown>} */
  const properties = {};
  let schema = parentSchema;
  /** @type {string} */
  let property;

  if (parentSchema.space === 'html' && name === 'svg') {
    schema = svg;
    context.schema = schema;
  }

  if (node.properties) {
    for (property in node.properties) {
      if (own$2.call(node.properties, property)) {
        addProperty(properties, property, node.properties[property], context);
      }
    }
  }

  if (name === 'ol' || name === 'ul') {
    context.listDepth++;
  }

  const children = childrenToReact(context, node);

  if (name === 'ol' || name === 'ul') {
    context.listDepth--;
  }

  // Restore parent schema.
  context.schema = parentSchema;

  // Nodes created by plugins do not have positional info, in which case we use
  // an object that matches the position interface.
  const position = node.position || {
    start: {line: null, column: null, offset: null},
    end: {line: null, column: null, offset: null}
  };
  const component =
    options.components && own$2.call(options.components, name)
      ? options.components[name]
      : name;
  const basic = typeof component === 'string' || component === SP_REACT.Fragment;

  if (!ReactIs.isValidElementType(component)) {
    throw new TypeError(
      `Component for name \`${name}\` not defined or is not renderable`
    )
  }

  properties.key = index;

  if (name === 'a' && options.linkTarget) {
    properties.target =
      typeof options.linkTarget === 'function'
        ? options.linkTarget(
            String(properties.href || ''),
            node.children,
            typeof properties.title === 'string' ? properties.title : null
          )
        : options.linkTarget;
  }

  if (name === 'a' && transform) {
    properties.href = transform(
      String(properties.href || ''),
      node.children,
      typeof properties.title === 'string' ? properties.title : null
    );
  }

  if (
    !basic &&
    name === 'code' &&
    parent.type === 'element' &&
    parent.tagName !== 'pre'
  ) {
    properties.inline = true;
  }

  if (
    !basic &&
    (name === 'h1' ||
      name === 'h2' ||
      name === 'h3' ||
      name === 'h4' ||
      name === 'h5' ||
      name === 'h6')
  ) {
    properties.level = Number.parseInt(name.charAt(1), 10);
  }

  if (name === 'img' && options.transformImageUri) {
    properties.src = options.transformImageUri(
      String(properties.src || ''),
      String(properties.alt || ''),
      typeof properties.title === 'string' ? properties.title : null
    );
  }

  if (!basic && name === 'li' && parent.type === 'element') {
    const input = getInputElement(node);
    properties.checked =
      input && input.properties ? Boolean(input.properties.checked) : null;
    properties.index = getElementsBeforeCount(parent, node);
    properties.ordered = parent.tagName === 'ol';
  }

  if (!basic && (name === 'ol' || name === 'ul')) {
    properties.ordered = name === 'ol';
    properties.depth = context.listDepth;
  }

  if (name === 'td' || name === 'th') {
    if (properties.align) {
      if (!properties.style) properties.style = {};
      // @ts-expect-error assume `style` is an object
      properties.style.textAlign = properties.align;
      delete properties.align;
    }

    if (!basic) {
      properties.isHeader = name === 'th';
    }
  }

  if (!basic && name === 'tr' && parent.type === 'element') {
    properties.isHeader = Boolean(parent.tagName === 'thead');
  }

  // If `sourcePos` is given, pass source information (line/column info from markdown source).
  if (options.sourcePos) {
    properties['data-sourcepos'] = flattenPosition(position);
  }

  if (!basic && options.rawSourcePos) {
    properties.sourcePosition = node.position;
  }

  // If `includeElementIndex` is given, pass node index info to components.
  if (!basic && options.includeElementIndex) {
    properties.index = getElementsBeforeCount(parent, node);
    properties.siblingCount = getElementsBeforeCount(parent);
  }

  if (!basic) {
    properties.node = node;
  }

  // Ensure no React warnings are emitted for void elements w/ children.
  return children.length > 0
    ? SP_REACT.createElement(component, properties, children)
    : SP_REACT.createElement(component, properties)
}

/**
 * @param {Element|Root} node
 * @returns {Element?}
 */
function getInputElement(node) {
  let index = -1;

  while (++index < node.children.length) {
    const child = node.children[index];

    if (child.type === 'element' && child.tagName === 'input') {
      return child
    }
  }

  return null
}

/**
 * @param {Element|Root} parent
 * @param {Element} [node]
 * @returns {number}
 */
function getElementsBeforeCount(parent, node) {
  let index = -1;
  let count = 0;

  while (++index < parent.children.length) {
    if (parent.children[index] === node) break
    if (parent.children[index].type === 'element') count++;
  }

  return count
}

/**
 * @param {Record<string, unknown>} props
 * @param {string} prop
 * @param {unknown} value
 * @param {Context} ctx
 */
function addProperty(props, prop, value, ctx) {
  const info = find(ctx.schema, prop);
  let result = value;

  // Ignore nullish and `NaN` values.
  // eslint-disable-next-line no-self-compare
  if (result === null || result === undefined || result !== result) {
    return
  }

  // Accept `array`.
  // Most props are space-separated.
  if (Array.isArray(result)) {
    result = info.commaSeparated ? stringify(result) : stringify$1(result);
  }

  if (info.property === 'style' && typeof result === 'string') {
    result = parseStyle(result);
  }

  if (info.space && info.property) {
    props[
      own$2.call(hastToReact, info.property)
        ? hastToReact[info.property]
        : info.property
    ] = result;
  } else if (info.attribute) {
    props[info.attribute] = result;
  }
}

/**
 * @param {string} value
 * @returns {Record<string, string>}
 */
function parseStyle(value) {
  /** @type {Record<string, string>} */
  const result = {};

  try {
    StyleToObject$1(value, iterator);
  } catch {
    // Silent.
  }

  return result

  /**
   * @param {string} name
   * @param {string} v
   */
  function iterator(name, v) {
    const k = name.slice(0, 4) === '-ms-' ? `ms-${name.slice(4)}` : name;
    result[k.replace(/-([a-z])/g, styleReplacer)] = v;
  }
}

/**
 * @param {unknown} _
 * @param {string} $1
 */
function styleReplacer(_, $1) {
  return $1.toUpperCase()
}

/**
 * @param {Position|{start: {line: null, column: null, offset: null}, end: {line: null, column: null, offset: null}}} pos
 * @returns {string}
 */
function flattenPosition(pos) {
  return [
    pos.start.line,
    ':',
    pos.start.column,
    '-',
    pos.end.line,
    ':',
    pos.end.column
  ]
    .map(String)
    .join('')
}

/**
 * @typedef {import('react').ReactNode} ReactNode
 * @typedef {import('react').ReactElement<{}>} ReactElement
 * @typedef {import('unified').PluggableList} PluggableList
 * @typedef {import('hast').Root} Root
 * @typedef {import('./rehype-filter.js').Options} FilterOptions
 * @typedef {import('./ast-to-react.js').Options} TransformOptions
 *
 * @typedef CoreOptions
 * @property {string} children
 *
 * @typedef PluginOptions
 * @property {PluggableList} [remarkPlugins=[]]
 * @property {PluggableList} [rehypePlugins=[]]
 * @property {import('remark-rehype').Options | undefined} [remarkRehypeOptions={}]
 *
 * @typedef LayoutOptions
 * @property {string} [className]
 *
 * @typedef {CoreOptions & PluginOptions & LayoutOptions & FilterOptions & TransformOptions} ReactMarkdownOptions
 *
 * @typedef Deprecation
 * @property {string} id
 * @property {string} [to]
 */


const own$1 = {}.hasOwnProperty;
const changelog =
  'https://github.com/remarkjs/react-markdown/blob/main/changelog.md';

/** @type {Record<string, Deprecation>} */
const deprecated = {
  plugins: {to: 'remarkPlugins', id: 'change-plugins-to-remarkplugins'},
  renderers: {to: 'components', id: 'change-renderers-to-components'},
  astPlugins: {id: 'remove-buggy-html-in-markdown-parser'},
  allowDangerousHtml: {id: 'remove-buggy-html-in-markdown-parser'},
  escapeHtml: {id: 'remove-buggy-html-in-markdown-parser'},
  source: {to: 'children', id: 'change-source-to-children'},
  allowNode: {
    to: 'allowElement',
    id: 'replace-allownode-allowedtypes-and-disallowedtypes'
  },
  allowedTypes: {
    to: 'allowedElements',
    id: 'replace-allownode-allowedtypes-and-disallowedtypes'
  },
  disallowedTypes: {
    to: 'disallowedElements',
    id: 'replace-allownode-allowedtypes-and-disallowedtypes'
  },
  includeNodeIndex: {
    to: 'includeElementIndex',
    id: 'change-includenodeindex-to-includeelementindex'
  }
};

/**
 * React component to render markdown.
 *
 * @param {ReactMarkdownOptions} options
 * @returns {ReactElement}
 */
function ReactMarkdown(options) {
  for (const key in deprecated) {
    if (own$1.call(deprecated, key) && own$1.call(options, key)) {
      const deprecation = deprecated[key];
      console.warn(
        `[react-markdown] Warning: please ${
          deprecation.to ? `use \`${deprecation.to}\` instead of` : 'remove'
        } \`${key}\` (see <${changelog}#${deprecation.id}> for more info)`
      );
      delete deprecated[key];
    }
  }

  const processor = unified()
    .use(remarkParse)
    .use(options.remarkPlugins || [])
    .use(remarkRehype, {
      ...options.remarkRehypeOptions,
      allowDangerousHtml: true
    })
    .use(options.rehypePlugins || [])
    .use(rehypeFilter, options);

  const file = new VFile();

  if (typeof options.children === 'string') {
    file.value = options.children;
  } else if (options.children !== undefined && options.children !== null) {
    console.warn(
      `[react-markdown] Warning: please pass a string as \`children\` (not: \`${options.children}\`)`
    );
  }

  const hastNode = processor.runSync(processor.parse(file), file);

  if (hastNode.type !== 'root') {
    throw new TypeError('Expected a `root` node')
  }

  /** @type {ReactElement} */
  let result = SP_REACT.createElement(
    SP_REACT.Fragment,
    {},
    childrenToReact({options, schema: html, listDepth: 0}, hastNode)
  );

  if (options.className) {
    result = SP_REACT.createElement('div', {className: options.className}, result);
  }

  return result
}

ReactMarkdown.propTypes = {
  // Core options:
  children: PropTypes.string,
  // Layout options:
  className: PropTypes.string,
  // Filter options:
  allowElement: PropTypes.func,
  allowedElements: PropTypes.arrayOf(PropTypes.string),
  disallowedElements: PropTypes.arrayOf(PropTypes.string),
  unwrapDisallowed: PropTypes.bool,
  // Plugin options:
  remarkPlugins: PropTypes.arrayOf(
    PropTypes.oneOfType([
      PropTypes.object,
      PropTypes.func,
      PropTypes.arrayOf(
        PropTypes.oneOfType([
          PropTypes.bool,
          PropTypes.string,
          PropTypes.object,
          PropTypes.func,
          PropTypes.arrayOf(
            // prettier-ignore
            // type-coverage:ignore-next-line
            PropTypes.any
          )
        ])
      )
    ])
  ),
  rehypePlugins: PropTypes.arrayOf(
    PropTypes.oneOfType([
      PropTypes.object,
      PropTypes.func,
      PropTypes.arrayOf(
        PropTypes.oneOfType([
          PropTypes.bool,
          PropTypes.string,
          PropTypes.object,
          PropTypes.func,
          PropTypes.arrayOf(
            // prettier-ignore
            // type-coverage:ignore-next-line
            PropTypes.any
          )
        ])
      )
    ])
  ),
  // Transform options:
  sourcePos: PropTypes.bool,
  rawSourcePos: PropTypes.bool,
  skipHtml: PropTypes.bool,
  includeElementIndex: PropTypes.bool,
  transformLinkUri: PropTypes.oneOfType([PropTypes.func, PropTypes.bool]),
  linkTarget: PropTypes.oneOfType([PropTypes.func, PropTypes.string]),
  transformImageUri: PropTypes.func,
  components: PropTypes.object
};

/**
 * @typedef {import('micromark-util-types').Code} Code
 * @typedef {import('micromark-util-types').ConstructRecord} ConstructRecord
 * @typedef {import('micromark-util-types').Event} Event
 * @typedef {import('micromark-util-types').Extension} Extension
 * @typedef {import('micromark-util-types').Previous} Previous
 * @typedef {import('micromark-util-types').State} State
 * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext
 * @typedef {import('micromark-util-types').Tokenizer} Tokenizer
 */

const wwwPrefix = {
  tokenize: tokenizeWwwPrefix,
  partial: true
};
const domain = {
  tokenize: tokenizeDomain,
  partial: true
};
const path = {
  tokenize: tokenizePath,
  partial: true
};
const trail = {
  tokenize: tokenizeTrail,
  partial: true
};
const emailDomainDotTrail = {
  tokenize: tokenizeEmailDomainDotTrail,
  partial: true
};
const wwwAutolink = {
  tokenize: tokenizeWwwAutolink,
  previous: previousWww
};
const protocolAutolink = {
  tokenize: tokenizeProtocolAutolink,
  previous: previousProtocol
};
const emailAutolink = {
  tokenize: tokenizeEmailAutolink,
  previous: previousEmail
};

/** @type {ConstructRecord} */
const text = {};

// To do: next major: expose functions that yields extension.

/**
 * Extension for `micromark` that can be passed in `extensions` to enable GFM
 * autolink literal syntax.
 *
 * @type {Extension}
 */
const gfmAutolinkLiteral = {
  text
};

/** @type {Code} */
let code = 48;

// Add alphanumerics.
while (code < 123) {
  text[code] = emailAutolink;
  code++;
  if (code === 58) code = 65;
  else if (code === 91) code = 97;
}
text[43] = emailAutolink;
text[45] = emailAutolink;
text[46] = emailAutolink;
text[95] = emailAutolink;
text[72] = [emailAutolink, protocolAutolink];
text[104] = [emailAutolink, protocolAutolink];
text[87] = [emailAutolink, wwwAutolink];
text[119] = [emailAutolink, wwwAutolink];

// To do: perform email autolink literals on events, afterwards.
// That’s where `markdown-rs` and `cmark-gfm` perform it.
// It should look for `@`, then for atext backwards, and then for a label
// forwards.
// To do: `mailto:`, `xmpp:` protocol as prefix.

/**
 * Email autolink literal.
 *
 * ```markdown
 * > | a contact@example.org b
 *       ^^^^^^^^^^^^^^^^^^^
 * ```
 *
 * @this {TokenizeContext}
 * @type {Tokenizer}
 */
function tokenizeEmailAutolink(effects, ok, nok) {
  const self = this;
  /** @type {boolean | undefined} */
  let dot;
  /** @type {boolean} */
  let data;
  return start

  /**
   * Start of email autolink literal.
   *
   * ```markdown
   * > | a contact@example.org b
   *       ^
   * ```
   *
   * @type {State}
   */
  function start(code) {
    if (
      !gfmAtext(code) ||
      !previousEmail.call(self, self.previous) ||
      previousUnbalanced(self.events)
    ) {
      return nok(code)
    }
    effects.enter('literalAutolink');
    effects.enter('literalAutolinkEmail');
    return atext(code)
  }

  /**
   * In email atext.
   *
   * ```markdown
   * > | a contact@example.org b
   *       ^
   * ```
   *
   * @type {State}
   */
  function atext(code) {
    if (gfmAtext(code)) {
      effects.consume(code);
      return atext
    }
    if (code === 64) {
      effects.consume(code);
      return emailDomain
    }
    return nok(code)
  }

  /**
   * In email domain.
   *
   * The reference code is a bit overly complex as it handles the `@`, of which
   * there may be just one.
   * Source: <https://github.com/github/cmark-gfm/blob/ef1cfcb/extensions/autolink.c#L318>
   *
   * ```markdown
   * > | a contact@example.org b
   *               ^
   * ```
   *
   * @type {State}
   */
  function emailDomain(code) {
    // Dot followed by alphanumerical (not `-` or `_`).
    if (code === 46) {
      return effects.check(
        emailDomainDotTrail,
        emailDomainAfter,
        emailDomainDot
      )(code)
    }

    // Alphanumerical, `-`, and `_`.
    if (code === 45 || code === 95 || asciiAlphanumeric(code)) {
      data = true;
      effects.consume(code);
      return emailDomain
    }

    // To do: `/` if xmpp.

    // Note: normally we’d truncate trailing punctuation from the link.
    // However, email autolink literals cannot contain any of those markers,
    // except for `.`, but that can only occur if it isn’t trailing.
    // So we can ignore truncating!
    return emailDomainAfter(code)
  }

  /**
   * In email domain, on dot that is not a trail.
   *
   * ```markdown
   * > | a contact@example.org b
   *                      ^
   * ```
   *
   * @type {State}
   */
  function emailDomainDot(code) {
    effects.consume(code);
    dot = true;
    return emailDomain
  }

  /**
   * After email domain.
   *
   * ```markdown
   * > | a contact@example.org b
   *                          ^
   * ```
   *
   * @type {State}
   */
  function emailDomainAfter(code) {
    // Domain must not be empty, must include a dot, and must end in alphabetical.
    // Source: <https://github.com/github/cmark-gfm/blob/ef1cfcb/extensions/autolink.c#L332>.
    if (data && dot && asciiAlpha(self.previous)) {
      effects.exit('literalAutolinkEmail');
      effects.exit('literalAutolink');
      return ok(code)
    }
    return nok(code)
  }
}

/**
 * `www` autolink literal.
 *
 * ```markdown
 * > | a www.example.org b
 *       ^^^^^^^^^^^^^^^
 * ```
 *
 * @this {TokenizeContext}
 * @type {Tokenizer}
 */
function tokenizeWwwAutolink(effects, ok, nok) {
  const self = this;
  return wwwStart

  /**
   * Start of www autolink literal.
   *
   * ```markdown
   * > | www.example.com/a?b#c
   *     ^
   * ```
   *
   * @type {State}
   */
  function wwwStart(code) {
    if (
      (code !== 87 && code !== 119) ||
      !previousWww.call(self, self.previous) ||
      previousUnbalanced(self.events)
    ) {
      return nok(code)
    }
    effects.enter('literalAutolink');
    effects.enter('literalAutolinkWww');
    // Note: we *check*, so we can discard the `www.` we parsed.
    // If it worked, we consider it as a part of the domain.
    return effects.check(
      wwwPrefix,
      effects.attempt(domain, effects.attempt(path, wwwAfter), nok),
      nok
    )(code)
  }

  /**
   * After a www autolink literal.
   *
   * ```markdown
   * > | www.example.com/a?b#c
   *                          ^
   * ```
   *
   * @type {State}
   */
  function wwwAfter(code) {
    effects.exit('literalAutolinkWww');
    effects.exit('literalAutolink');
    return ok(code)
  }
}

/**
 * Protocol autolink literal.
 *
 * ```markdown
 * > | a https://example.org b
 *       ^^^^^^^^^^^^^^^^^^^
 * ```
 *
 * @this {TokenizeContext}
 * @type {Tokenizer}
 */
function tokenizeProtocolAutolink(effects, ok, nok) {
  const self = this;
  let buffer = '';
  let seen = false;
  return protocolStart

  /**
   * Start of protocol autolink literal.
   *
   * ```markdown
   * > | https://example.com/a?b#c
   *     ^
   * ```
   *
   * @type {State}
   */
  function protocolStart(code) {
    if (
      (code === 72 || code === 104) &&
      previousProtocol.call(self, self.previous) &&
      !previousUnbalanced(self.events)
    ) {
      effects.enter('literalAutolink');
      effects.enter('literalAutolinkHttp');
      buffer += String.fromCodePoint(code);
      effects.consume(code);
      return protocolPrefixInside
    }
    return nok(code)
  }

  /**
   * In protocol.
   *
   * ```markdown
   * > | https://example.com/a?b#c
   *     ^^^^^
   * ```
   *
   * @type {State}
   */
  function protocolPrefixInside(code) {
    // `5` is size of `https`
    if (asciiAlpha(code) && buffer.length < 5) {
      // @ts-expect-error: definitely number.
      buffer += String.fromCodePoint(code);
      effects.consume(code);
      return protocolPrefixInside
    }
    if (code === 58) {
      const protocol = buffer.toLowerCase();
      if (protocol === 'http' || protocol === 'https') {
        effects.consume(code);
        return protocolSlashesInside
      }
    }
    return nok(code)
  }

  /**
   * In slashes.
   *
   * ```markdown
   * > | https://example.com/a?b#c
   *           ^^
   * ```
   *
   * @type {State}
   */
  function protocolSlashesInside(code) {
    if (code === 47) {
      effects.consume(code);
      if (seen) {
        return afterProtocol
      }
      seen = true;
      return protocolSlashesInside
    }
    return nok(code)
  }

  /**
   * After protocol, before domain.
   *
   * ```markdown
   * > | https://example.com/a?b#c
   *             ^
   * ```
   *
   * @type {State}
   */
  function afterProtocol(code) {
    // To do: this is different from `markdown-rs`:
    // https://github.com/wooorm/markdown-rs/blob/b3a921c761309ae00a51fe348d8a43adbc54b518/src/construct/gfm_autolink_literal.rs#L172-L182
    return code === null ||
      asciiControl(code) ||
      markdownLineEndingOrSpace(code) ||
      unicodeWhitespace(code) ||
      unicodePunctuation(code)
      ? nok(code)
      : effects.attempt(domain, effects.attempt(path, protocolAfter), nok)(code)
  }

  /**
   * After a protocol autolink literal.
   *
   * ```markdown
   * > | https://example.com/a?b#c
   *                              ^
   * ```
   *
   * @type {State}
   */
  function protocolAfter(code) {
    effects.exit('literalAutolinkHttp');
    effects.exit('literalAutolink');
    return ok(code)
  }
}

/**
 * `www` prefix.
 *
 * ```markdown
 * > | a www.example.org b
 *       ^^^^
 * ```
 *
 * @this {TokenizeContext}
 * @type {Tokenizer}
 */
function tokenizeWwwPrefix(effects, ok, nok) {
  let size = 0;
  return wwwPrefixInside

  /**
   * In www prefix.
   *
   * ```markdown
   * > | www.example.com
   *     ^^^^
   * ```
   *
   * @type {State}
   */
  function wwwPrefixInside(code) {
    if ((code === 87 || code === 119) && size < 3) {
      size++;
      effects.consume(code);
      return wwwPrefixInside
    }
    if (code === 46 && size === 3) {
      effects.consume(code);
      return wwwPrefixAfter
    }
    return nok(code)
  }

  /**
   * After www prefix.
   *
   * ```markdown
   * > | www.example.com
   *         ^
   * ```
   *
   * @type {State}
   */
  function wwwPrefixAfter(code) {
    // If there is *anything*, we can link.
    return code === null ? nok(code) : ok(code)
  }
}

/**
 * Domain.
 *
 * ```markdown
 * > | a https://example.org b
 *               ^^^^^^^^^^^
 * ```
 *
 * @this {TokenizeContext}
 * @type {Tokenizer}
 */
function tokenizeDomain(effects, ok, nok) {
  /** @type {boolean | undefined} */
  let underscoreInLastSegment;
  /** @type {boolean | undefined} */
  let underscoreInLastLastSegment;
  /** @type {boolean | undefined} */
  let seen;
  return domainInside

  /**
   * In domain.
   *
   * ```markdown
   * > | https://example.com/a
   *             ^^^^^^^^^^^
   * ```
   *
   * @type {State}
   */
  function domainInside(code) {
    // Check whether this marker, which is a trailing punctuation
    // marker, optionally followed by more trailing markers, and then
    // followed by an end.
    if (code === 46 || code === 95) {
      return effects.check(trail, domainAfter, domainAtPunctuation)(code)
    }

    // GH documents that only alphanumerics (other than `-`, `.`, and `_`) can
    // occur, which sounds like ASCII only, but they also support `www.點看.com`,
    // so that’s Unicode.
    // Instead of some new production for Unicode alphanumerics, markdown
    // already has that for Unicode punctuation and whitespace, so use those.
    // Source: <https://github.com/github/cmark-gfm/blob/ef1cfcb/extensions/autolink.c#L12>.
    if (
      code === null ||
      markdownLineEndingOrSpace(code) ||
      unicodeWhitespace(code) ||
      (code !== 45 && unicodePunctuation(code))
    ) {
      return domainAfter(code)
    }
    seen = true;
    effects.consume(code);
    return domainInside
  }

  /**
   * In domain, at potential trailing punctuation, that was not trailing.
   *
   * ```markdown
   * > | https://example.com
   *                    ^
   * ```
   *
   * @type {State}
   */
  function domainAtPunctuation(code) {
    // There is an underscore in the last segment of the domain
    if (code === 95) {
      underscoreInLastSegment = true;
    }
    // Otherwise, it’s a `.`: save the last segment underscore in the
    // penultimate segment slot.
    else {
      underscoreInLastLastSegment = underscoreInLastSegment;
      underscoreInLastSegment = undefined;
    }
    effects.consume(code);
    return domainInside
  }

  /**
   * After domain.
   *
   * ```markdown
   * > | https://example.com/a
   *                        ^
   * ```
   *
   * @type {State} */
  function domainAfter(code) {
    // Note: that’s GH says a dot is needed, but it’s not true:
    // <https://github.com/github/cmark-gfm/issues/279>
    if (underscoreInLastLastSegment || underscoreInLastSegment || !seen) {
      return nok(code)
    }
    return ok(code)
  }
}

/**
 * Path.
 *
 * ```markdown
 * > | a https://example.org/stuff b
 *                          ^^^^^^
 * ```
 *
 * @this {TokenizeContext}
 * @type {Tokenizer}
 */
function tokenizePath(effects, ok) {
  let sizeOpen = 0;
  let sizeClose = 0;
  return pathInside

  /**
   * In path.
   *
   * ```markdown
   * > | https://example.com/a
   *                        ^^
   * ```
   *
   * @type {State}
   */
  function pathInside(code) {
    if (code === 40) {
      sizeOpen++;
      effects.consume(code);
      return pathInside
    }

    // To do: `markdown-rs` also needs this.
    // If this is a paren, and there are less closings than openings,
    // we don’t check for a trail.
    if (code === 41 && sizeClose < sizeOpen) {
      return pathAtPunctuation(code)
    }

    // Check whether this trailing punctuation marker is optionally
    // followed by more trailing markers, and then followed
    // by an end.
    if (
      code === 33 ||
      code === 34 ||
      code === 38 ||
      code === 39 ||
      code === 41 ||
      code === 42 ||
      code === 44 ||
      code === 46 ||
      code === 58 ||
      code === 59 ||
      code === 60 ||
      code === 63 ||
      code === 93 ||
      code === 95 ||
      code === 126
    ) {
      return effects.check(trail, ok, pathAtPunctuation)(code)
    }
    if (
      code === null ||
      markdownLineEndingOrSpace(code) ||
      unicodeWhitespace(code)
    ) {
      return ok(code)
    }
    effects.consume(code);
    return pathInside
  }

  /**
   * In path, at potential trailing punctuation, that was not trailing.
   *
   * ```markdown
   * > | https://example.com/a"b
   *                          ^
   * ```
   *
   * @type {State}
   */
  function pathAtPunctuation(code) {
    // Count closing parens.
    if (code === 41) {
      sizeClose++;
    }
    effects.consume(code);
    return pathInside
  }
}

/**
 * Trail.
 *
 * This calls `ok` if this *is* the trail, followed by an end, which means
 * the entire trail is not part of the link.
 * It calls `nok` if this *is* part of the link.
 *
 * ```markdown
 * > | https://example.com").
 *                        ^^^
 * ```
 *
 * @this {TokenizeContext}
 * @type {Tokenizer}
 */
function tokenizeTrail(effects, ok, nok) {
  return trail

  /**
   * In trail of domain or path.
   *
   * ```markdown
   * > | https://example.com").
   *                        ^
   * ```
   *
   * @type {State}
   */
  function trail(code) {
    // Regular trailing punctuation.
    if (
      code === 33 ||
      code === 34 ||
      code === 39 ||
      code === 41 ||
      code === 42 ||
      code === 44 ||
      code === 46 ||
      code === 58 ||
      code === 59 ||
      code === 63 ||
      code === 95 ||
      code === 126
    ) {
      effects.consume(code);
      return trail
    }

    // `&` followed by one or more alphabeticals and then a `;`, is
    // as a whole considered as trailing punctuation.
    // In all other cases, it is considered as continuation of the URL.
    if (code === 38) {
      effects.consume(code);
      return trailCharRefStart
    }

    // Needed because we allow literals after `[`, as we fix:
    // <https://github.com/github/cmark-gfm/issues/278>.
    // Check that it is not followed by `(` or `[`.
    if (code === 93) {
      effects.consume(code);
      return trailBracketAfter
    }
    if (
      // `<` is an end.
      code === 60 ||
      // So is whitespace.
      code === null ||
      markdownLineEndingOrSpace(code) ||
      unicodeWhitespace(code)
    ) {
      return ok(code)
    }
    return nok(code)
  }

  /**
   * In trail, after `]`.
   *
   * > 👉 **Note**: this deviates from `cmark-gfm` to fix a bug.
   * > See end of <https://github.com/github/cmark-gfm/issues/278> for more.
   *
   * ```markdown
   * > | https://example.com](
   *                         ^
   * ```
   *
   * @type {State}
   */
  function trailBracketAfter(code) {
    // Whitespace or something that could start a resource or reference is the end.
    // Switch back to trail otherwise.
    if (
      code === null ||
      code === 40 ||
      code === 91 ||
      markdownLineEndingOrSpace(code) ||
      unicodeWhitespace(code)
    ) {
      return ok(code)
    }
    return trail(code)
  }

  /**
   * In character-reference like trail, after `&`.
   *
   * ```markdown
   * > | https://example.com&amp;).
   *                         ^
   * ```
   *
   * @type {State}
   */
  function trailCharRefStart(code) {
    // When non-alpha, it’s not a trail.
    return asciiAlpha(code) ? trailCharRefInside(code) : nok(code)
  }

  /**
   * In character-reference like trail.
   *
   * ```markdown
   * > | https://example.com&amp;).
   *                         ^
   * ```
   *
   * @type {State}
   */
  function trailCharRefInside(code) {
    // Switch back to trail if this is well-formed.
    if (code === 59) {
      effects.consume(code);
      return trail
    }
    if (asciiAlpha(code)) {
      effects.consume(code);
      return trailCharRefInside
    }

    // It’s not a trail.
    return nok(code)
  }
}

/**
 * Dot in email domain trail.
 *
 * This calls `ok` if this *is* the trail, followed by an end, which means
 * the trail is not part of the link.
 * It calls `nok` if this *is* part of the link.
 *
 * ```markdown
 * > | contact@example.org.
 *                        ^
 * ```
 *
 * @this {TokenizeContext}
 * @type {Tokenizer}
 */
function tokenizeEmailDomainDotTrail(effects, ok, nok) {
  return start

  /**
   * Dot.
   *
   * ```markdown
   * > | contact@example.org.
   *                    ^   ^
   * ```
   *
   * @type {State}
   */
  function start(code) {
    // Must be dot.
    effects.consume(code);
    return after
  }

  /**
   * After dot.
   *
   * ```markdown
   * > | contact@example.org.
   *                     ^   ^
   * ```
   *
   * @type {State}
   */
  function after(code) {
    // Not a trail if alphanumeric.
    return asciiAlphanumeric(code) ? nok(code) : ok(code)
  }
}

/**
 * See:
 * <https://github.com/github/cmark-gfm/blob/ef1cfcb/extensions/autolink.c#L156>.
 *
 * @type {Previous}
 */
function previousWww(code) {
  return (
    code === null ||
    code === 40 ||
    code === 42 ||
    code === 95 ||
    code === 91 ||
    code === 93 ||
    code === 126 ||
    markdownLineEndingOrSpace(code)
  )
}

/**
 * See:
 * <https://github.com/github/cmark-gfm/blob/ef1cfcb/extensions/autolink.c#L214>.
 *
 * @type {Previous}
 */
function previousProtocol(code) {
  return !asciiAlpha(code)
}

/**
 * @this {TokenizeContext}
 * @type {Previous}
 */
function previousEmail(code) {
  // Do not allow a slash “inside” atext.
  // The reference code is a bit weird, but that’s what it results in.
  // Source: <https://github.com/github/cmark-gfm/blob/ef1cfcb/extensions/autolink.c#L307>.
  // Other than slash, every preceding character is allowed.
  return !(code === 47 || gfmAtext(code))
}

/**
 * @param {Code} code
 * @returns {boolean}
 */
function gfmAtext(code) {
  return (
    code === 43 ||
    code === 45 ||
    code === 46 ||
    code === 95 ||
    asciiAlphanumeric(code)
  )
}

/**
 * @param {Array<Event>} events
 * @returns {boolean}
 */
function previousUnbalanced(events) {
  let index = events.length;
  let result = false;
  while (index--) {
    const token = events[index][1];
    if (
      (token.type === 'labelLink' || token.type === 'labelImage') &&
      !token._balanced
    ) {
      result = true;
      break
    }

    // If we’ve seen this token, and it was marked as not having any unbalanced
    // bracket before it, we can exit.
    if (token._gfmAutolinkLiteralWalkedInto) {
      result = false;
      break
    }
  }
  if (events.length > 0 && !result) {
    // Mark the last token as “walked into” w/o finding
    // anything.
    events[events.length - 1][1]._gfmAutolinkLiteralWalkedInto = true;
  }
  return result
}

/**
 * @typedef {import('micromark-util-types').Event} Event
 * @typedef {import('micromark-util-types').Exiter} Exiter
 * @typedef {import('micromark-util-types').Extension} Extension
 * @typedef {import('micromark-util-types').Resolver} Resolver
 * @typedef {import('micromark-util-types').State} State
 * @typedef {import('micromark-util-types').Token} Token
 * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext
 * @typedef {import('micromark-util-types').Tokenizer} Tokenizer
 */

const indent = {
  tokenize: tokenizeIndent,
  partial: true
};

// To do: micromark should support a `_hiddenGfmFootnoteSupport`, which only
// affects label start (image).
// That will let us drop `tokenizePotentialGfmFootnote*`.
// It currently has a `_hiddenFootnoteSupport`, which affects that and more.
// That can be removed when `micromark-extension-footnote` is archived.

/**
 * Create an extension for `micromark` to enable GFM footnote syntax.
 *
 * @returns {Extension}
 *   Extension for `micromark` that can be passed in `extensions` to
 *   enable GFM footnote syntax.
 */
function gfmFootnote() {
  /** @type {Extension} */
  return {
    document: {
      [91]: {
        tokenize: tokenizeDefinitionStart,
        continuation: {
          tokenize: tokenizeDefinitionContinuation
        },
        exit: gfmFootnoteDefinitionEnd
      }
    },
    text: {
      [91]: {
        tokenize: tokenizeGfmFootnoteCall
      },
      [93]: {
        add: 'after',
        tokenize: tokenizePotentialGfmFootnoteCall,
        resolveTo: resolveToPotentialGfmFootnoteCall
      }
    }
  }
}

// To do: remove after micromark update.
/**
 * @this {TokenizeContext}
 * @type {Tokenizer}
 */
function tokenizePotentialGfmFootnoteCall(effects, ok, nok) {
  const self = this;
  let index = self.events.length;
  /** @type {Array<string>} */
  // @ts-expect-error It’s fine!
  const defined = self.parser.gfmFootnotes || (self.parser.gfmFootnotes = []);
  /** @type {Token} */
  let labelStart;

  // Find an opening.
  while (index--) {
    const token = self.events[index][1];
    if (token.type === 'labelImage') {
      labelStart = token;
      break
    }

    // Exit if we’ve walked far enough.
    if (
      token.type === 'gfmFootnoteCall' ||
      token.type === 'labelLink' ||
      token.type === 'label' ||
      token.type === 'image' ||
      token.type === 'link'
    ) {
      break
    }
  }
  return start

  /**
   * @type {State}
   */
  function start(code) {
    if (!labelStart || !labelStart._balanced) {
      return nok(code)
    }
    const id = normalizeIdentifier(
      self.sliceSerialize({
        start: labelStart.end,
        end: self.now()
      })
    );
    if (id.codePointAt(0) !== 94 || !defined.includes(id.slice(1))) {
      return nok(code)
    }
    effects.enter('gfmFootnoteCallLabelMarker');
    effects.consume(code);
    effects.exit('gfmFootnoteCallLabelMarker');
    return ok(code)
  }
}

// To do: remove after micromark update.
/** @type {Resolver} */
function resolveToPotentialGfmFootnoteCall(events, context) {
  let index = events.length;

  // Find an opening.
  while (index--) {
    if (
      events[index][1].type === 'labelImage' &&
      events[index][0] === 'enter'
    ) {
      break
    }
  }
  // Change the `labelImageMarker` to a `data`.
  events[index + 1][1].type = 'data';
  events[index + 3][1].type = 'gfmFootnoteCallLabelMarker';

  // The whole (without `!`):
  /** @type {Token} */
  const call = {
    type: 'gfmFootnoteCall',
    start: Object.assign({}, events[index + 3][1].start),
    end: Object.assign({}, events[events.length - 1][1].end)
  };
  // The `^` marker
  /** @type {Token} */
  const marker = {
    type: 'gfmFootnoteCallMarker',
    start: Object.assign({}, events[index + 3][1].end),
    end: Object.assign({}, events[index + 3][1].end)
  };
  // Increment the end 1 character.
  marker.end.column++;
  marker.end.offset++;
  marker.end._bufferIndex++;
  /** @type {Token} */
  const string = {
    type: 'gfmFootnoteCallString',
    start: Object.assign({}, marker.end),
    end: Object.assign({}, events[events.length - 1][1].start)
  };
  /** @type {Token} */
  const chunk = {
    type: 'chunkString',
    contentType: 'string',
    start: Object.assign({}, string.start),
    end: Object.assign({}, string.end)
  };

  /** @type {Array<Event>} */
  const replacement = [
    // Take the `labelImageMarker` (now `data`, the `!`)
    events[index + 1],
    events[index + 2],
    ['enter', call, context],
    // The `[`
    events[index + 3],
    events[index + 4],
    // The `^`.
    ['enter', marker, context],
    ['exit', marker, context],
    // Everything in between.
    ['enter', string, context],
    ['enter', chunk, context],
    ['exit', chunk, context],
    ['exit', string, context],
    // The ending (`]`, properly parsed and labelled).
    events[events.length - 2],
    events[events.length - 1],
    ['exit', call, context]
  ];
  events.splice(index, events.length - index + 1, ...replacement);
  return events
}

/**
 * @this {TokenizeContext}
 * @type {Tokenizer}
 */
function tokenizeGfmFootnoteCall(effects, ok, nok) {
  const self = this;
  /** @type {Array<string>} */
  // @ts-expect-error It’s fine!
  const defined = self.parser.gfmFootnotes || (self.parser.gfmFootnotes = []);
  let size = 0;
  /** @type {boolean} */
  let data;

  // Note: the implementation of `markdown-rs` is different, because it houses
  // core *and* extensions in one project.
  // Therefore, it can include footnote logic inside `label-end`.
  // We can’t do that, but luckily, we can parse footnotes in a simpler way than
  // needed for labels.
  return start

  /**
   * Start of footnote label.
   *
   * ```markdown
   * > | a [^b] c
   *       ^
   * ```
   *
   * @type {State}
   */
  function start(code) {
    effects.enter('gfmFootnoteCall');
    effects.enter('gfmFootnoteCallLabelMarker');
    effects.consume(code);
    effects.exit('gfmFootnoteCallLabelMarker');
    return callStart
  }

  /**
   * After `[`, at `^`.
   *
   * ```markdown
   * > | a [^b] c
   *        ^
   * ```
   *
   * @type {State}
   */
  function callStart(code) {
    if (code !== 94) return nok(code)
    effects.enter('gfmFootnoteCallMarker');
    effects.consume(code);
    effects.exit('gfmFootnoteCallMarker');
    effects.enter('gfmFootnoteCallString');
    effects.enter('chunkString').contentType = 'string';
    return callData
  }

  /**
   * In label.
   *
   * ```markdown
   * > | a [^b] c
   *         ^
   * ```
   *
   * @type {State}
   */
  function callData(code) {
    if (
      // Too long.
      size > 999 ||
      // Closing brace with nothing.
      (code === 93 && !data) ||
      // Space or tab is not supported by GFM for some reason.
      // `\n` and `[` not being supported makes sense.
      code === null ||
      code === 91 ||
      markdownLineEndingOrSpace(code)
    ) {
      return nok(code)
    }
    if (code === 93) {
      effects.exit('chunkString');
      const token = effects.exit('gfmFootnoteCallString');
      if (!defined.includes(normalizeIdentifier(self.sliceSerialize(token)))) {
        return nok(code)
      }
      effects.enter('gfmFootnoteCallLabelMarker');
      effects.consume(code);
      effects.exit('gfmFootnoteCallLabelMarker');
      effects.exit('gfmFootnoteCall');
      return ok
    }
    if (!markdownLineEndingOrSpace(code)) {
      data = true;
    }
    size++;
    effects.consume(code);
    return code === 92 ? callEscape : callData
  }

  /**
   * On character after escape.
   *
   * ```markdown
   * > | a [^b\c] d
   *           ^
   * ```
   *
   * @type {State}
   */
  function callEscape(code) {
    if (code === 91 || code === 92 || code === 93) {
      effects.consume(code);
      size++;
      return callData
    }
    return callData(code)
  }
}

/**
 * @this {TokenizeContext}
 * @type {Tokenizer}
 */
function tokenizeDefinitionStart(effects, ok, nok) {
  const self = this;
  /** @type {Array<string>} */
  // @ts-expect-error It’s fine!
  const defined = self.parser.gfmFootnotes || (self.parser.gfmFootnotes = []);
  /** @type {string} */
  let identifier;
  let size = 0;
  /** @type {boolean | undefined} */
  let data;
  return start

  /**
   * Start of GFM footnote definition.
   *
   * ```markdown
   * > | [^a]: b
   *     ^
   * ```
   *
   * @type {State}
   */
  function start(code) {
    effects.enter('gfmFootnoteDefinition')._container = true;
    effects.enter('gfmFootnoteDefinitionLabel');
    effects.enter('gfmFootnoteDefinitionLabelMarker');
    effects.consume(code);
    effects.exit('gfmFootnoteDefinitionLabelMarker');
    return labelAtMarker
  }

  /**
   * In label, at caret.
   *
   * ```markdown
   * > | [^a]: b
   *      ^
   * ```
   *
   * @type {State}
   */
  function labelAtMarker(code) {
    if (code === 94) {
      effects.enter('gfmFootnoteDefinitionMarker');
      effects.consume(code);
      effects.exit('gfmFootnoteDefinitionMarker');
      effects.enter('gfmFootnoteDefinitionLabelString');
      effects.enter('chunkString').contentType = 'string';
      return labelInside
    }
    return nok(code)
  }

  /**
   * In label.
   *
   * > 👉 **Note**: `cmark-gfm` prevents whitespace from occurring in footnote
   * > definition labels.
   *
   * ```markdown
   * > | [^a]: b
   *       ^
   * ```
   *
   * @type {State}
   */
  function labelInside(code) {
    if (
      // Too long.
      size > 999 ||
      // Closing brace with nothing.
      (code === 93 && !data) ||
      // Space or tab is not supported by GFM for some reason.
      // `\n` and `[` not being supported makes sense.
      code === null ||
      code === 91 ||
      markdownLineEndingOrSpace(code)
    ) {
      return nok(code)
    }
    if (code === 93) {
      effects.exit('chunkString');
      const token = effects.exit('gfmFootnoteDefinitionLabelString');
      identifier = normalizeIdentifier(self.sliceSerialize(token));
      effects.enter('gfmFootnoteDefinitionLabelMarker');
      effects.consume(code);
      effects.exit('gfmFootnoteDefinitionLabelMarker');
      effects.exit('gfmFootnoteDefinitionLabel');
      return labelAfter
    }
    if (!markdownLineEndingOrSpace(code)) {
      data = true;
    }
    size++;
    effects.consume(code);
    return code === 92 ? labelEscape : labelInside
  }

  /**
   * After `\`, at a special character.
   *
   * > 👉 **Note**: `cmark-gfm` currently does not support escaped brackets:
   * > <https://github.com/github/cmark-gfm/issues/240>
   *
   * ```markdown
   * > | [^a\*b]: c
   *         ^
   * ```
   *
   * @type {State}
   */
  function labelEscape(code) {
    if (code === 91 || code === 92 || code === 93) {
      effects.consume(code);
      size++;
      return labelInside
    }
    return labelInside(code)
  }

  /**
   * After definition label.
   *
   * ```markdown
   * > | [^a]: b
   *         ^
   * ```
   *
   * @type {State}
   */
  function labelAfter(code) {
    if (code === 58) {
      effects.enter('definitionMarker');
      effects.consume(code);
      effects.exit('definitionMarker');
      if (!defined.includes(identifier)) {
        defined.push(identifier);
      }

      // Any whitespace after the marker is eaten, forming indented code
      // is not possible.
      // No space is also fine, just like a block quote marker.
      return factorySpace(
        effects,
        whitespaceAfter,
        'gfmFootnoteDefinitionWhitespace'
      )
    }
    return nok(code)
  }

  /**
   * After definition prefix.
   *
   * ```markdown
   * > | [^a]: b
   *           ^
   * ```
   *
   * @type {State}
   */
  function whitespaceAfter(code) {
    // `markdown-rs` has a wrapping token for the prefix that is closed here.
    return ok(code)
  }
}

/**
 * @this {TokenizeContext}
 * @type {Tokenizer}
 */
function tokenizeDefinitionContinuation(effects, ok, nok) {
  /// Start of footnote definition continuation.
  ///
  /// ```markdown
  ///   | [^a]: b
  /// > |     c
  ///     ^
  /// ```
  //
  // Either a blank line, which is okay, or an indented thing.
  return effects.check(blankLine, ok, effects.attempt(indent, ok, nok))
}

/** @type {Exiter} */
function gfmFootnoteDefinitionEnd(effects) {
  effects.exit('gfmFootnoteDefinition');
}

/**
 * @this {TokenizeContext}
 * @type {Tokenizer}
 */
function tokenizeIndent(effects, ok, nok) {
  const self = this;
  return factorySpace(
    effects,
    afterPrefix,
    'gfmFootnoteDefinitionIndent',
    4 + 1
  )

  /**
   * @type {State}
   */
  function afterPrefix(code) {
    const tail = self.events[self.events.length - 1];
    return tail &&
      tail[1].type === 'gfmFootnoteDefinitionIndent' &&
      tail[2].sliceSerialize(tail[1], true).length === 4
      ? ok(code)
      : nok(code)
  }
}

/**
 * @typedef {import('micromark-util-types').Event} Event
 * @typedef {import('micromark-util-types').Extension} Extension
 * @typedef {import('micromark-util-types').Resolver} Resolver
 * @typedef {import('micromark-util-types').State} State
 * @typedef {import('micromark-util-types').Token} Token
 * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext
 * @typedef {import('micromark-util-types').Tokenizer} Tokenizer
 *
 * @typedef Options
 *   Configuration (optional).
 * @property {boolean} [singleTilde=true]
 *   Whether to support strikethrough with a single tilde.
 *
 *   Single tildes work on github.com, but are technically prohibited by the
 *   GFM spec.
 */

/**
 * Create an extension for `micromark` to enable GFM strikethrough syntax.
 *
 * @param {Options | null | undefined} [options]
 *   Configuration.
 * @returns {Extension}
 *   Extension for `micromark` that can be passed in `extensions`, to
 *   enable GFM strikethrough syntax.
 */
function gfmStrikethrough(options) {
  const options_ = options || {};
  let single = options_.singleTilde;
  const tokenizer = {
    tokenize: tokenizeStrikethrough,
    resolveAll: resolveAllStrikethrough
  };
  if (single === null || single === undefined) {
    single = true;
  }
  return {
    text: {
      [126]: tokenizer
    },
    insideSpan: {
      null: [tokenizer]
    },
    attentionMarkers: {
      null: [126]
    }
  }

  /**
   * Take events and resolve strikethrough.
   *
   * @type {Resolver}
   */
  function resolveAllStrikethrough(events, context) {
    let index = -1;

    // Walk through all events.
    while (++index < events.length) {
      // Find a token that can close.
      if (
        events[index][0] === 'enter' &&
        events[index][1].type === 'strikethroughSequenceTemporary' &&
        events[index][1]._close
      ) {
        let open = index;

        // Now walk back to find an opener.
        while (open--) {
          // Find a token that can open the closer.
          if (
            events[open][0] === 'exit' &&
            events[open][1].type === 'strikethroughSequenceTemporary' &&
            events[open][1]._open &&
            // If the sizes are the same:
            events[index][1].end.offset - events[index][1].start.offset ===
              events[open][1].end.offset - events[open][1].start.offset
          ) {
            events[index][1].type = 'strikethroughSequence';
            events[open][1].type = 'strikethroughSequence';

            /** @type {Token} */
            const strikethrough = {
              type: 'strikethrough',
              start: Object.assign({}, events[open][1].start),
              end: Object.assign({}, events[index][1].end)
            };

            /** @type {Token} */
            const text = {
              type: 'strikethroughText',
              start: Object.assign({}, events[open][1].end),
              end: Object.assign({}, events[index][1].start)
            };

            // Opening.
            /** @type {Array<Event>} */
            const nextEvents = [
              ['enter', strikethrough, context],
              ['enter', events[open][1], context],
              ['exit', events[open][1], context],
              ['enter', text, context]
            ];
            const insideSpan = context.parser.constructs.insideSpan.null;
            if (insideSpan) {
              // Between.
              splice(
                nextEvents,
                nextEvents.length,
                0,
                resolveAll(insideSpan, events.slice(open + 1, index), context)
              );
            }

            // Closing.
            splice(nextEvents, nextEvents.length, 0, [
              ['exit', text, context],
              ['enter', events[index][1], context],
              ['exit', events[index][1], context],
              ['exit', strikethrough, context]
            ]);
            splice(events, open - 1, index - open + 3, nextEvents);
            index = open + nextEvents.length - 2;
            break
          }
        }
      }
    }
    index = -1;
    while (++index < events.length) {
      if (events[index][1].type === 'strikethroughSequenceTemporary') {
        events[index][1].type = 'data';
      }
    }
    return events
  }

  /**
   * @this {TokenizeContext}
   * @type {Tokenizer}
   */
  function tokenizeStrikethrough(effects, ok, nok) {
    const previous = this.previous;
    const events = this.events;
    let size = 0;
    return start

    /** @type {State} */
    function start(code) {
      if (
        previous === 126 &&
        events[events.length - 1][1].type !== 'characterEscape'
      ) {
        return nok(code)
      }
      effects.enter('strikethroughSequenceTemporary');
      return more(code)
    }

    /** @type {State} */
    function more(code) {
      const before = classifyCharacter(previous);
      if (code === 126) {
        // If this is the third marker, exit.
        if (size > 1) return nok(code)
        effects.consume(code);
        size++;
        return more
      }
      if (size < 2 && !single) return nok(code)
      const token = effects.exit('strikethroughSequenceTemporary');
      const after = classifyCharacter(code);
      token._open = !after || (after === 2 && Boolean(before));
      token._close = !before || (before === 2 && Boolean(after));
      return ok(code)
    }
  }
}

/**
 * @typedef {import('micromark-util-types').Event} Event
 */

// Port of `edit_map.rs` from `markdown-rs`.
// This should move to `markdown-js` later.

// Deal with several changes in events, batching them together.
//
// Preferably, changes should be kept to a minimum.
// Sometimes, it’s needed to change the list of events, because parsing can be
// messy, and it helps to expose a cleaner interface of events to the compiler
// and other users.
// It can also help to merge many adjacent similar events.
// And, in other cases, it’s needed to parse subcontent: pass some events
// through another tokenizer and inject the result.

/**
 * @typedef {[number, number, Array<Event>]} Change
 * @typedef {[number, number, number]} Jump
 */

/**
 * Tracks a bunch of edits.
 */
class EditMap {
  /**
   * Create a new edit map.
   */
  constructor() {
    /**
     * Record of changes.
     *
     * @type {Array<Change>}
     */
    this.map = [];
  }

  /**
   * Create an edit: a remove and/or add at a certain place.
   *
   * @param {number} index
   * @param {number} remove
   * @param {Array<Event>} add
   * @returns {void}
   */
  add(index, remove, add) {
    addImpl(this, index, remove, add);
  }

  // To do: not used here.
  // /**
  //  * Create an edit: but insert `add` before existing additions.
  //  *
  //  * @param {number} index
  //  * @param {number} remove
  //  * @param {Array<Event>} add
  //  * @returns {void}
  //  */
  // addBefore(index, remove, add) {
  //   addImpl(this, index, remove, add, true)
  // }

  /**
   * Done, change the events.
   *
   * @param {Array<Event>} events
   * @returns {void}
   */
  consume(events) {
    this.map.sort((a, b) => a[0] - b[0]);

    /* c8 ignore next 3 -- `resolve` is never called without tables, so without edits. */
    if (this.map.length === 0) {
      return
    }

    // To do: if links are added in events, like they are in `markdown-rs`,
    // this is needed.
    // // Calculate jumps: where items in the current list move to.
    // /** @type {Array<Jump>} */
    // const jumps = []
    // let index = 0
    // let addAcc = 0
    // let removeAcc = 0
    // while (index < this.map.length) {
    //   const [at, remove, add] = this.map[index]
    //   removeAcc += remove
    //   addAcc += add.length
    //   jumps.push([at, removeAcc, addAcc])
    //   index += 1
    // }
    //
    // . shiftLinks(events, jumps)

    let index = this.map.length;
    /** @type {Array<Array<Event>>} */
    const vecs = [];
    while (index > 0) {
      index -= 1;
      vecs.push(events.slice(this.map[index][0] + this.map[index][1]));
      // eslint-disable-next-line unicorn/no-array-push-push
      vecs.push(this.map[index][2]);

      // Truncate rest.
      events.length = this.map[index][0];
    }
    vecs.push([...events]);
    events.length = 0;
    let slice = vecs.pop();
    while (slice) {
      events.push(...slice);
      slice = vecs.pop();
    }

    // Truncate everything.
    this.map.length = 0;
  }
}

/**
 * Create an edit.
 *
 * @param {EditMap} editMap
 * @param {number} at
 * @param {number} remove
 * @param {Array<Event>} add
 * @returns {void}
 */
function addImpl(editMap, at, remove, add) {
  let index = 0;

  /* c8 ignore next 3 -- `resolve` is never called without tables, so without edits. */
  if (remove === 0 && add.length === 0) {
    return
  }
  while (index < editMap.map.length) {
    if (editMap.map[index][0] === at) {
      editMap.map[index][1] += remove;

      // To do: before not used.
      // if (before) {
      //   add.push(...editMap.map[index][2])
      //   editMap.map[index][2] = add
      // } else {
      editMap.map[index][2].push(...add);
      // }

      return
    }
    index += 1;
  }
  editMap.map.push([at, remove, add]);
}

// /**
//  * Shift `previous` and `next` links according to `jumps`.
//  *
//  * This fixes links in case there are events removed or added between them.
//  *
//  * @param {Array<Event>} events
//  * @param {Array<Jump>} jumps
//  */
// function shiftLinks(events, jumps) {
//   let jumpIndex = 0
//   let index = 0
//   let add = 0
//   let rm = 0

//   while (index < events.length) {
//     const rmCurr = rm

//     while (jumpIndex < jumps.length && jumps[jumpIndex][0] <= index) {
//       add = jumps[jumpIndex][2]
//       rm = jumps[jumpIndex][1]
//       jumpIndex += 1
//     }

//     // Ignore items that will be removed.
//     if (rm > rmCurr) {
//       index += rm - rmCurr
//     } else {
//       console.log('to do: links?', add, rmCurr)
//       // ?
//       // if let Some(link) = &events[index].link {
//       //     if let Some(next) = link.next {
//       //         events[next].link.as_mut().unwrap().previous = Some(index + add - rm);
//       //         while jumpIndex < jumps.len() && jumps[jumpIndex].0 <= next {
//       //             add = jumps[jumpIndex].2;
//       //             rm = jumps[jumpIndex].1;
//       //             jumpIndex += 1;
//       //         }
//       //         events[index].link.as_mut().unwrap().next = Some(next + add - rm);
//       //         index = next;
//       //         continue;
//       //     }
//       // }
//       index += 1
//     }
//   }
// }

/**
 * @typedef {import('micromark-util-types').Event} Event
 */

/**
 * @typedef {'left' | 'center' | 'right' | 'none'} Align
 */

/**
 * Figure out the alignment of a GFM table.
 *
 * @param {Array<Event>} events
 * @param {number} index
 * @returns {Array<Align>}
 */
function gfmTableAlign(events, index) {
  let inDelimiterRow = false;
  /** @type {Array<Align>} */
  const align = [];
  while (index < events.length) {
    const event = events[index];
    if (inDelimiterRow) {
      if (event[0] === 'enter') {
        // Start of alignment value: set a new column.
        // To do: `markdown-rs` uses `tableDelimiterCellValue`.
        if (event[1].type === 'tableContent') {
          align.push(
            events[index + 1][1].type === 'tableDelimiterMarker'
              ? 'left'
              : 'none'
          );
        }
      }
      // Exits:
      // End of alignment value: change the column.
      // To do: `markdown-rs` uses `tableDelimiterCellValue`.
      else if (event[1].type === 'tableContent') {
        if (events[index - 1][1].type === 'tableDelimiterMarker') {
          const alignIndex = align.length - 1;
          align[alignIndex] = align[alignIndex] === 'left' ? 'center' : 'right';
        }
      }
      // Done!
      else if (event[1].type === 'tableDelimiterRow') {
        break
      }
    } else if (event[0] === 'enter' && event[1].type === 'tableDelimiterRow') {
      inDelimiterRow = true;
    }
    index += 1;
  }
  return align
}

/**
 * @typedef {import('micromark-util-types').Event} Event
 * @typedef {import('micromark-util-types').Extension} Extension
 * @typedef {import('micromark-util-types').Point} Point
 * @typedef {import('micromark-util-types').Resolver} Resolver
 * @typedef {import('micromark-util-types').State} State
 * @typedef {import('micromark-util-types').Token} Token
 * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext
 * @typedef {import('micromark-util-types').Tokenizer} Tokenizer
 */


// To do: next major: expose functions.

/**
 * Extension for `micromark` that can be passed in `extensions` to enable GFM
 * table syntax.
 *
 * @type {Extension}
 */
const gfmTable = {
  flow: {
    null: {
      tokenize: tokenizeTable,
      resolveAll: resolveTable
    }
  }
};

/**
 * @this {TokenizeContext}
 * @type {Tokenizer}
 */
function tokenizeTable(effects, ok, nok) {
  const self = this;
  let size = 0;
  let sizeB = 0;
  /** @type {boolean | undefined} */
  let seen;
  return start

  /**
   * Start of a GFM table.
   *
   * If there is a valid table row or table head before, then we try to parse
   * another row.
   * Otherwise, we try to parse a head.
   *
   * ```markdown
   * > | | a |
   *     ^
   *   | | - |
   * > | | b |
   *     ^
   * ```
   * @type {State}
   */
  function start(code) {
    let index = self.events.length - 1;
    while (index > -1) {
      const type = self.events[index][1].type;
      if (
        type === 'lineEnding' ||
        // Note: markdown-rs uses `whitespace` instead of `linePrefix`
        type === 'linePrefix'
      )
        index--;
      else break
    }
    const tail = index > -1 ? self.events[index][1].type : null;
    const next =
      tail === 'tableHead' || tail === 'tableRow' ? bodyRowStart : headRowBefore;

    // Don’t allow lazy body rows.
    if (next === bodyRowStart && self.parser.lazy[self.now().line]) {
      return nok(code)
    }
    return next(code)
  }

  /**
   * Before table head row.
   *
   * ```markdown
   * > | | a |
   *     ^
   *   | | - |
   *   | | b |
   * ```
   *
   * @type {State}
   */
  function headRowBefore(code) {
    effects.enter('tableHead');
    effects.enter('tableRow');
    return headRowStart(code)
  }

  /**
   * Before table head row, after whitespace.
   *
   * ```markdown
   * > | | a |
   *     ^
   *   | | - |
   *   | | b |
   * ```
   *
   * @type {State}
   */
  function headRowStart(code) {
    if (code === 124) {
      return headRowBreak(code)
    }

    // To do: micromark-js should let us parse our own whitespace in extensions,
    // like `markdown-rs`:
    //
    // ```js
    // // 4+ spaces.
    // if (markdownSpace(code)) {
    //   return nok(code)
    // }
    // ```

    seen = true;
    // Count the first character, that isn’t a pipe, double.
    sizeB += 1;
    return headRowBreak(code)
  }

  /**
   * At break in table head row.
   *
   * ```markdown
   * > | | a |
   *     ^
   *       ^
   *         ^
   *   | | - |
   *   | | b |
   * ```
   *
   * @type {State}
   */
  function headRowBreak(code) {
    if (code === null) {
      // Note: in `markdown-rs`, we need to reset, in `micromark-js` we don‘t.
      return nok(code)
    }
    if (markdownLineEnding(code)) {
      // If anything other than one pipe (ignoring whitespace) was used, it’s fine.
      if (sizeB > 1) {
        sizeB = 0;
        // To do: check if this works.
        // Feel free to interrupt:
        self.interrupt = true;
        effects.exit('tableRow');
        effects.enter('lineEnding');
        effects.consume(code);
        effects.exit('lineEnding');
        return headDelimiterStart
      }

      // Note: in `markdown-rs`, we need to reset, in `micromark-js` we don‘t.
      return nok(code)
    }
    if (markdownSpace(code)) {
      // To do: check if this is fine.
      // effects.attempt(State::Next(StateName::GfmTableHeadRowBreak), State::Nok)
      // State::Retry(space_or_tab(tokenizer))
      return factorySpace(effects, headRowBreak, 'whitespace')(code)
    }
    sizeB += 1;
    if (seen) {
      seen = false;
      // Header cell count.
      size += 1;
    }
    if (code === 124) {
      effects.enter('tableCellDivider');
      effects.consume(code);
      effects.exit('tableCellDivider');
      // Whether a delimiter was seen.
      seen = true;
      return headRowBreak
    }

    // Anything else is cell data.
    effects.enter('data');
    return headRowData(code)
  }

  /**
   * In table head row data.
   *
   * ```markdown
   * > | | a |
   *       ^
   *   | | - |
   *   | | b |
   * ```
   *
   * @type {State}
   */
  function headRowData(code) {
    if (code === null || code === 124 || markdownLineEndingOrSpace(code)) {
      effects.exit('data');
      return headRowBreak(code)
    }
    effects.consume(code);
    return code === 92 ? headRowEscape : headRowData
  }

  /**
   * In table head row escape.
   *
   * ```markdown
   * > | | a\-b |
   *         ^
   *   | | ---- |
   *   | | c    |
   * ```
   *
   * @type {State}
   */
  function headRowEscape(code) {
    if (code === 92 || code === 124) {
      effects.consume(code);
      return headRowData
    }
    return headRowData(code)
  }

  /**
   * Before delimiter row.
   *
   * ```markdown
   *   | | a |
   * > | | - |
   *     ^
   *   | | b |
   * ```
   *
   * @type {State}
   */
  function headDelimiterStart(code) {
    // Reset `interrupt`.
    self.interrupt = false;

    // Note: in `markdown-rs`, we need to handle piercing here too.
    if (self.parser.lazy[self.now().line]) {
      return nok(code)
    }
    effects.enter('tableDelimiterRow');
    // Track if we’ve seen a `:` or `|`.
    seen = false;
    if (markdownSpace(code)) {
      return factorySpace(
        effects,
        headDelimiterBefore,
        'linePrefix',
        self.parser.constructs.disable.null.includes('codeIndented')
          ? undefined
          : 4
      )(code)
    }
    return headDelimiterBefore(code)
  }

  /**
   * Before delimiter row, after optional whitespace.
   *
   * Reused when a `|` is found later, to parse another cell.
   *
   * ```markdown
   *   | | a |
   * > | | - |
   *     ^
   *   | | b |
   * ```
   *
   * @type {State}
   */
  function headDelimiterBefore(code) {
    if (code === 45 || code === 58) {
      return headDelimiterValueBefore(code)
    }
    if (code === 124) {
      seen = true;
      // If we start with a pipe, we open a cell marker.
      effects.enter('tableCellDivider');
      effects.consume(code);
      effects.exit('tableCellDivider');
      return headDelimiterCellBefore
    }

    // More whitespace / empty row not allowed at start.
    return headDelimiterNok(code)
  }

  /**
   * After `|`, before delimiter cell.
   *
   * ```markdown
   *   | | a |
   * > | | - |
   *      ^
   * ```
   *
   * @type {State}
   */
  function headDelimiterCellBefore(code) {
    if (markdownSpace(code)) {
      return factorySpace(effects, headDelimiterValueBefore, 'whitespace')(code)
    }
    return headDelimiterValueBefore(code)
  }

  /**
   * Before delimiter cell value.
   *
   * ```markdown
   *   | | a |
   * > | | - |
   *       ^
   * ```
   *
   * @type {State}
   */
  function headDelimiterValueBefore(code) {
    // Align: left.
    if (code === 58) {
      sizeB += 1;
      seen = true;
      effects.enter('tableDelimiterMarker');
      effects.consume(code);
      effects.exit('tableDelimiterMarker');
      return headDelimiterLeftAlignmentAfter
    }

    // Align: none.
    if (code === 45) {
      sizeB += 1;
      // To do: seems weird that this *isn’t* left aligned, but that state is used?
      return headDelimiterLeftAlignmentAfter(code)
    }
    if (code === null || markdownLineEnding(code)) {
      return headDelimiterCellAfter(code)
    }
    return headDelimiterNok(code)
  }

  /**
   * After delimiter cell left alignment marker.
   *
   * ```markdown
   *   | | a  |
   * > | | :- |
   *        ^
   * ```
   *
   * @type {State}
   */
  function headDelimiterLeftAlignmentAfter(code) {
    if (code === 45) {
      effects.enter('tableDelimiterFiller');
      return headDelimiterFiller(code)
    }

    // Anything else is not ok after the left-align colon.
    return headDelimiterNok(code)
  }

  /**
   * In delimiter cell filler.
   *
   * ```markdown
   *   | | a |
   * > | | - |
   *       ^
   * ```
   *
   * @type {State}
   */
  function headDelimiterFiller(code) {
    if (code === 45) {
      effects.consume(code);
      return headDelimiterFiller
    }

    // Align is `center` if it was `left`, `right` otherwise.
    if (code === 58) {
      seen = true;
      effects.exit('tableDelimiterFiller');
      effects.enter('tableDelimiterMarker');
      effects.consume(code);
      effects.exit('tableDelimiterMarker');
      return headDelimiterRightAlignmentAfter
    }
    effects.exit('tableDelimiterFiller');
    return headDelimiterRightAlignmentAfter(code)
  }

  /**
   * After delimiter cell right alignment marker.
   *
   * ```markdown
   *   | |  a |
   * > | | -: |
   *         ^
   * ```
   *
   * @type {State}
   */
  function headDelimiterRightAlignmentAfter(code) {
    if (markdownSpace(code)) {
      return factorySpace(effects, headDelimiterCellAfter, 'whitespace')(code)
    }
    return headDelimiterCellAfter(code)
  }

  /**
   * After delimiter cell.
   *
   * ```markdown
   *   | |  a |
   * > | | -: |
   *          ^
   * ```
   *
   * @type {State}
   */
  function headDelimiterCellAfter(code) {
    if (code === 124) {
      return headDelimiterBefore(code)
    }
    if (code === null || markdownLineEnding(code)) {
      // Exit when:
      // * there was no `:` or `|` at all (it’s a thematic break or setext
      //   underline instead)
      // * the header cell count is not the delimiter cell count
      if (!seen || size !== sizeB) {
        return headDelimiterNok(code)
      }

      // Note: in markdown-rs`, a reset is needed here.
      effects.exit('tableDelimiterRow');
      effects.exit('tableHead');
      // To do: in `markdown-rs`, resolvers need to be registered manually.
      // effects.register_resolver(ResolveName::GfmTable)
      return ok(code)
    }
    return headDelimiterNok(code)
  }

  /**
   * In delimiter row, at a disallowed byte.
   *
   * ```markdown
   *   | | a |
   * > | | x |
   *       ^
   * ```
   *
   * @type {State}
   */
  function headDelimiterNok(code) {
    // Note: in `markdown-rs`, we need to reset, in `micromark-js` we don‘t.
    return nok(code)
  }

  /**
   * Before table body row.
   *
   * ```markdown
   *   | | a |
   *   | | - |
   * > | | b |
   *     ^
   * ```
   *
   * @type {State}
   */
  function bodyRowStart(code) {
    // Note: in `markdown-rs` we need to manually take care of a prefix,
    // but in `micromark-js` that is done for us, so if we’re here, we’re
    // never at whitespace.
    effects.enter('tableRow');
    return bodyRowBreak(code)
  }

  /**
   * At break in table body row.
   *
   * ```markdown
   *   | | a |
   *   | | - |
   * > | | b |
   *     ^
   *       ^
   *         ^
   * ```
   *
   * @type {State}
   */
  function bodyRowBreak(code) {
    if (code === 124) {
      effects.enter('tableCellDivider');
      effects.consume(code);
      effects.exit('tableCellDivider');
      return bodyRowBreak
    }
    if (code === null || markdownLineEnding(code)) {
      effects.exit('tableRow');
      return ok(code)
    }
    if (markdownSpace(code)) {
      return factorySpace(effects, bodyRowBreak, 'whitespace')(code)
    }

    // Anything else is cell content.
    effects.enter('data');
    return bodyRowData(code)
  }

  /**
   * In table body row data.
   *
   * ```markdown
   *   | | a |
   *   | | - |
   * > | | b |
   *       ^
   * ```
   *
   * @type {State}
   */
  function bodyRowData(code) {
    if (code === null || code === 124 || markdownLineEndingOrSpace(code)) {
      effects.exit('data');
      return bodyRowBreak(code)
    }
    effects.consume(code);
    return code === 92 ? bodyRowEscape : bodyRowData
  }

  /**
   * In table body row escape.
   *
   * ```markdown
   *   | | a    |
   *   | | ---- |
   * > | | b\-c |
   *         ^
   * ```
   *
   * @type {State}
   */
  function bodyRowEscape(code) {
    if (code === 92 || code === 124) {
      effects.consume(code);
      return bodyRowData
    }
    return bodyRowData(code)
  }
}

/** @type {Resolver} */
// eslint-disable-next-line complexity
function resolveTable(events, context) {
  let index = -1;
  let inFirstCellAwaitingPipe = true;
  /** @type {RowKind} */
  let rowKind = 0;
  /** @type {Range} */
  let lastCell = [0, 0, 0, 0];
  /** @type {Range} */
  let cell = [0, 0, 0, 0];
  let afterHeadAwaitingFirstBodyRow = false;
  let lastTableEnd = 0;
  /** @type {Token | undefined} */
  let currentTable;
  /** @type {Token | undefined} */
  let currentBody;
  /** @type {Token | undefined} */
  let currentCell;
  const map = new EditMap();
  while (++index < events.length) {
    const event = events[index];
    const token = event[1];
    if (event[0] === 'enter') {
      // Start of head.
      if (token.type === 'tableHead') {
        afterHeadAwaitingFirstBodyRow = false;

        // Inject previous (body end and) table end.
        if (lastTableEnd !== 0) {
          flushTableEnd(map, context, lastTableEnd, currentTable, currentBody);
          currentBody = undefined;
          lastTableEnd = 0;
        }

        // Inject table start.
        currentTable = {
          type: 'table',
          start: Object.assign({}, token.start),
          // Note: correct end is set later.
          end: Object.assign({}, token.end)
        };
        map.add(index, 0, [['enter', currentTable, context]]);
      } else if (
        token.type === 'tableRow' ||
        token.type === 'tableDelimiterRow'
      ) {
        inFirstCellAwaitingPipe = true;
        currentCell = undefined;
        lastCell = [0, 0, 0, 0];
        cell = [0, index + 1, 0, 0];

        // Inject table body start.
        if (afterHeadAwaitingFirstBodyRow) {
          afterHeadAwaitingFirstBodyRow = false;
          currentBody = {
            type: 'tableBody',
            start: Object.assign({}, token.start),
            // Note: correct end is set later.
            end: Object.assign({}, token.end)
          };
          map.add(index, 0, [['enter', currentBody, context]]);
        }
        rowKind = token.type === 'tableDelimiterRow' ? 2 : currentBody ? 3 : 1;
      }
      // Cell data.
      else if (
        rowKind &&
        (token.type === 'data' ||
          token.type === 'tableDelimiterMarker' ||
          token.type === 'tableDelimiterFiller')
      ) {
        inFirstCellAwaitingPipe = false;

        // First value in cell.
        if (cell[2] === 0) {
          if (lastCell[1] !== 0) {
            cell[0] = cell[1];
            currentCell = flushCell(
              map,
              context,
              lastCell,
              rowKind,
              undefined,
              currentCell
            );
            lastCell = [0, 0, 0, 0];
          }
          cell[2] = index;
        }
      } else if (token.type === 'tableCellDivider') {
        if (inFirstCellAwaitingPipe) {
          inFirstCellAwaitingPipe = false;
        } else {
          if (lastCell[1] !== 0) {
            cell[0] = cell[1];
            currentCell = flushCell(
              map,
              context,
              lastCell,
              rowKind,
              undefined,
              currentCell
            );
          }
          lastCell = cell;
          cell = [lastCell[1], index, 0, 0];
        }
      }
    }
    // Exit events.
    else if (token.type === 'tableHead') {
      afterHeadAwaitingFirstBodyRow = true;
      lastTableEnd = index;
    } else if (
      token.type === 'tableRow' ||
      token.type === 'tableDelimiterRow'
    ) {
      lastTableEnd = index;
      if (lastCell[1] !== 0) {
        cell[0] = cell[1];
        currentCell = flushCell(
          map,
          context,
          lastCell,
          rowKind,
          index,
          currentCell
        );
      } else if (cell[1] !== 0) {
        currentCell = flushCell(map, context, cell, rowKind, index, currentCell);
      }
      rowKind = 0;
    } else if (
      rowKind &&
      (token.type === 'data' ||
        token.type === 'tableDelimiterMarker' ||
        token.type === 'tableDelimiterFiller')
    ) {
      cell[3] = index;
    }
  }
  if (lastTableEnd !== 0) {
    flushTableEnd(map, context, lastTableEnd, currentTable, currentBody);
  }
  map.consume(context.events);

  // To do: move this into `html`, when events are exposed there.
  // That’s what `markdown-rs` does.
  // That needs updates to `mdast-util-gfm-table`.
  index = -1;
  while (++index < context.events.length) {
    const event = context.events[index];
    if (event[0] === 'enter' && event[1].type === 'table') {
      event[1]._align = gfmTableAlign(context.events, index);
    }
  }
  return events
}

/// Generate a cell.
/**
 *
 * @param {EditMap} map
 * @param {TokenizeContext} context
 * @param {Range} range
 * @param {RowKind} rowKind
 * @param {number | undefined} rowEnd
 * @param {Token | undefined} previousCell
 * @returns {Token | undefined}
 */
// eslint-disable-next-line max-params
function flushCell(map, context, range, rowKind, rowEnd, previousCell) {
  // `markdown-rs` uses:
  // rowKind === 2 ? 'tableDelimiterCell' : 'tableCell'
  const groupName =
    rowKind === 1
      ? 'tableHeader'
      : rowKind === 2
      ? 'tableDelimiter'
      : 'tableData';
  // `markdown-rs` uses:
  // rowKind === 2 ? 'tableDelimiterCellValue' : 'tableCellText'
  const valueName = 'tableContent';

  // Insert an exit for the previous cell, if there is one.
  //
  // ```markdown
  // > | | aa | bb | cc |
  //          ^-- exit
  //           ^^^^-- this cell
  // ```
  if (range[0] !== 0) {
    previousCell.end = Object.assign({}, getPoint(context.events, range[0]));
    map.add(range[0], 0, [['exit', previousCell, context]]);
  }

  // Insert enter of this cell.
  //
  // ```markdown
  // > | | aa | bb | cc |
  //           ^-- enter
  //           ^^^^-- this cell
  // ```
  const now = getPoint(context.events, range[1]);
  previousCell = {
    type: groupName,
    start: Object.assign({}, now),
    // Note: correct end is set later.
    end: Object.assign({}, now)
  };
  map.add(range[1], 0, [['enter', previousCell, context]]);

  // Insert text start at first data start and end at last data end, and
  // remove events between.
  //
  // ```markdown
  // > | | aa | bb | cc |
  //            ^-- enter
  //             ^-- exit
  //           ^^^^-- this cell
  // ```
  if (range[2] !== 0) {
    const relatedStart = getPoint(context.events, range[2]);
    const relatedEnd = getPoint(context.events, range[3]);
    /** @type {Token} */
    const valueToken = {
      type: valueName,
      start: Object.assign({}, relatedStart),
      end: Object.assign({}, relatedEnd)
    };
    map.add(range[2], 0, [['enter', valueToken, context]]);
    if (rowKind !== 2) {
      // Fix positional info on remaining events
      const start = context.events[range[2]];
      const end = context.events[range[3]];
      start[1].end = Object.assign({}, end[1].end);
      start[1].type = 'chunkText';
      start[1].contentType = 'text';

      // Remove if needed.
      if (range[3] > range[2] + 1) {
        const a = range[2] + 1;
        const b = range[3] - range[2] - 1;
        map.add(a, b, []);
      }
    }
    map.add(range[3] + 1, 0, [['exit', valueToken, context]]);
  }

  // Insert an exit for the last cell, if at the row end.
  //
  // ```markdown
  // > | | aa | bb | cc |
  //                    ^-- exit
  //               ^^^^^^-- this cell (the last one contains two “between” parts)
  // ```
  if (rowEnd !== undefined) {
    previousCell.end = Object.assign({}, getPoint(context.events, rowEnd));
    map.add(rowEnd, 0, [['exit', previousCell, context]]);
    previousCell = undefined;
  }
  return previousCell
}

/**
 * Generate table end (and table body end).
 *
 * @param {EditMap} map
 * @param {TokenizeContext} context
 * @param {number} index
 * @param {Token} table
 * @param {Token | undefined} tableBody
 */
// eslint-disable-next-line max-params
function flushTableEnd(map, context, index, table, tableBody) {
  /** @type {Array<Event>} */
  const exits = [];
  const related = getPoint(context.events, index);
  if (tableBody) {
    tableBody.end = Object.assign({}, related);
    exits.push(['exit', tableBody, context]);
  }
  table.end = Object.assign({}, related);
  exits.push(['exit', table, context]);
  map.add(index + 1, 0, exits);
}

/**
 * @param {Array<Event>} events
 * @param {number} index
 * @returns {readonly Point}
 */
function getPoint(events, index) {
  const event = events[index];
  const side = event[0] === 'enter' ? 'start' : 'end';
  return event[1][side]
}

/**
 * @typedef {import('micromark-util-types').Extension} Extension
 * @typedef {import('micromark-util-types').State} State
 * @typedef {import('micromark-util-types').TokenizeContext} TokenizeContext
 * @typedef {import('micromark-util-types').Tokenizer} Tokenizer
 */

const tasklistCheck = {
  tokenize: tokenizeTasklistCheck
};

// To do: next major: expose function to make extension.

/**
 * Extension for `micromark` that can be passed in `extensions`, to
 * enable GFM task list items syntax.
 *
 * @type {Extension}
 */
const gfmTaskListItem = {
  text: {
    [91]: tasklistCheck
  }
};

/**
 * @this {TokenizeContext}
 * @type {Tokenizer}
 */
function tokenizeTasklistCheck(effects, ok, nok) {
  const self = this;
  return open

  /**
   * At start of task list item check.
   *
   * ```markdown
   * > | * [x] y.
   *       ^
   * ```
   *
   * @type {State}
   */
  function open(code) {
    if (
      // Exit if there’s stuff before.
      self.previous !== null ||
      // Exit if not in the first content that is the first child of a list
      // item.
      !self._gfmTasklistFirstContentOfListItem
    ) {
      return nok(code)
    }
    effects.enter('taskListCheck');
    effects.enter('taskListCheckMarker');
    effects.consume(code);
    effects.exit('taskListCheckMarker');
    return inside
  }

  /**
   * In task list item check.
   *
   * ```markdown
   * > | * [x] y.
   *        ^
   * ```
   *
   * @type {State}
   */
  function inside(code) {
    // Currently we match how GH works in files.
    // To match how GH works in comments, use `markdownSpace` (`[\t ]`) instead
    // of `markdownLineEndingOrSpace` (`[\t\n\r ]`).
    if (markdownLineEndingOrSpace(code)) {
      effects.enter('taskListCheckValueUnchecked');
      effects.consume(code);
      effects.exit('taskListCheckValueUnchecked');
      return close
    }
    if (code === 88 || code === 120) {
      effects.enter('taskListCheckValueChecked');
      effects.consume(code);
      effects.exit('taskListCheckValueChecked');
      return close
    }
    return nok(code)
  }

  /**
   * At close of task list item check.
   *
   * ```markdown
   * > | * [x] y.
   *         ^
   * ```
   *
   * @type {State}
   */
  function close(code) {
    if (code === 93) {
      effects.enter('taskListCheckMarker');
      effects.consume(code);
      effects.exit('taskListCheckMarker');
      effects.exit('taskListCheck');
      return after
    }
    return nok(code)
  }

  /**
   * @type {State}
   */
  function after(code) {
    // EOL in paragraph means there must be something else after it.
    if (markdownLineEnding(code)) {
      return ok(code)
    }

    // Space or tab?
    // Check what comes after.
    if (markdownSpace(code)) {
      return effects.check(
        {
          tokenize: spaceThenNonSpace
        },
        ok,
        nok
      )(code)
    }

    // EOF, or non-whitespace, both wrong.
    return nok(code)
  }
}

/**
 * @this {TokenizeContext}
 * @type {Tokenizer}
 */
function spaceThenNonSpace(effects, ok, nok) {
  return factorySpace(effects, after, 'whitespace')

  /**
   * After whitespace, after task list item check.
   *
   * ```markdown
   * > | * [x] y.
   *           ^
   * ```
   *
   * @type {State}
   */
  function after(code) {
    // EOF means there was nothing, so bad.
    // EOL means there’s content after it, so good.
    // Impossible to have more spaces.
    // Anything else is good.
    return code === null ? nok(code) : ok(code)
  }
}

/**
 * @typedef {import('micromark-extension-gfm-footnote').HtmlOptions} HtmlOptions
 * @typedef {import('micromark-extension-gfm-strikethrough').Options} Options
 * @typedef {import('micromark-util-types').Extension} Extension
 * @typedef {import('micromark-util-types').HtmlExtension} HtmlExtension
 */


/**
 * Create an extension for `micromark` to enable GFM syntax.
 *
 * @param {Options | null | undefined} [options]
 *   Configuration (optional).
 *
 *   Passed to `micromark-extens-gfm-strikethrough`.
 * @returns {Extension}
 *   Extension for `micromark` that can be passed in `extensions` to enable GFM
 *   syntax.
 */
function gfm(options) {
  return combineExtensions([
    gfmAutolinkLiteral,
    gfmFootnote(),
    gfmStrikethrough(options),
    gfmTable,
    gfmTaskListItem
  ])
}

/**
 * Count how often a character (or substring) is used in a string.
 *
 * @param {string} value
 *   Value to search in.
 * @param {string} character
 *   Character (or substring) to look for.
 * @return {number}
 *   Number of times `character` occurred in `value`.
 */
function ccount(value, character) {
  const source = String(value);

  if (typeof character !== 'string') {
    throw new TypeError('Expected character')
  }

  let count = 0;
  let index = source.indexOf(character);

  while (index !== -1) {
    count++;
    index = source.indexOf(character, index + character.length);
  }

  return count
}

function escapeStringRegexp(string) {
	if (typeof string !== 'string') {
		throw new TypeError('Expected a string');
	}

	// Escape characters with special meaning either inside or outside character sets.
	// Use a simple backslash escape when it’s always valid, and a `\xnn` escape when the simpler form would be disallowed by Unicode patterns’ stricter grammar.
	return string
		.replace(/[|\\{}()[\]^$+*?.]/g, '\\$&')
		.replace(/-/g, '\\x2d');
}

/**
 * @typedef {import('mdast').Parent} MdastParent
 * @typedef {import('mdast').Root} Root
 * @typedef {import('mdast').Content} Content
 * @typedef {import('mdast').PhrasingContent} PhrasingContent
 * @typedef {import('mdast').Text} Text
 * @typedef {import('unist-util-visit-parents').Test} Test
 * @typedef {import('unist-util-visit-parents').VisitorResult} VisitorResult
 */


const own = {}.hasOwnProperty;

/**
 * Find patterns in a tree and replace them.
 *
 * The algorithm searches the tree in *preorder* for complete values in `Text`
 * nodes.
 * Partial matches are not supported.
 *
 * @param tree
 *   Tree to change.
 * @param find
 *   Patterns to find.
 * @param replace
 *   Things to replace with (when `find` is `Find`) or configuration.
 * @param options
 *   Configuration (when `find` is not `Find`).
 * @returns
 *   Given, modified, tree.
 */
// To do: next major: remove `find` & `replace` combo, remove schema.
const findAndReplace =
  /**
   * @type {(
   *   (<Tree extends Node>(tree: Tree, find: Find, replace?: Replace | null | undefined, options?: Options | null | undefined) => Tree) &
   *   (<Tree extends Node>(tree: Tree, schema: FindAndReplaceSchema | FindAndReplaceList, options?: Options | null | undefined) => Tree)
   * )}
   **/
  (
    /**
     * @template {Node} Tree
     * @param {Tree} tree
     * @param {Find | FindAndReplaceSchema | FindAndReplaceList} find
     * @param {Replace | Options | null | undefined} [replace]
     * @param {Options | null | undefined} [options]
     * @returns {Tree}
     */
    function (tree, find, replace, options) {
      /** @type {Options | null | undefined} */
      let settings;
      /** @type {FindAndReplaceSchema|FindAndReplaceList} */
      let schema;

      if (typeof find === 'string' || find instanceof RegExp) {
        // @ts-expect-error don’t expect options twice.
        schema = [[find, replace]];
        settings = options;
      } else {
        schema = find;
        // @ts-expect-error don’t expect replace twice.
        settings = replace;
      }

      if (!settings) {
        settings = {};
      }

      const ignored = convert(settings.ignore || []);
      const pairs = toPairs(schema);
      let pairIndex = -1;

      while (++pairIndex < pairs.length) {
        visitParents(tree, 'text', visitor);
      }

      // To do next major: don’t return the given tree.
      return tree

      /** @type {import('unist-util-visit-parents/complex-types.js').BuildVisitor<Root, 'text'>} */
      function visitor(node, parents) {
        let index = -1;
        /** @type {Parent | undefined} */
        let grandparent;

        while (++index < parents.length) {
          const parent = parents[index];

          if (
            ignored(
              parent,
              // @ts-expect-error: TS doesn’t understand but it’s perfect.
              grandparent ? grandparent.children.indexOf(parent) : undefined,
              grandparent
            )
          ) {
            return
          }

          grandparent = parent;
        }

        if (grandparent) {
          return handler(node, parents)
        }
      }

      /**
       * Handle a text node which is not in an ignored parent.
       *
       * @param {Text} node
       *   Text node.
       * @param {Array<Parent>} parents
       *   Parents.
       * @returns {VisitorResult}
       *   Result.
       */
      function handler(node, parents) {
        const parent = parents[parents.length - 1];
        const find = pairs[pairIndex][0];
        const replace = pairs[pairIndex][1];
        let start = 0;
        // @ts-expect-error: TS is wrong, some of these children can be text.
        const index = parent.children.indexOf(node);
        let change = false;
        /** @type {Array<PhrasingContent>} */
        let nodes = [];

        find.lastIndex = 0;

        let match = find.exec(node.value);

        while (match) {
          const position = match.index;
          /** @type {RegExpMatchObject} */
          const matchObject = {
            index: match.index,
            input: match.input,
            // @ts-expect-error: stack is fine.
            stack: [...parents, node]
          };
          let value = replace(...match, matchObject);

          if (typeof value === 'string') {
            value = value.length > 0 ? {type: 'text', value} : undefined;
          }

          // It wasn’t a match after all.
          if (value !== false) {
            if (start !== position) {
              nodes.push({
                type: 'text',
                value: node.value.slice(start, position)
              });
            }

            if (Array.isArray(value)) {
              nodes.push(...value);
            } else if (value) {
              nodes.push(value);
            }

            start = position + match[0].length;
            change = true;
          }

          if (!find.global) {
            break
          }

          match = find.exec(node.value);
        }

        if (change) {
          if (start < node.value.length) {
            nodes.push({type: 'text', value: node.value.slice(start)});
          }

          parent.children.splice(index, 1, ...nodes);
        } else {
          nodes = [node];
        }

        return index + nodes.length
      }
    }
  );

/**
 * Turn a schema into pairs.
 *
 * @param {FindAndReplaceSchema | FindAndReplaceList} schema
 *   Schema.
 * @returns {Pairs}
 *   Clean pairs.
 */
function toPairs(schema) {
  /** @type {Pairs} */
  const result = [];

  if (typeof schema !== 'object') {
    throw new TypeError('Expected array or object as schema')
  }

  if (Array.isArray(schema)) {
    let index = -1;

    while (++index < schema.length) {
      result.push([
        toExpression(schema[index][0]),
        toFunction(schema[index][1])
      ]);
    }
  } else {
    /** @type {string} */
    let key;

    for (key in schema) {
      if (own.call(schema, key)) {
        result.push([toExpression(key), toFunction(schema[key])]);
      }
    }
  }

  return result
}

/**
 * Turn a find into an expression.
 *
 * @param {Find} find
 *   Find.
 * @returns {RegExp}
 *   Expression.
 */
function toExpression(find) {
  return typeof find === 'string' ? new RegExp(escapeStringRegexp(find), 'g') : find
}

/**
 * Turn a replace into a function.
 *
 * @param {Replace} replace
 *   Replace.
 * @returns {ReplaceFunction}
 *   Function.
 */
function toFunction(replace) {
  return typeof replace === 'function' ? replace : () => replace
}

/**
 * @typedef {import('mdast').Link} Link
 * @typedef {import('mdast').PhrasingContent} PhrasingContent
 *
 * @typedef {import('mdast-util-from-markdown').CompileContext} CompileContext
 * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension
 * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle
 * @typedef {import('mdast-util-from-markdown').Transform} FromMarkdownTransform
 *
 * @typedef {import('mdast-util-to-markdown').ConstructName} ConstructName
 * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension
 *
 * @typedef {import('mdast-util-find-and-replace').ReplaceFunction} ReplaceFunction
 * @typedef {import('mdast-util-find-and-replace').RegExpMatchObject} RegExpMatchObject
 */


/** @type {ConstructName} */
const inConstruct = 'phrasing';
/** @type {Array<ConstructName>} */
const notInConstruct = ['autolink', 'link', 'image', 'label'];

// To do: next major: expose functions instead of extensions.

/**
 * Extension for `mdast-util-from-markdown` to enable GFM autolink literals.
 *
 * @type {FromMarkdownExtension}
 */
const gfmAutolinkLiteralFromMarkdown = {
  transforms: [transformGfmAutolinkLiterals],
  enter: {
    literalAutolink: enterLiteralAutolink,
    literalAutolinkEmail: enterLiteralAutolinkValue,
    literalAutolinkHttp: enterLiteralAutolinkValue,
    literalAutolinkWww: enterLiteralAutolinkValue
  },
  exit: {
    literalAutolink: exitLiteralAutolink,
    literalAutolinkEmail: exitLiteralAutolinkEmail,
    literalAutolinkHttp: exitLiteralAutolinkHttp,
    literalAutolinkWww: exitLiteralAutolinkWww
  }
};

/**
 * Extension for `mdast-util-to-markdown` to enable GFM autolink literals.
 *
 * @type {ToMarkdownExtension}
 */
const gfmAutolinkLiteralToMarkdown = {
  unsafe: [
    {
      character: '@',
      before: '[+\\-.\\w]',
      after: '[\\-.\\w]',
      inConstruct,
      notInConstruct
    },
    {
      character: '.',
      before: '[Ww]',
      after: '[\\-.\\w]',
      inConstruct,
      notInConstruct
    },
    {character: ':', before: '[ps]', after: '\\/', inConstruct, notInConstruct}
  ]
};

/**
 * @this {CompileContext}
 * @type {FromMarkdownHandle}
 */
function enterLiteralAutolink(token) {
  this.enter({type: 'link', title: null, url: '', children: []}, token);
}

/**
 * @this {CompileContext}
 * @type {FromMarkdownHandle}
 */
function enterLiteralAutolinkValue(token) {
  this.config.enter.autolinkProtocol.call(this, token);
}

/**
 * @this {CompileContext}
 * @type {FromMarkdownHandle}
 */
function exitLiteralAutolinkHttp(token) {
  this.config.exit.autolinkProtocol.call(this, token);
}

/**
 * @this {CompileContext}
 * @type {FromMarkdownHandle}
 */
function exitLiteralAutolinkWww(token) {
  this.config.exit.data.call(this, token);
  const node = /** @type {Link} */ (this.stack[this.stack.length - 1]);
  node.url = 'http://' + this.sliceSerialize(token);
}

/**
 * @this {CompileContext}
 * @type {FromMarkdownHandle}
 */
function exitLiteralAutolinkEmail(token) {
  this.config.exit.autolinkEmail.call(this, token);
}

/**
 * @this {CompileContext}
 * @type {FromMarkdownHandle}
 */
function exitLiteralAutolink(token) {
  this.exit(token);
}

/** @type {FromMarkdownTransform} */
function transformGfmAutolinkLiterals(tree) {
  findAndReplace(
    tree,
    [
      [/(https?:\/\/|www(?=\.))([-.\w]+)([^ \t\r\n]*)/gi, findUrl],
      [/([-.\w+]+)@([-\w]+(?:\.[-\w]+)+)/g, findEmail]
    ],
    {ignore: ['link', 'linkReference']}
  );
}

/**
 * @type {ReplaceFunction}
 * @param {string} _
 * @param {string} protocol
 * @param {string} domain
 * @param {string} path
 * @param {RegExpMatchObject} match
 * @returns {Link | Array<PhrasingContent> | false}
 */
// eslint-disable-next-line max-params
function findUrl(_, protocol, domain, path, match) {
  let prefix = '';

  // Not an expected previous character.
  if (!previous(match)) {
    return false
  }

  // Treat `www` as part of the domain.
  if (/^w/i.test(protocol)) {
    domain = protocol + domain;
    protocol = '';
    prefix = 'http://';
  }

  if (!isCorrectDomain(domain)) {
    return false
  }

  const parts = splitUrl(domain + path);

  if (!parts[0]) return false

  /** @type {Link} */
  const result = {
    type: 'link',
    title: null,
    url: prefix + protocol + parts[0],
    children: [{type: 'text', value: protocol + parts[0]}]
  };

  if (parts[1]) {
    return [result, {type: 'text', value: parts[1]}]
  }

  return result
}

/**
 * @type {ReplaceFunction}
 * @param {string} _
 * @param {string} atext
 * @param {string} label
 * @param {RegExpMatchObject} match
 * @returns {Link | false}
 */
function findEmail(_, atext, label, match) {
  if (
    // Not an expected previous character.
    !previous(match, true) ||
    // Label ends in not allowed character.
    /[-\d_]$/.test(label)
  ) {
    return false
  }

  return {
    type: 'link',
    title: null,
    url: 'mailto:' + atext + '@' + label,
    children: [{type: 'text', value: atext + '@' + label}]
  }
}

/**
 * @param {string} domain
 * @returns {boolean}
 */
function isCorrectDomain(domain) {
  const parts = domain.split('.');

  if (
    parts.length < 2 ||
    (parts[parts.length - 1] &&
      (/_/.test(parts[parts.length - 1]) ||
        !/[a-zA-Z\d]/.test(parts[parts.length - 1]))) ||
    (parts[parts.length - 2] &&
      (/_/.test(parts[parts.length - 2]) ||
        !/[a-zA-Z\d]/.test(parts[parts.length - 2])))
  ) {
    return false
  }

  return true
}

/**
 * @param {string} url
 * @returns {[string, string | undefined]}
 */
function splitUrl(url) {
  const trailExec = /[!"&'),.:;<>?\]}]+$/.exec(url);

  if (!trailExec) {
    return [url, undefined]
  }

  url = url.slice(0, trailExec.index);

  let trail = trailExec[0];
  let closingParenIndex = trail.indexOf(')');
  const openingParens = ccount(url, '(');
  let closingParens = ccount(url, ')');

  while (closingParenIndex !== -1 && openingParens > closingParens) {
    url += trail.slice(0, closingParenIndex + 1);
    trail = trail.slice(closingParenIndex + 1);
    closingParenIndex = trail.indexOf(')');
    closingParens++;
  }

  return [url, trail]
}

/**
 * @param {RegExpMatchObject} match
 * @param {boolean | null | undefined} [email=false]
 * @returns {boolean}
 */
function previous(match, email) {
  const code = match.input.charCodeAt(match.index - 1);

  return (
    (match.index === 0 ||
      unicodeWhitespace(code) ||
      unicodePunctuation(code)) &&
    (!email || code !== 47)
  )
}

/**
 * @typedef {import('../types.js').AssociationId} AssociationId
 */


/**
 * Get an identifier from an association to match it to others.
 *
 * Associations are nodes that match to something else through an ID:
 * <https://github.com/syntax-tree/mdast#association>.
 *
 * The `label` of an association is the string value: character escapes and
 * references work, and casing is intact.
 * The `identifier` is used to match one association to another:
 * controversially, character escapes and references don’t work in this
 * matching: `&copy;` does not match `©`, and `\+` does not match `+`.
 *
 * But casing is ignored (and whitespace) is trimmed and collapsed: ` A\nb`
 * matches `a b`.
 * So, we do prefer the label when figuring out how we’re going to serialize:
 * it has whitespace, casing, and we can ignore most useless character
 * escapes and all character references.
 *
 * @type {AssociationId}
 */
function association(node) {
  if (node.label || !node.identifier) {
    return node.label || ''
  }

  return decodeString(node.identifier)
}

/**
 * @typedef {import('../types.js').FlowContent} FlowContent
 * @typedef {import('../types.js').Node} Node
 * @typedef {import('../types.js').Parent} Parent
 * @typedef {import('../types.js').State} State
 * @typedef {import('../types.js').TrackFields} TrackFields
 */

/**
 * @param {Parent & {children: Array<FlowContent>}} parent
 *   Parent of flow nodes.
 * @param {State} state
 *   Info passed around about the current state.
 * @param {TrackFields} info
 *   Info on where we are in the document we are generating.
 * @returns {string}
 *   Serialized children, joined by (blank) lines.
 */
function containerFlow(parent, state, info) {
  const indexStack = state.indexStack;
  const children = parent.children || [];
  const tracker = state.createTracker(info);
  /** @type {Array<string>} */
  const results = [];
  let index = -1;

  indexStack.push(-1);

  while (++index < children.length) {
    const child = children[index];

    indexStack[indexStack.length - 1] = index;

    results.push(
      tracker.move(
        state.handle(child, parent, state, {
          before: '\n',
          after: '\n',
          ...tracker.current()
        })
      )
    );

    if (child.type !== 'list') {
      state.bulletLastUsed = undefined;
    }

    if (index < children.length - 1) {
      results.push(
        tracker.move(between(child, children[index + 1], parent, state))
      );
    }
  }

  indexStack.pop();

  return results.join('')
}

/**
 * @param {Node} left
 * @param {Node} right
 * @param {Parent} parent
 * @param {State} state
 * @returns {string}
 */
function between(left, right, parent, state) {
  let index = state.join.length;

  while (index--) {
    const result = state.join[index](left, right, parent, state);

    if (result === true || result === 1) {
      break
    }

    if (typeof result === 'number') {
      return '\n'.repeat(1 + result)
    }

    if (result === false) {
      return '\n\n<!---->\n\n'
    }
  }

  return '\n\n'
}

/**
 * @typedef {import('../types.js').IndentLines} IndentLines
 */

const eol = /\r?\n|\r/g;

/**
 * @type {IndentLines}
 */
function indentLines(value, map) {
  /** @type {Array<string>} */
  const result = [];
  let start = 0;
  let line = 0;
  /** @type {RegExpExecArray | null} */
  let match;

  while ((match = eol.exec(value))) {
    one(value.slice(start, match.index));
    result.push(match[0]);
    start = match.index + match[0].length;
    line++;
  }

  one(value.slice(start));

  return result.join('')

  /**
   * @param {string} value
   */
  function one(value) {
    result.push(map(value, line, !value));
  }
}

/**
 * @typedef {import('../types.js').Unsafe} Unsafe
 */

/**
 * @param {Unsafe} pattern
 * @returns {RegExp}
 */
function patternCompile(pattern) {
  if (!pattern._compiled) {
    const before =
      (pattern.atBreak ? '[\\r\\n][\\t ]*' : '') +
      (pattern.before ? '(?:' + pattern.before + ')' : '');

    pattern._compiled = new RegExp(
      (before ? '(' + before + ')' : '') +
        (/[|\\{}()[\]^$+*?.-]/.test(pattern.character) ? '\\' : '') +
        pattern.character +
        (pattern.after ? '(?:' + pattern.after + ')' : ''),
      'g'
    );
  }

  return pattern._compiled
}

/**
 * @typedef {import('../types.js').Unsafe} Unsafe
 * @typedef {import('../types.js').ConstructName} ConstructName
 */

/**
 * @param {Array<ConstructName>} stack
 * @param {Unsafe} pattern
 * @returns {boolean}
 */
function patternInScope(stack, pattern) {
  return (
    listInScope(stack, pattern.inConstruct, true) &&
    !listInScope(stack, pattern.notInConstruct, false)
  )
}

/**
 * @param {Array<ConstructName>} stack
 * @param {Unsafe['inConstruct']} list
 * @param {boolean} none
 * @returns {boolean}
 */
function listInScope(stack, list, none) {
  if (typeof list === 'string') {
    list = [list];
  }

  if (!list || list.length === 0) {
    return none
  }

  let index = -1;

  while (++index < list.length) {
    if (stack.includes(list[index])) {
      return true
    }
  }

  return false
}

/**
 * @typedef {import('../types.js').State} State
 * @typedef {import('../types.js').SafeConfig} SafeConfig
 */


/**
 * Make a string safe for embedding in markdown constructs.
 *
 * In markdown, almost all punctuation characters can, in certain cases,
 * result in something.
 * Whether they do is highly subjective to where they happen and in what
 * they happen.
 *
 * To solve this, `mdast-util-to-markdown` tracks:
 *
 * * Characters before and after something;
 * * What “constructs” we are in.
 *
 * This information is then used by this function to escape or encode
 * special characters.
 *
 * @param {State} state
 *   Info passed around about the current state.
 * @param {string | null | undefined} input
 *   Raw value to make safe.
 * @param {SafeConfig} config
 *   Configuration.
 * @returns {string}
 *   Serialized markdown safe for embedding.
 */
function safe(state, input, config) {
  const value = (config.before || '') + (input || '') + (config.after || '');
  /** @type {Array<number>} */
  const positions = [];
  /** @type {Array<string>} */
  const result = [];
  /** @type {Record<number, {before: boolean, after: boolean}>} */
  const infos = {};
  let index = -1;

  while (++index < state.unsafe.length) {
    const pattern = state.unsafe[index];

    if (!patternInScope(state.stack, pattern)) {
      continue
    }

    const expression = patternCompile(pattern);
    /** @type {RegExpExecArray | null} */
    let match;

    while ((match = expression.exec(value))) {
      const before = 'before' in pattern || Boolean(pattern.atBreak);
      const after = 'after' in pattern;
      const position = match.index + (before ? match[1].length : 0);

      if (positions.includes(position)) {
        if (infos[position].before && !before) {
          infos[position].before = false;
        }

        if (infos[position].after && !after) {
          infos[position].after = false;
        }
      } else {
        positions.push(position);
        infos[position] = {before, after};
      }
    }
  }

  positions.sort(numerical);

  let start = config.before ? config.before.length : 0;
  const end = value.length - (config.after ? config.after.length : 0);
  index = -1;

  while (++index < positions.length) {
    const position = positions[index];

    // Character before or after matched:
    if (position < start || position >= end) {
      continue
    }

    // If this character is supposed to be escaped because it has a condition on
    // the next character, and the next character is definitly being escaped,
    // then skip this escape.
    if (
      (position + 1 < end &&
        positions[index + 1] === position + 1 &&
        infos[position].after &&
        !infos[position + 1].before &&
        !infos[position + 1].after) ||
      (positions[index - 1] === position - 1 &&
        infos[position].before &&
        !infos[position - 1].before &&
        !infos[position - 1].after)
    ) {
      continue
    }

    if (start !== position) {
      // If we have to use a character reference, an ampersand would be more
      // correct, but as backslashes only care about punctuation, either will
      // do the trick
      result.push(escapeBackslashes(value.slice(start, position), '\\'));
    }

    start = position;

    if (
      /[!-/:-@[-`{-~]/.test(value.charAt(position)) &&
      (!config.encode || !config.encode.includes(value.charAt(position)))
    ) {
      // Character escape.
      result.push('\\');
    } else {
      // Character reference.
      result.push(
        '&#x' + value.charCodeAt(position).toString(16).toUpperCase() + ';'
      );
      start++;
    }
  }

  result.push(escapeBackslashes(value.slice(start, end), config.after));

  return result.join('')
}

/**
 * @param {number} a
 * @param {number} b
 * @returns {number}
 */
function numerical(a, b) {
  return a - b
}

/**
 * @param {string} value
 * @param {string} after
 * @returns {string}
 */
function escapeBackslashes(value, after) {
  const expression = /\\(?=[!-/:-@[-`{-~])/g;
  /** @type {Array<number>} */
  const positions = [];
  /** @type {Array<string>} */
  const results = [];
  const whole = value + after;
  let index = -1;
  let start = 0;
  /** @type {RegExpExecArray | null} */
  let match;

  while ((match = expression.exec(whole))) {
    positions.push(match.index);
  }

  while (++index < positions.length) {
    if (start !== positions[index]) {
      results.push(value.slice(start, positions[index]));
    }

    results.push('\\');
    start = positions[index];
  }

  results.push(value.slice(start));

  return results.join('')
}

/**
 * @typedef {import('../types.js').CreateTracker} CreateTracker
 * @typedef {import('../types.js').TrackCurrent} TrackCurrent
 * @typedef {import('../types.js').TrackMove} TrackMove
 * @typedef {import('../types.js').TrackShift} TrackShift
 */

/**
 * Track positional info in the output.
 *
 * @type {CreateTracker}
 */
function track(config) {
  // Defaults are used to prevent crashes when older utilities somehow activate
  // this code.
  /* c8 ignore next 5 */
  const options = config || {};
  const now = options.now || {};
  let lineShift = options.lineShift || 0;
  let line = now.line || 1;
  let column = now.column || 1;

  return {move, current, shift}

  /**
   * Get the current tracked info.
   *
   * @type {TrackCurrent}
   */
  function current() {
    return {now: {line, column}, lineShift}
  }

  /**
   * Define an increased line shift (the typical indent for lines).
   *
   * @type {TrackShift}
   */
  function shift(value) {
    lineShift += value;
  }

  /**
   * Move past some generated markdown.
   *
   * @type {TrackMove}
   */
  function move(input) {
    // eslint-disable-next-line unicorn/prefer-default-parameters
    const value = input || '';
    const chunks = value.split(/\r?\n|\r/g);
    const tail = chunks[chunks.length - 1];
    line += chunks.length - 1;
    column =
      chunks.length === 1 ? column + tail.length : 1 + tail.length + lineShift;
    return value
  }
}

/**
 * @typedef {import('mdast').FootnoteReference} FootnoteReference
 * @typedef {import('mdast').FootnoteDefinition} FootnoteDefinition
 * @typedef {import('mdast-util-from-markdown').CompileContext} CompileContext
 * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension
 * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle
 * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension
 * @typedef {import('mdast-util-to-markdown').Handle} ToMarkdownHandle
 * @typedef {import('mdast-util-to-markdown').Map} Map
 */


footnoteReference.peek = footnoteReferencePeek;

// To do: next major: rename `context` -> `state`, `safeOptions` to `info`, use
// utilities on `state`.

/**
 * Create an extension for `mdast-util-from-markdown` to enable GFM footnotes
 * in markdown.
 *
 * @returns {FromMarkdownExtension}
 *   Extension for `mdast-util-from-markdown`.
 */
function gfmFootnoteFromMarkdown() {
  return {
    enter: {
      gfmFootnoteDefinition: enterFootnoteDefinition,
      gfmFootnoteDefinitionLabelString: enterFootnoteDefinitionLabelString,
      gfmFootnoteCall: enterFootnoteCall,
      gfmFootnoteCallString: enterFootnoteCallString
    },
    exit: {
      gfmFootnoteDefinition: exitFootnoteDefinition,
      gfmFootnoteDefinitionLabelString: exitFootnoteDefinitionLabelString,
      gfmFootnoteCall: exitFootnoteCall,
      gfmFootnoteCallString: exitFootnoteCallString
    }
  }
}

/**
 * Create an extension for `mdast-util-to-markdown` to enable GFM footnotes
 * in markdown.
 *
 * @returns {ToMarkdownExtension}
 *   Extension for `mdast-util-to-markdown`.
 */
function gfmFootnoteToMarkdown() {
  return {
    // This is on by default already.
    unsafe: [{character: '[', inConstruct: ['phrasing', 'label', 'reference']}],
    handlers: {footnoteDefinition, footnoteReference}
  }
}

/**
 * @this {CompileContext}
 * @type {FromMarkdownHandle}
 */
function enterFootnoteDefinition(token) {
  this.enter(
    {type: 'footnoteDefinition', identifier: '', label: '', children: []},
    token
  );
}

/**
 * @this {CompileContext}
 * @type {FromMarkdownHandle}
 */
function enterFootnoteDefinitionLabelString() {
  this.buffer();
}

/**
 * @this {CompileContext}
 * @type {FromMarkdownHandle}
 */
function exitFootnoteDefinitionLabelString(token) {
  const label = this.resume();
  const node = /** @type {FootnoteDefinition} */ (
    this.stack[this.stack.length - 1]
  );
  node.label = label;
  node.identifier = normalizeIdentifier(
    this.sliceSerialize(token)
  ).toLowerCase();
}

/**
 * @this {CompileContext}
 * @type {FromMarkdownHandle}
 */
function exitFootnoteDefinition(token) {
  this.exit(token);
}

/**
 * @this {CompileContext}
 * @type {FromMarkdownHandle}
 */
function enterFootnoteCall(token) {
  this.enter({type: 'footnoteReference', identifier: '', label: ''}, token);
}

/**
 * @this {CompileContext}
 * @type {FromMarkdownHandle}
 */
function enterFootnoteCallString() {
  this.buffer();
}

/**
 * @this {CompileContext}
 * @type {FromMarkdownHandle}
 */
function exitFootnoteCallString(token) {
  const label = this.resume();
  const node = /** @type {FootnoteDefinition} */ (
    this.stack[this.stack.length - 1]
  );
  node.label = label;
  node.identifier = normalizeIdentifier(
    this.sliceSerialize(token)
  ).toLowerCase();
}

/**
 * @this {CompileContext}
 * @type {FromMarkdownHandle}
 */
function exitFootnoteCall(token) {
  this.exit(token);
}

/**
 * @type {ToMarkdownHandle}
 * @param {FootnoteReference} node
 */
function footnoteReference(node, _, context, safeOptions) {
  const tracker = track(safeOptions);
  let value = tracker.move('[^');
  const exit = context.enter('footnoteReference');
  const subexit = context.enter('reference');
  value += tracker.move(
    safe(context, association(node), {
      ...tracker.current(),
      before: value,
      after: ']'
    })
  );
  subexit();
  exit();
  value += tracker.move(']');
  return value
}

/** @type {ToMarkdownHandle} */
function footnoteReferencePeek() {
  return '['
}

/**
 * @type {ToMarkdownHandle}
 * @param {FootnoteDefinition} node
 */
function footnoteDefinition(node, _, context, safeOptions) {
  const tracker = track(safeOptions);
  let value = tracker.move('[^');
  const exit = context.enter('footnoteDefinition');
  const subexit = context.enter('label');
  value += tracker.move(
    safe(context, association(node), {
      ...tracker.current(),
      before: value,
      after: ']'
    })
  );
  subexit();
  value += tracker.move(
    ']:' + (node.children && node.children.length > 0 ? ' ' : '')
  );
  tracker.shift(4);
  value += tracker.move(
    indentLines(containerFlow(node, context, tracker.current()), map)
  );
  exit();

  return value
}

/** @type {Map} */
function map(line, index, blank) {
  if (index === 0) {
    return line
  }

  return (blank ? '' : '    ') + line
}

/**
 * @typedef {import('../types.js').Handle} Handle
 * @typedef {import('../types.js').Info} Info
 * @typedef {import('../types.js').Parent} Parent
 * @typedef {import('../types.js').PhrasingContent} PhrasingContent
 * @typedef {import('../types.js').State} State
 */

/**
 * Serialize the children of a parent that contains phrasing children.
 *
 * These children will be joined flush together.
 *
 * @param {Parent & {children: Array<PhrasingContent>}} parent
 *   Parent of flow nodes.
 * @param {State} state
 *   Info passed around about the current state.
 * @param {Info} info
 *   Info on where we are in the document we are generating.
 * @returns {string}
 *   Serialized children, joined together.
 */
function containerPhrasing(parent, state, info) {
  const indexStack = state.indexStack;
  const children = parent.children || [];
  /** @type {Array<string>} */
  const results = [];
  let index = -1;
  let before = info.before;

  indexStack.push(-1);
  let tracker = state.createTracker(info);

  while (++index < children.length) {
    const child = children[index];
    /** @type {string} */
    let after;

    indexStack[indexStack.length - 1] = index;

    if (index + 1 < children.length) {
      /** @type {Handle} */
      // @ts-expect-error: hush, it’s actually a `zwitch`.
      let handle = state.handle.handlers[children[index + 1].type];
      /** @type {Handle} */
      // @ts-expect-error: hush, it’s actually a `zwitch`.
      if (handle && handle.peek) handle = handle.peek;
      after = handle
        ? handle(children[index + 1], parent, state, {
            before: '',
            after: '',
            ...tracker.current()
          }).charAt(0)
        : '';
    } else {
      after = info.after;
    }

    // In some cases, html (text) can be found in phrasing right after an eol.
    // When we’d serialize that, in most cases that would be seen as html
    // (flow).
    // As we can’t escape or so to prevent it from happening, we take a somewhat
    // reasonable approach: replace that eol with a space.
    // See: <https://github.com/syntax-tree/mdast-util-to-markdown/issues/15>
    if (
      results.length > 0 &&
      (before === '\r' || before === '\n') &&
      child.type === 'html'
    ) {
      results[results.length - 1] = results[results.length - 1].replace(
        /(\r?\n|\r)$/,
        ' '
      );
      before = ' ';

      // To do: does this work to reset tracker?
      tracker = state.createTracker(info);
      tracker.move(results.join(''));
    }

    results.push(
      tracker.move(
        state.handle(child, parent, state, {
          ...tracker.current(),
          before,
          after
        })
      )
    );

    before = results[results.length - 1].slice(-1);
  }

  indexStack.pop();

  return results.join('')
}

/**
 * @typedef {import('mdast').Delete} Delete
 *
 * @typedef {import('mdast-util-from-markdown').CompileContext} CompileContext
 * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension
 * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle
 *
 * @typedef {import('mdast-util-to-markdown').ConstructName} ConstructName
 * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension
 * @typedef {import('mdast-util-to-markdown').Handle} ToMarkdownHandle
 */


// To do: next major: expose functions.
// To do: next major: use `state`, state utilities.

/**
 * List of constructs that occur in phrasing (paragraphs, headings), but cannot
 * contain strikethrough.
 * So they sort of cancel each other out.
 * Note: could use a better name.
 *
 * Note: keep in sync with: <https://github.com/syntax-tree/mdast-util-to-markdown/blob/8ce8dbf/lib/unsafe.js#L14>
 *
 * @type {Array<ConstructName>}
 */
const constructsWithoutStrikethrough = [
  'autolink',
  'destinationLiteral',
  'destinationRaw',
  'reference',
  'titleQuote',
  'titleApostrophe'
];

handleDelete.peek = peekDelete;

/**
 * Extension for `mdast-util-from-markdown` to enable GFM strikethrough.
 *
 * @type {FromMarkdownExtension}
 */
const gfmStrikethroughFromMarkdown = {
  canContainEols: ['delete'],
  enter: {strikethrough: enterStrikethrough},
  exit: {strikethrough: exitStrikethrough}
};

/**
 * Extension for `mdast-util-to-markdown` to enable GFM strikethrough.
 *
 * @type {ToMarkdownExtension}
 */
const gfmStrikethroughToMarkdown = {
  unsafe: [
    {
      character: '~',
      inConstruct: 'phrasing',
      notInConstruct: constructsWithoutStrikethrough
    }
  ],
  handlers: {delete: handleDelete}
};

/**
 * @this {CompileContext}
 * @type {FromMarkdownHandle}
 */
function enterStrikethrough(token) {
  this.enter({type: 'delete', children: []}, token);
}

/**
 * @this {CompileContext}
 * @type {FromMarkdownHandle}
 */
function exitStrikethrough(token) {
  this.exit(token);
}

/**
 * @type {ToMarkdownHandle}
 * @param {Delete} node
 */
function handleDelete(node, _, context, safeOptions) {
  const tracker = track(safeOptions);
  const exit = context.enter('strikethrough');
  let value = tracker.move('~~');
  value += containerPhrasing(node, context, {
    ...tracker.current(),
    before: value,
    after: '~'
  });
  value += tracker.move('~~');
  exit();
  return value
}

/** @type {ToMarkdownHandle} */
function peekDelete() {
  return '~'
}

/**
 * @typedef {import('mdast').InlineCode} InlineCode
 * @typedef {import('../types.js').Parent} Parent
 * @typedef {import('../types.js').State} State
 */


inlineCode.peek = inlineCodePeek;

/**
 * @param {InlineCode} node
 * @param {Parent | undefined} _
 * @param {State} state
 * @returns {string}
 */
function inlineCode(node, _, state) {
  let value = node.value || '';
  let sequence = '`';
  let index = -1;

  // If there is a single grave accent on its own in the code, use a fence of
  // two.
  // If there are two in a row, use one.
  while (new RegExp('(^|[^`])' + sequence + '([^`]|$)').test(value)) {
    sequence += '`';
  }

  // If this is not just spaces or eols (tabs don’t count), and either the
  // first or last character are a space, eol, or tick, then pad with spaces.
  if (
    /[^ \r\n]/.test(value) &&
    ((/^[ \r\n]/.test(value) && /[ \r\n]$/.test(value)) || /^`|`$/.test(value))
  ) {
    value = ' ' + value + ' ';
  }

  // We have a potential problem: certain characters after eols could result in
  // blocks being seen.
  // For example, if someone injected the string `'\n# b'`, then that would
  // result in an ATX heading.
  // We can’t escape characters in `inlineCode`, but because eols are
  // transformed to spaces when going from markdown to HTML anyway, we can swap
  // them out.
  while (++index < state.unsafe.length) {
    const pattern = state.unsafe[index];
    const expression = patternCompile(pattern);
    /** @type {RegExpExecArray | null} */
    let match;

    // Only look for `atBreak`s.
    // Btw: note that `atBreak` patterns will always start the regex at LF or
    // CR.
    if (!pattern.atBreak) continue

    while ((match = expression.exec(value))) {
      let position = match.index;

      // Support CRLF (patterns only look for one of the characters).
      if (
        value.charCodeAt(position) === 10 /* `\n` */ &&
        value.charCodeAt(position - 1) === 13 /* `\r` */
      ) {
        position--;
      }

      value = value.slice(0, position) + ' ' + value.slice(match.index + 1);
    }
  }

  return sequence + value + sequence
}

/**
 * @returns {string}
 */
function inlineCodePeek() {
  return '`'
}

/**
 * @typedef Options
 *   Configuration (optional).
 * @property {string|null|ReadonlyArray<string|null|undefined>} [align]
 *   One style for all columns, or styles for their respective columns.
 *   Each style is either `'l'` (left), `'r'` (right), or `'c'` (center).
 *   Other values are treated as `''`, which doesn’t place the colon in the
 *   alignment row but does align left.
 *   *Only the lowercased first character is used, so `Right` is fine.*
 * @property {boolean} [padding=true]
 *   Whether to add a space of padding between delimiters and cells.
 *
 *   When `true`, there is padding:
 *
 *   ```markdown
 *   | Alpha | B     |
 *   | ----- | ----- |
 *   | C     | Delta |
 *   ```
 *
 *   When `false`, there is no padding:
 *
 *   ```markdown
 *   |Alpha|B    |
 *   |-----|-----|
 *   |C    |Delta|
 *   ```
 * @property {boolean} [delimiterStart=true]
 *   Whether to begin each row with the delimiter.
 *
 *   > 👉 **Note**: please don’t use this: it could create fragile structures
 *   > that aren’t understandable to some markdown parsers.
 *
 *   When `true`, there are starting delimiters:
 *
 *   ```markdown
 *   | Alpha | B     |
 *   | ----- | ----- |
 *   | C     | Delta |
 *   ```
 *
 *   When `false`, there are no starting delimiters:
 *
 *   ```markdown
 *   Alpha | B     |
 *   ----- | ----- |
 *   C     | Delta |
 *   ```
 * @property {boolean} [delimiterEnd=true]
 *   Whether to end each row with the delimiter.
 *
 *   > 👉 **Note**: please don’t use this: it could create fragile structures
 *   > that aren’t understandable to some markdown parsers.
 *
 *   When `true`, there are ending delimiters:
 *
 *   ```markdown
 *   | Alpha | B     |
 *   | ----- | ----- |
 *   | C     | Delta |
 *   ```
 *
 *   When `false`, there are no ending delimiters:
 *
 *   ```markdown
 *   | Alpha | B
 *   | ----- | -----
 *   | C     | Delta
 *   ```
 * @property {boolean} [alignDelimiters=true]
 *   Whether to align the delimiters.
 *   By default, they are aligned:
 *
 *   ```markdown
 *   | Alpha | B     |
 *   | ----- | ----- |
 *   | C     | Delta |
 *   ```
 *
 *   Pass `false` to make them staggered:
 *
 *   ```markdown
 *   | Alpha | B |
 *   | - | - |
 *   | C | Delta |
 *   ```
 * @property {(value: string) => number} [stringLength]
 *   Function to detect the length of table cell content.
 *   This is used when aligning the delimiters (`|`) between table cells.
 *   Full-width characters and emoji mess up delimiter alignment when viewing
 *   the markdown source.
 *   To fix this, you can pass this function, which receives the cell content
 *   and returns its “visible” size.
 *   Note that what is and isn’t visible depends on where the text is displayed.
 *
 *   Without such a function, the following:
 *
 *   ```js
 *   markdownTable([
 *     ['Alpha', 'Bravo'],
 *     ['中文', 'Charlie'],
 *     ['👩‍❤️‍👩', 'Delta']
 *   ])
 *   ```
 *
 *   Yields:
 *
 *   ```markdown
 *   | Alpha | Bravo |
 *   | - | - |
 *   | 中文 | Charlie |
 *   | 👩‍❤️‍👩 | Delta |
 *   ```
 *
 *   With [`string-width`](https://github.com/sindresorhus/string-width):
 *
 *   ```js
 *   import stringWidth from 'string-width'
 *
 *   markdownTable(
 *     [
 *       ['Alpha', 'Bravo'],
 *       ['中文', 'Charlie'],
 *       ['👩‍❤️‍👩', 'Delta']
 *     ],
 *     {stringLength: stringWidth}
 *   )
 *   ```
 *
 *   Yields:
 *
 *   ```markdown
 *   | Alpha | Bravo   |
 *   | ----- | ------- |
 *   | 中文  | Charlie |
 *   | 👩‍❤️‍👩    | Delta   |
 *   ```
 */

/**
 * @typedef {Options} MarkdownTableOptions
 * @todo
 *   Remove next major.
 */

/**
 * Generate a markdown ([GFM](https://docs.github.com/en/github/writing-on-github/working-with-advanced-formatting/organizing-information-with-tables)) table..
 *
 * @param {ReadonlyArray<ReadonlyArray<string|null|undefined>>} table
 *   Table data (matrix of strings).
 * @param {Options} [options]
 *   Configuration (optional).
 * @returns {string}
 */
function markdownTable(table, options = {}) {
  const align = (options.align || []).concat();
  const stringLength = options.stringLength || defaultStringLength;
  /** @type {Array<number>} Character codes as symbols for alignment per column. */
  const alignments = [];
  /** @type {Array<Array<string>>} Cells per row. */
  const cellMatrix = [];
  /** @type {Array<Array<number>>} Sizes of each cell per row. */
  const sizeMatrix = [];
  /** @type {Array<number>} */
  const longestCellByColumn = [];
  let mostCellsPerRow = 0;
  let rowIndex = -1;

  // This is a superfluous loop if we don’t align delimiters, but otherwise we’d
  // do superfluous work when aligning, so optimize for aligning.
  while (++rowIndex < table.length) {
    /** @type {Array<string>} */
    const row = [];
    /** @type {Array<number>} */
    const sizes = [];
    let columnIndex = -1;

    if (table[rowIndex].length > mostCellsPerRow) {
      mostCellsPerRow = table[rowIndex].length;
    }

    while (++columnIndex < table[rowIndex].length) {
      const cell = serialize(table[rowIndex][columnIndex]);

      if (options.alignDelimiters !== false) {
        const size = stringLength(cell);
        sizes[columnIndex] = size;

        if (
          longestCellByColumn[columnIndex] === undefined ||
          size > longestCellByColumn[columnIndex]
        ) {
          longestCellByColumn[columnIndex] = size;
        }
      }

      row.push(cell);
    }

    cellMatrix[rowIndex] = row;
    sizeMatrix[rowIndex] = sizes;
  }

  // Figure out which alignments to use.
  let columnIndex = -1;

  if (typeof align === 'object' && 'length' in align) {
    while (++columnIndex < mostCellsPerRow) {
      alignments[columnIndex] = toAlignment(align[columnIndex]);
    }
  } else {
    const code = toAlignment(align);

    while (++columnIndex < mostCellsPerRow) {
      alignments[columnIndex] = code;
    }
  }

  // Inject the alignment row.
  columnIndex = -1;
  /** @type {Array<string>} */
  const row = [];
  /** @type {Array<number>} */
  const sizes = [];

  while (++columnIndex < mostCellsPerRow) {
    const code = alignments[columnIndex];
    let before = '';
    let after = '';

    if (code === 99 /* `c` */) {
      before = ':';
      after = ':';
    } else if (code === 108 /* `l` */) {
      before = ':';
    } else if (code === 114 /* `r` */) {
      after = ':';
    }

    // There *must* be at least one hyphen-minus in each alignment cell.
    let size =
      options.alignDelimiters === false
        ? 1
        : Math.max(
            1,
            longestCellByColumn[columnIndex] - before.length - after.length
          );

    const cell = before + '-'.repeat(size) + after;

    if (options.alignDelimiters !== false) {
      size = before.length + size + after.length;

      if (size > longestCellByColumn[columnIndex]) {
        longestCellByColumn[columnIndex] = size;
      }

      sizes[columnIndex] = size;
    }

    row[columnIndex] = cell;
  }

  // Inject the alignment row.
  cellMatrix.splice(1, 0, row);
  sizeMatrix.splice(1, 0, sizes);

  rowIndex = -1;
  /** @type {Array<string>} */
  const lines = [];

  while (++rowIndex < cellMatrix.length) {
    const row = cellMatrix[rowIndex];
    const sizes = sizeMatrix[rowIndex];
    columnIndex = -1;
    /** @type {Array<string>} */
    const line = [];

    while (++columnIndex < mostCellsPerRow) {
      const cell = row[columnIndex] || '';
      let before = '';
      let after = '';

      if (options.alignDelimiters !== false) {
        const size =
          longestCellByColumn[columnIndex] - (sizes[columnIndex] || 0);
        const code = alignments[columnIndex];

        if (code === 114 /* `r` */) {
          before = ' '.repeat(size);
        } else if (code === 99 /* `c` */) {
          if (size % 2) {
            before = ' '.repeat(size / 2 + 0.5);
            after = ' '.repeat(size / 2 - 0.5);
          } else {
            before = ' '.repeat(size / 2);
            after = before;
          }
        } else {
          after = ' '.repeat(size);
        }
      }

      if (options.delimiterStart !== false && !columnIndex) {
        line.push('|');
      }

      if (
        options.padding !== false &&
        // Don’t add the opening space if we’re not aligning and the cell is
        // empty: there will be a closing space.
        !(options.alignDelimiters === false && cell === '') &&
        (options.delimiterStart !== false || columnIndex)
      ) {
        line.push(' ');
      }

      if (options.alignDelimiters !== false) {
        line.push(before);
      }

      line.push(cell);

      if (options.alignDelimiters !== false) {
        line.push(after);
      }

      if (options.padding !== false) {
        line.push(' ');
      }

      if (
        options.delimiterEnd !== false ||
        columnIndex !== mostCellsPerRow - 1
      ) {
        line.push('|');
      }
    }

    lines.push(
      options.delimiterEnd === false
        ? line.join('').replace(/ +$/, '')
        : line.join('')
    );
  }

  return lines.join('\n')
}

/**
 * @param {string|null|undefined} [value]
 * @returns {string}
 */
function serialize(value) {
  return value === null || value === undefined ? '' : String(value)
}

/**
 * @param {string} value
 * @returns {number}
 */
function defaultStringLength(value) {
  return value.length
}

/**
 * @param {string|null|undefined} value
 * @returns {number}
 */
function toAlignment(value) {
  const code = typeof value === 'string' ? value.codePointAt(0) : 0;

  return code === 67 /* `C` */ || code === 99 /* `c` */
    ? 99 /* `c` */
    : code === 76 /* `L` */ || code === 108 /* `l` */
    ? 108 /* `l` */
    : code === 82 /* `R` */ || code === 114 /* `r` */
    ? 114 /* `r` */
    : 0
}

/**
 * @typedef {import('mdast').Table} Table
 * @typedef {import('mdast').TableRow} TableRow
 * @typedef {import('mdast').TableCell} TableCell
 * @typedef {import('mdast').InlineCode} InlineCode
 *
 * @typedef {import('markdown-table').MarkdownTableOptions} MarkdownTableOptions
 *
 * @typedef {import('mdast-util-from-markdown').CompileContext} CompileContext
 * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension
 * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle
 *
 * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension
 * @typedef {import('mdast-util-to-markdown').Handle} ToMarkdownHandle
 * @typedef {import('mdast-util-to-markdown').Context} ToMarkdownContext
 * @typedef {import('mdast-util-to-markdown').SafeOptions} SafeOptions
 */


// To do: next major: use `state` and `state` utilities from `mdast-util-to-markdown`.
// To do: next major: use `defaultHandlers.inlineCode`.
// To do: next major: expose functions.

/**
 * Extension for `mdast-util-from-markdown` to enable GFM tables.
 *
 * @type {FromMarkdownExtension}
 */
const gfmTableFromMarkdown = {
  enter: {
    table: enterTable,
    tableData: enterCell,
    tableHeader: enterCell,
    tableRow: enterRow
  },
  exit: {
    codeText: exitCodeText,
    table: exitTable,
    tableData: exit,
    tableHeader: exit,
    tableRow: exit
  }
};

/**
 * @this {CompileContext}
 * @type {FromMarkdownHandle}
 */
function enterTable(token) {
  /** @type {Array<'left' | 'right' | 'center' | 'none'>} */
  // @ts-expect-error: `align` is custom.
  const align = token._align;
  this.enter(
    {
      type: 'table',
      align: align.map((d) => (d === 'none' ? null : d)),
      children: []
    },
    token
  );
  this.setData('inTable', true);
}

/**
 * @this {CompileContext}
 * @type {FromMarkdownHandle}
 */
function exitTable(token) {
  this.exit(token);
  this.setData('inTable');
}

/**
 * @this {CompileContext}
 * @type {FromMarkdownHandle}
 */
function enterRow(token) {
  this.enter({type: 'tableRow', children: []}, token);
}

/**
 * @this {CompileContext}
 * @type {FromMarkdownHandle}
 */
function exit(token) {
  this.exit(token);
}

/**
 * @this {CompileContext}
 * @type {FromMarkdownHandle}
 */
function enterCell(token) {
  this.enter({type: 'tableCell', children: []}, token);
}

// Overwrite the default code text data handler to unescape escaped pipes when
// they are in tables.
/**
 * @this {CompileContext}
 * @type {FromMarkdownHandle}
 */
function exitCodeText(token) {
  let value = this.resume();

  if (this.getData('inTable')) {
    value = value.replace(/\\([\\|])/g, replace);
  }

  const node = /** @type {InlineCode} */ (this.stack[this.stack.length - 1]);
  node.value = value;
  this.exit(token);
}

/**
 * @param {string} $0
 * @param {string} $1
 * @returns {string}
 */
function replace($0, $1) {
  // Pipes work, backslashes don’t (but can’t escape pipes).
  return $1 === '|' ? $1 : $0
}

/**
 * Create an extension for `mdast-util-to-markdown` to enable GFM tables in
 * markdown.
 *
 * @param {Options | null | undefined} [options]
 *   Configuration.
 * @returns {ToMarkdownExtension}
 *   Extension for `mdast-util-to-markdown` to enable GFM tables.
 */
function gfmTableToMarkdown(options) {
  const settings = options || {};
  const padding = settings.tableCellPadding;
  const alignDelimiters = settings.tablePipeAlign;
  const stringLength = settings.stringLength;
  const around = padding ? ' ' : '|';

  return {
    unsafe: [
      {character: '\r', inConstruct: 'tableCell'},
      {character: '\n', inConstruct: 'tableCell'},
      // A pipe, when followed by a tab or space (padding), or a dash or colon
      // (unpadded delimiter row), could result in a table.
      {atBreak: true, character: '|', after: '[\t :-]'},
      // A pipe in a cell must be encoded.
      {character: '|', inConstruct: 'tableCell'},
      // A colon must be followed by a dash, in which case it could start a
      // delimiter row.
      {atBreak: true, character: ':', after: '-'},
      // A delimiter row can also start with a dash, when followed by more
      // dashes, a colon, or a pipe.
      // This is a stricter version than the built in check for lists, thematic
      // breaks, and setex heading underlines though:
      // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/51a2038/lib/unsafe.js#L57>
      {atBreak: true, character: '-', after: '[:|-]'}
    ],
    handlers: {
      table: handleTable,
      tableRow: handleTableRow,
      tableCell: handleTableCell,
      inlineCode: inlineCodeWithTable
    }
  }

  /**
   * @type {ToMarkdownHandle}
   * @param {Table} node
   */
  function handleTable(node, _, context, safeOptions) {
    return serializeData(
      handleTableAsData(node, context, safeOptions),
      node.align
    )
  }

  /**
   * This function isn’t really used normally, because we handle rows at the
   * table level.
   * But, if someone passes in a table row, this ensures we make somewhat sense.
   *
   * @type {ToMarkdownHandle}
   * @param {TableRow} node
   */
  function handleTableRow(node, _, context, safeOptions) {
    const row = handleTableRowAsData(node, context, safeOptions);
    const value = serializeData([row]);
    // `markdown-table` will always add an align row
    return value.slice(0, value.indexOf('\n'))
  }

  /**
   * @type {ToMarkdownHandle}
   * @param {TableCell} node
   */
  function handleTableCell(node, _, context, safeOptions) {
    const exit = context.enter('tableCell');
    const subexit = context.enter('phrasing');
    const value = containerPhrasing(node, context, {
      ...safeOptions,
      before: around,
      after: around
    });
    subexit();
    exit();
    return value
  }

  /**
   * @param {Array<Array<string>>} matrix
   * @param {Array<string | null | undefined> | null | undefined} [align]
   */
  function serializeData(matrix, align) {
    return markdownTable(matrix, {
      align,
      // @ts-expect-error: `markdown-table` types should support `null`.
      alignDelimiters,
      // @ts-expect-error: `markdown-table` types should support `null`.
      padding,
      // @ts-expect-error: `markdown-table` types should support `null`.
      stringLength
    })
  }

  /**
   * @param {Table} node
   * @param {ToMarkdownContext} context
   * @param {SafeOptions} safeOptions
   */
  function handleTableAsData(node, context, safeOptions) {
    const children = node.children;
    let index = -1;
    /** @type {Array<Array<string>>} */
    const result = [];
    const subexit = context.enter('table');

    while (++index < children.length) {
      result[index] = handleTableRowAsData(
        children[index],
        context,
        safeOptions
      );
    }

    subexit();

    return result
  }

  /**
   * @param {TableRow} node
   * @param {ToMarkdownContext} context
   * @param {SafeOptions} safeOptions
   */
  function handleTableRowAsData(node, context, safeOptions) {
    const children = node.children;
    let index = -1;
    /** @type {Array<string>} */
    const result = [];
    const subexit = context.enter('tableRow');

    while (++index < children.length) {
      // Note: the positional info as used here is incorrect.
      // Making it correct would be impossible due to aligning cells?
      // And it would need copy/pasting `markdown-table` into this project.
      result[index] = handleTableCell(
        children[index],
        node,
        context,
        safeOptions
      );
    }

    subexit();

    return result
  }

  /**
   * @type {ToMarkdownHandle}
   * @param {InlineCode} node
   */
  function inlineCodeWithTable(node, parent, context) {
    let value = inlineCode(node, parent, context);

    if (context.stack.includes('tableCell')) {
      value = value.replace(/\|/g, '\\$&');
    }

    return value
  }
}

/**
 * @typedef {import('../types.js').State} State
 * @typedef {import('../types.js').Options} Options
 */

/**
 * @param {State} state
 * @returns {Exclude<Options['bullet'], null | undefined>}
 */
function checkBullet(state) {
  const marker = state.options.bullet || '*';

  if (marker !== '*' && marker !== '+' && marker !== '-') {
    throw new Error(
      'Cannot serialize items with `' +
        marker +
        '` for `options.bullet`, expected `*`, `+`, or `-`'
    )
  }

  return marker
}

/**
 * @typedef {import('../types.js').State} State
 * @typedef {import('../types.js').Options} Options
 */

/**
 * @param {State} state
 * @returns {Exclude<Options['listItemIndent'], null | undefined>}
 */
function checkListItemIndent(state) {
  const style = state.options.listItemIndent || 'tab';

  // To do: remove in a major.
  // @ts-expect-error: deprecated.
  if (style === 1 || style === '1') {
    return 'one'
  }

  if (style !== 'tab' && style !== 'one' && style !== 'mixed') {
    throw new Error(
      'Cannot serialize items with `' +
        style +
        '` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`'
    )
  }

  return style
}

/**
 * @typedef {import('mdast').ListItem} ListItem
 * @typedef {import('../types.js').Map} Map
 * @typedef {import('../types.js').Parent} Parent
 * @typedef {import('../types.js').State} State
 * @typedef {import('../types.js').Info} Info
 */


/**
 * @param {ListItem} node
 * @param {Parent | undefined} parent
 * @param {State} state
 * @param {Info} info
 * @returns {string}
 */
function listItem(node, parent, state, info) {
  const listItemIndent = checkListItemIndent(state);
  let bullet = state.bulletCurrent || checkBullet(state);

  // Add the marker value for ordered lists.
  if (parent && parent.type === 'list' && parent.ordered) {
    bullet =
      (typeof parent.start === 'number' && parent.start > -1
        ? parent.start
        : 1) +
      (state.options.incrementListMarker === false
        ? 0
        : parent.children.indexOf(node)) +
      bullet;
  }

  let size = bullet.length + 1;

  if (
    listItemIndent === 'tab' ||
    (listItemIndent === 'mixed' &&
      ((parent && parent.type === 'list' && parent.spread) || node.spread))
  ) {
    size = Math.ceil(size / 4) * 4;
  }

  const tracker = state.createTracker(info);
  tracker.move(bullet + ' '.repeat(size - bullet.length));
  tracker.shift(size);
  const exit = state.enter('listItem');
  const value = state.indentLines(
    state.containerFlow(node, tracker.current()),
    map
  );
  exit();

  return value

  /** @type {Map} */
  function map(line, index, blank) {
    if (index) {
      return (blank ? '' : ' '.repeat(size)) + line
    }

    return (blank ? bullet : bullet + ' '.repeat(size - bullet.length)) + line
  }
}

/**
 * @typedef {import('mdast').Content} Content
 * @typedef {import('mdast').ListItem} ListItem
 * @typedef {import('mdast').Paragraph} Paragraph
 * @typedef {import('mdast').Parent} Parent
 * @typedef {import('mdast').Root} Root
 * @typedef {import('mdast-util-from-markdown').CompileContext} CompileContext
 * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension
 * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle
 * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension
 * @typedef {import('mdast-util-to-markdown').Handle} ToMarkdownHandle
 */


// To do: next major: rename `context` -> `state`, `safeOptions` -> `info`, use
// `track` from `state`.
// To do: next major: replace exports with functions.
// To do: next major: use `defaulthandlers.listItem`.

/**
 * Extension for `mdast-util-from-markdown` to enable GFM task list items.
 *
 * @type {FromMarkdownExtension}
 */
const gfmTaskListItemFromMarkdown = {
  exit: {
    taskListCheckValueChecked: exitCheck,
    taskListCheckValueUnchecked: exitCheck,
    paragraph: exitParagraphWithTaskListItem
  }
};

/**
 * Extension for `mdast-util-to-markdown` to enable GFM task list items.
 *
 * @type {ToMarkdownExtension}
 */
const gfmTaskListItemToMarkdown = {
  unsafe: [{atBreak: true, character: '-', after: '[:|-]'}],
  handlers: {listItem: listItemWithTaskListItem}
};

/**
 * @this {CompileContext}
 * @type {FromMarkdownHandle}
 */
function exitCheck(token) {
  const node = /** @type {ListItem} */ (this.stack[this.stack.length - 2]);
  // We’re always in a paragraph, in a list item.
  node.checked = token.type === 'taskListCheckValueChecked';
}

/**
 * @this {CompileContext}
 * @type {FromMarkdownHandle}
 */
function exitParagraphWithTaskListItem(token) {
  const parent = /** @type {Parents} */ (this.stack[this.stack.length - 2]);

  if (
    parent &&
    parent.type === 'listItem' &&
    typeof parent.checked === 'boolean'
  ) {
    const node = /** @type {Paragraph} */ (this.stack[this.stack.length - 1]);
    const head = node.children[0];

    if (head && head.type === 'text') {
      const siblings = parent.children;
      let index = -1;
      /** @type {Paragraph | undefined} */
      let firstParaghraph;

      while (++index < siblings.length) {
        const sibling = siblings[index];
        if (sibling.type === 'paragraph') {
          firstParaghraph = sibling;
          break
        }
      }

      if (firstParaghraph === node) {
        // Must start with a space or a tab.
        head.value = head.value.slice(1);

        if (head.value.length === 0) {
          node.children.shift();
        } else if (
          node.position &&
          head.position &&
          typeof head.position.start.offset === 'number'
        ) {
          head.position.start.column++;
          head.position.start.offset++;
          node.position.start = Object.assign({}, head.position.start);
        }
      }
    }
  }

  this.exit(token);
}

/**
 * @type {ToMarkdownHandle}
 * @param {ListItem} node
 */
function listItemWithTaskListItem(node, parent, context, safeOptions) {
  const head = node.children[0];
  const checkable =
    typeof node.checked === 'boolean' && head && head.type === 'paragraph';
  const checkbox = '[' + (node.checked ? 'x' : ' ') + '] ';
  const tracker = track(safeOptions);

  if (checkable) {
    tracker.move(checkbox);
  }

  let value = listItem(node, parent, context, {
    ...safeOptions,
    ...tracker.current()
  });

  if (checkable) {
    value = value.replace(/^(?:[*+-]|\d+\.)([\r\n]| {1,3})/, check);
  }

  return value

  /**
   * @param {string} $0
   * @returns {string}
   */
  function check($0) {
    return $0 + checkbox
  }
}

/**
 * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension
 * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension
 */


/**
 * Create an extension for `mdast-util-from-markdown` to enable GFM (autolink
 * literals, footnotes, strikethrough, tables, tasklists).
 *
 * @returns {Array<FromMarkdownExtension>}
 *   Extension for `mdast-util-from-markdown` to enable GFM (autolink literals,
 *   footnotes, strikethrough, tables, tasklists).
 */
function gfmFromMarkdown() {
  return [
    gfmAutolinkLiteralFromMarkdown,
    gfmFootnoteFromMarkdown(),
    gfmStrikethroughFromMarkdown,
    gfmTableFromMarkdown,
    gfmTaskListItemFromMarkdown
  ]
}

/**
 * Create an extension for `mdast-util-to-markdown` to enable GFM (autolink
 * literals, footnotes, strikethrough, tables, tasklists).
 *
 * @param {Options | null | undefined} [options]
 *   Configuration.
 * @returns {ToMarkdownExtension}
 *   Extension for `mdast-util-to-markdown` to enable GFM (autolink literals,
 *   footnotes, strikethrough, tables, tasklists).
 */
function gfmToMarkdown(options) {
  return {
    extensions: [
      gfmAutolinkLiteralToMarkdown,
      gfmFootnoteToMarkdown(),
      gfmStrikethroughToMarkdown,
      gfmTableToMarkdown(options),
      gfmTaskListItemToMarkdown
    ]
  }
}

/**
 * @typedef {import('mdast').Root} Root
 * @typedef {import('micromark-extension-gfm').Options & import('mdast-util-gfm').Options} Options
 */


/**
 * Plugin to support GFM (autolink literals, footnotes, strikethrough, tables, tasklists).
 *
 * @type {import('unified').Plugin<[Options?]|void[], Root>}
 */
function remarkGfm(options = {}) {
  const data = this.data();

  add('micromarkExtensions', gfm(options));
  add('fromMarkdownExtensions', gfmFromMarkdown());
  add('toMarkdownExtensions', gfmToMarkdown(options));

  /**
   * @param {string} field
   * @param {unknown} value
   */
  function add(field, value) {
    const list = /** @type {unknown[]} */ (
      // Other extensions
      /* c8 ignore next 2 */
      data[field] ? data[field] : (data[field] = [])
    );

    list.push(value);
  }
}

/* eslint-disable @typescript-eslint/no-unused-vars */

const Markdown = ({ onLinkClick, focusableProps, children, ...props }) => {
    return (window.SP_REACT.createElement(DFL.Focusable, { ...focusableProps },
        window.SP_REACT.createElement(ReactMarkdown, { remarkPlugins: [remarkGfm], 
            // Match sanitazion from the new site ssr
            disallowedElements: ['h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'img'], unwrapDisallowed: true, components: {
                // Make links usable
                a: ({ node, children, ...linkProps }) => (window.SP_REACT.createElement(DFL.Focusable, { onActivate: () => {
                        if (linkProps.href) {
                            DFL.Navigation.NavigateToExternalWeb(linkProps.href);
                            onLinkClick?.();
                        }
                    }, onSecondaryButton: () => showQrModal(linkProps.href ?? ''), onSecondaryActionDescription: trans_string('ACTION_SHOW_LINK_QR', 'Show Link QR'), style: { display: 'inline-block' } },
                    window.SP_REACT.createElement("a", { style: { textDecoration: 'underline', color: '#1a9fff' }, ...linkProps }, children))),
            }, ...props }, children)));
};

const DetailsModal = ({ closeModal, asset, assetType, onAssetChange, assetProps }) => {
    const [downloading, setDownloading] = SP_REACT.useState(false); // props don't update in modals, need to repeat this here
    const handleDownload = async (evt) => {
        evt.preventDefault();
        setDownloading(true);
        await onAssetChange?.();
        setDownloading(false);
    };
    return (window.SP_REACT.createElement(DFL.ModalRoot, { className: "sgdb-modal sgdb-modal-details", closeModal: closeModal, bDisableBackgroundDismiss: false, bHideCloseIcon: false },
        window.SP_REACT.createElement("div", { className: DFL.joinClassNames('sgdb-modal-details-wrapper', asset.width > asset.height ? 'wide' : '') },
            window.SP_REACT.createElement(Asset, { src: asset.url, width: asset.width, height: asset.height, assetType: assetType, isAnimated: false, isDownloading: downloading, onClick: handleDownload, ...assetProps }),
            window.SP_REACT.createElement("div", { className: "info" },
                window.SP_REACT.createElement(DFL.DialogButtonPrimary, { onClick: handleDownload, onOKActionDescription: trans_string('ACTION_ASSET_APPLY', 'Apply {assetType}').replace('{assetType}', SGDB_ASSET_TYPE_READABLE[assetType]) }, trans_string('ACTION_ASSET_APPLY', 'Apply {assetType}').replace('{assetType}', SGDB_ASSET_TYPE_READABLE[assetType])),
                window.SP_REACT.createElement("span", { className: "meta" }, [
                    SGDB_MIME_MAP[asset.mime] || asset.mime,
                    asset.style.replace(/_/g, ' '),
                    asset.width > 0 ? `${asset.width}×${asset.height}` : undefined,
                ].filter(Boolean).join(' • ')),
                window.SP_REACT.createElement(DFL.Focusable, { className: "author", onActivate: () => {
                        DFL.Navigation.NavigateToExternalWeb(`https://steamcommunity.com/profiles/${asset.author.steam64}`);
                        closeModal?.();
                    } },
                    window.SP_REACT.createElement("img", { src: asset.author.avatar, alt: "" }),
                    window.SP_REACT.createElement("span", null, asset.author.name)),
                asset.notes && (window.SP_REACT.createElement(Markdown, { onLinkClick: closeModal, focusableProps: { className: 'notes' } }, asset.notes))))));
};

const appGridFilterHeaderClass = DFL.findModuleExport((e, name) => typeof e === 'string' && name === 'AppGridFilterHeader');
const appGridFilterTextClass = DFL.findModuleExport((e, name) => typeof e === 'string' && name === 'AppGridFilterText');
const AppGridFilterBar = ({ children, ...rest }) => (window.SP_REACT.createElement("div", { ...rest },
    window.SP_REACT.createElement("div", { className: appGridFilterHeaderClass },
        window.SP_REACT.createElement("span", { className: appGridFilterTextClass }, children))));

const strGameSelected = trans_string('MSG_GAME_SELECTED', 'Selected {gameName}');
const strFilterActive = trans_string('MSG_ASSETS_FILTERED', 'Some assets may be hidden due to filter');
const strFilterAndGame = trans_string('MSG_GAME_SELECTED_AND_ASSETS_FILTERED', 'Selected {gameName} with filter');
const ResultsStateBar = ({ loading, selectedGame, isFiltered, onClick }) => {
    if (loading)
        return null;
    if (selectedGame && !isFiltered) {
        return (window.SP_REACT.createElement(AppGridFilterBar, { style: { marginTop: '1em' }, onClick: onClick },
            reactStringReplace$1(strGameSelected, '{gameName}', (_, i) => (window.SP_REACT.createElement(DFL.Marquee, { key: i, fadeLength: 5, style: { maxWidth: '350px' } },
                "\"",
                selectedGame.name,
                "\""))),
            window.SP_REACT.createElement(FooterGlyph, { button: 2, type: 0, size: 0 })));
    }
    if (!selectedGame && isFiltered) {
        return (window.SP_REACT.createElement(AppGridFilterBar, { style: { marginTop: '1em' }, onClick: onClick },
            strFilterActive,
            " ",
            window.SP_REACT.createElement(FooterGlyph, { button: 2, type: 0, size: 0 })));
    }
    if (selectedGame && isFiltered) {
        return (window.SP_REACT.createElement(AppGridFilterBar, { style: { marginTop: '1em' }, onClick: onClick },
            reactStringReplace$1(strFilterAndGame, '{gameName}', (_, i) => (window.SP_REACT.createElement(DFL.Marquee, { key: i, fadeLength: 5, style: { maxWidth: '350px' } },
                "\"",
                selectedGame.name,
                "\""))),
            window.SP_REACT.createElement(FooterGlyph, { button: 2, type: 0, size: 0 })));
    }
    return null;
};

/**
 * Languages from official Steam docs
 * https://partner.steamgames.com/doc/store/localization/languages#supported_languages
(() => {
  const langs = [];
  const table = document.evaluate("//th[contains(text(),'English Name')]", document, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue.closest('table');
  for (const row of table.rows) {
    if (row.cells[0].innerText !== 'English Name') {
      langs.push(Array.from(row.cells).map((x) => x.innerText.replace('*', '').trim()));
    }
  }

  // Create SteamChina from Simplified Chinese
  const zhXC = [...langs.find((x) => x[3] === 'zh-CN')];
  zhXC[2] = 'sc_schinese';
  zhXC[3] = 'zh-XC';
  langs.push(zhXC)

  console.info(`const LANGS = ${JSON.stringify(langs, null, 2)};`);
})();
 */
const LANGS = [
    [
        'Arabic',
        'العربية',
        'arabic',
        'ar',
    ],
    [
        'Bulgarian',
        'български език',
        'bulgarian',
        'bg',
    ],
    [
        'Chinese (Simplified)',
        '简体中文',
        'schinese',
        'zh-CN',
    ],
    [
        'Chinese (Traditional)',
        '繁體中文',
        'tchinese',
        'zh-TW',
    ],
    [
        'Czech',
        'čeština',
        'czech',
        'cs',
    ],
    [
        'Danish',
        'Dansk',
        'danish',
        'da',
    ],
    [
        'Dutch',
        'Nederlands',
        'dutch',
        'nl',
    ],
    [
        'English',
        'English',
        'english',
        'en',
    ],
    [
        'Finnish',
        'Suomi',
        'finnish',
        'fi',
    ],
    [
        'French',
        'Français',
        'french',
        'fr',
    ],
    [
        'German',
        'Deutsch',
        'german',
        'de',
    ],
    [
        'Greek',
        'Ελληνικά',
        'greek',
        'el',
    ],
    [
        'Hungarian',
        'Magyar',
        'hungarian',
        'hu',
    ],
    [
        'Italian',
        'Italiano',
        'italian',
        'it',
    ],
    [
        'Japanese',
        '日本語',
        'japanese',
        'ja',
    ],
    [
        'Korean',
        '한국어',
        'koreana',
        'ko',
    ],
    [
        'Norwegian',
        'Norsk',
        'norwegian',
        'no',
    ],
    [
        'Polish',
        'Polski',
        'polish',
        'pl',
    ],
    [
        'Portuguese',
        'Português',
        'portuguese',
        'pt',
    ],
    [
        'Portuguese-Brazil',
        'Português-Brasil',
        'brazilian',
        'pt-BR',
    ],
    [
        'Romanian',
        'Română',
        'romanian',
        'ro',
    ],
    [
        'Russian',
        'Русский',
        'russian',
        'ru',
    ],
    [
        'Spanish-Spain',
        'Español-España',
        'spanish',
        'es',
    ],
    [
        'Spanish-Latin America',
        'Español-Latinoamérica',
        'latam',
        'es-419',
    ],
    [
        'Swedish',
        'Svenska',
        'swedish',
        'sv',
    ],
    [
        'Thai',
        'ไทย',
        'thai',
        'th',
    ],
    [
        'Turkish',
        'Türkçe',
        'turkish',
        'tr',
    ],
    [
        'Ukrainian',
        'Українська',
        'ukrainian',
        'uk',
    ],
    [
        'Vietnamese',
        'Tiếng Việt',
        'vietnamese',
        'vn',
    ],
    [
        'Steam China (Simplified Chinese)',
        '简体中文',
        'sc_schinese',
        'zh-XC',
    ],
];
/**
 * English Name, Native Name, API language code, Web API language code
 */
const TYPES = {
    english: 0,
    native: 1,
    api: 2,
    webapi: 3,
};
var SteamLang = (input, inputType, output) => {
    if (Object.keys(TYPES).indexOf(output) === -1 || Object.keys(TYPES).indexOf(inputType) === -1) {
        return null;
    }
    for (let i = 0; i < LANGS.length; i++) {
        const lang = LANGS[i];
        if (lang[TYPES[inputType]].toLowerCase() == input.toLowerCase()) {
            return lang[TYPES[output]];
        }
    }
    return null;
};

const SteamModalImageSection = ({ closeModal, languages, langType, urlHandler, urlHandler2x, assetType, onAssetChange, assetProps }) => {
    const hasEng = SP_REACT.useMemo(() => (languages.indexOf(SteamLang('en', 'webapi', langType)) > -1), [langType, languages]);
    const [selectedLang, setSelectedLang] = SP_REACT.useState(hasEng ? SteamLang('en', 'webapi', langType) : languages[0]); // English as default
    const [selectedImg, setSelectedImg] = SP_REACT.useState('');
    const [downloading, setDownloading] = SP_REACT.useState(false);
    const fallbackAttempted = SP_REACT.useRef(false);
    const handleDownload = async (evt) => {
        evt.preventDefault();
        setDownloading(true);
        await onAssetChange?.(selectedImg);
        setDownloading(false);
        closeModal?.();
    };
    const handleImgError = () => {
        if (urlHandler && !fallbackAttempted.current) {
            setSelectedImg(urlHandler(selectedLang));
            fallbackAttempted.current = true;
        }
    };
    // Reset fallback check when changing langs
    SP_REACT.useEffect(() => {
        fallbackAttempted.current = false;
    }, [selectedLang]);
    SP_REACT.useEffect(() => {
        if (urlHandler2x) {
            setSelectedImg(urlHandler2x(selectedLang));
        }
        else {
            setSelectedImg(urlHandler(selectedLang));
        }
    }, [selectedLang, urlHandler, urlHandler2x]);
    return (window.SP_REACT.createElement(window.SP_REACT.Fragment, null,
        window.SP_REACT.createElement(DFL.DialogBody, null,
            (languages.length > 1) && (window.SP_REACT.createElement(DFL.Field, { label: trans_string('LanguageTitle', 'Language', true) },
                window.SP_REACT.createElement(DFL.Dropdown, { rgOptions: languages.map((language) => ({
                        data: language,
                        label: SteamLang(language, langType, 'native'),
                    })), selectedOption: selectedLang, onChange: (newLang) => setSelectedLang(newLang.data) }))),
            window.SP_REACT.createElement(DFL.DialogControlsSection, null, selectedImg && (window.SP_REACT.createElement(DFL.Field, { padding: "none", childrenLayout: "below", childrenContainerWidth: "max", bottomSeparator: "none" },
                window.SP_REACT.createElement("div", { className: DFL.joinClassNames('official-steam-asset', assetType) },
                    window.SP_REACT.createElement(Asset, { src: selectedImg, width: 0, height: 0, assetType: assetType, isAnimated: false, isDownloading: downloading, onImgError: handleImgError, onClick: handleDownload, ...assetProps })))))),
        window.SP_REACT.createElement(DFL.DialogFooter, null,
            window.SP_REACT.createElement(DFL.DialogButtonPrimary, { onClick: handleDownload, onOKActionDescription: trans_string('ACTION_ASSET_APPLY', 'Apply {assetType}').replace('{assetType}', SGDB_ASSET_TYPE_READABLE[assetType]) }, trans_string('ACTION_ASSET_APPLY', 'Apply {assetType}').replace('{assetType}', SGDB_ASSET_TYPE_READABLE[assetType])))));
};
const OfficialAssetsModal = ({ closeModal, assetType, data, onAssetChange }) => {
    const steam = data.steam[0];
    const meta = steam.metadata;
    return (window.SP_REACT.createElement(DFL.ModalRoot, { className: "sgdb-modal sgdb-modal-official-assets", closeModal: closeModal, bDisableBackgroundDismiss: false, bHideCloseIcon: false },
        (assetType === 'grid_l' && meta.header_image_full) && (window.SP_REACT.createElement(SteamModalImageSection, { closeModal: closeModal, onAssetChange: onAssetChange, assetType: assetType, languages: Object.keys(meta.header_image_full), urlHandler2x: (lang) => {
                const fileName = meta.header_image_full[lang].replace(/\.jpg$/, '_2x.jpg');
                return `https://shared.steamstatic.com/store_item_assets/steam/apps/${steam.id}/${fileName}?t=${meta.store_asset_mtime}`;
            }, urlHandler: (lang) => `https://shared.steamstatic.com/store_item_assets/steam/apps/${steam.id}/${meta.header_image_full[lang]}?t=${meta.store_asset_mtime}`, langType: "api", assetProps: {
                width: 460,
                height: 215,
            } })),
        (assetType === 'grid_p' && meta.library_capsule_full) && (window.SP_REACT.createElement(SteamModalImageSection, { closeModal: closeModal, onAssetChange: onAssetChange, assetType: assetType, languages: Object.keys(meta.library_capsule_full.image), urlHandler2x: meta.library_capsule_full?.image2x ? (lang) => `https://shared.steamstatic.com/store_item_assets/steam/apps/${steam.id}/${meta.library_capsule_full.image2x[lang]}?t=${meta.store_asset_mtime}` : undefined, urlHandler: (lang) => `https://shared.steamstatic.com/store_item_assets/steam/apps/${steam.id}/${meta.library_capsule_full.image[lang]}?t=${meta.store_asset_mtime}`, langType: "api", assetProps: {
                width: 600,
                height: 900,
            } })),
        (assetType === 'hero' && meta.library_hero_full) && (window.SP_REACT.createElement(SteamModalImageSection, { closeModal: closeModal, onAssetChange: onAssetChange, assetType: assetType, languages: Object.keys(meta.library_hero_full.image), urlHandler2x: meta.library_hero_full?.image2x ? (lang) => `https://shared.steamstatic.com/store_item_assets/steam/apps/${steam.id}/${meta.library_hero_full.image2x[lang]}?t=${meta.store_asset_mtime}` : undefined, urlHandler: (lang) => `https://shared.steamstatic.com/store_item_assets/steam/apps/${steam.id}/${meta.library_hero_full.image[lang]}?t=${meta.store_asset_mtime}`, langType: "api", assetProps: {
                width: 1920,
                height: 620,
            } })),
        (assetType === 'logo' && meta.library_logo_full) && (window.SP_REACT.createElement(SteamModalImageSection, { closeModal: closeModal, onAssetChange: onAssetChange, assetType: assetType, languages: Object.keys(meta.library_logo_full.image), urlHandler2x: meta.library_logo_full?.image2x ? (lang) => `https://shared.steamstatic.com/store_item_assets/steam/apps/${steam.id}/${meta.library_logo_full.image2x[lang]}?t=${meta.store_asset_mtime}` : undefined, urlHandler: (lang) => `https://shared.steamstatic.com/store_item_assets/steam/apps/${steam.id}/${meta.library_logo_full.image[lang]}?t=${meta.store_asset_mtime}`, langType: "api" })),
        (assetType === 'icon' && meta.clienticon) && (window.SP_REACT.createElement(SteamModalImageSection, { closeModal: closeModal, onAssetChange: onAssetChange, assetType: assetType, languages: ['English'], urlHandler: () => `https://cdn.cloudflare.steamstatic.com/steamcommunity/public/images/apps/${steam.id}/${meta.clienticon}.ico`, langType: "english", assetProps: {
                width: 32,
                height: 32,
            } }))));
};

const Motd = ({ disabled = false, noFocusRing, }) => {
    const { set, get } = useSettings();
    const [motdCurrent, setMotdCurrent] = SP_REACT.useState(null);
    const hideMotd = SP_REACT.useCallback(() => {
        if (!motdCurrent?.id)
            return;
        DFL.showModal(window.SP_REACT.createElement(DFL.ConfirmModal, { strTitle: trans_string('TITLE_MOTD_HIDE', 'Hide Announcement?'), strDescription: trans_string('LABEL_SETTINGS_DISABLE_MOTD_DESC', 'Announcements are used sparingly to display important information or community events.'), strOKButtonText: trans_string('LABEL_MOTD_THIS', 'This Announcement'), strMiddleButtonText: trans_string('LABEL_MOTD_ALL', 'All Announcements'), onOK: () => {
                set('motd_hidden', motdCurrent.id);
                setMotdCurrent(null);
            }, onMiddleButton: () => {
                set('motd_hidden_global', true, true);
                setMotdCurrent(null);
            } }));
    }, [set, motdCurrent]);
    const fetchMotd = SP_REACT.useCallback(async () => {
        try {
            const res = await fetchNoCors(`${SGDB_API_BASE}/deckymotd`, {
                method: 'GET',
                headers: {
                    Accept: 'application/json',
                    Authorization: `Bearer ${SGDB_API_KEY}`,
                    'X-Motd-Version': '1',
                },
            });
            const jsonBody = await res.json();
            set('motd_cached', jsonBody, true);
            return jsonBody;
        }
        catch (error) {
            // fail silently, try again in a week
        }
        finally {
            set('motd_last_fetched', Math.floor(new Date().getTime() / 1000), true);
        }
        return null;
    }, [set]);
    SP_REACT.useEffect(() => {
        (async () => {
            // skip if motd is disabled globally
            const hiddenMotdGlobal = await get('motd_hidden_global', false);
            if (hiddenMotdGlobal)
                return;
            const hiddenMotd = await get('motd_hidden', null);
            const rn = Math.floor(new Date().getTime() / 1000);
            const yesterday = Math.floor(new Date(new Date().getTime() - 24 * 60 * 60 * 1000).getTime() / 1000);
            const lastCheck = parseInt(await get('motd_last_fetched', 0));
            let motd;
            // only get new motd once a week
            if (yesterday >= lastCheck) {
                motd = await fetchMotd();
            }
            else {
                // get cached motd if not hidden
                motd = await get('motd_cached', null);
            }
            // Don't set if explicitly hidden by the user or already expired
            if (motd && (hiddenMotd !== motd.id)) {
                if (!(motd.expires < rn)) {
                    setMotdCurrent(motd);
                }
            }
        })();
    }, [fetchMotd, get]);
    if (disabled || !motdCurrent)
        return null;
    return (window.SP_REACT.createElement(DFL.Focusable, { noFocusRing: noFocusRing, "flow-children": "row", className: "motd-wrap" },
        window.SP_REACT.createElement(DFL.Focusable, { noFocusRing: false, className: "motd", style: {
                backgroundImage: motdCurrent.bg_type === 'image' ? `url(${motdCurrent.bg_url})` : 'none',
                backgroundPosition: `${motdCurrent.bg_position}`,
                backgroundColor: `${motdCurrent.bg_color}`,
            }, onSecondaryActionDescription: trans_string('ACTION_SHOW_LINK_QR', 'Show Link QR'), onOKActionDescription: motdCurrent.text ? motdCurrent.text : trans_string('Button_Go', 'Go', true), onSecondaryButton: () => showQrModal(motdCurrent.url), onActivate: () => {
                DFL.Navigation.NavigateToExternalWeb(motdCurrent.url);
            } },
            window.SP_REACT.createElement("div", { className: "motd-inner" },
                motdCurrent.image_url ? window.SP_REACT.createElement("img", { src: motdCurrent.image_url, alt: "" }) : null,
                window.SP_REACT.createElement("div", { className: "motd-text" },
                    motdCurrent.text ? (window.SP_REACT.createElement("span", { className: "motd-title" }, motdCurrent.text)) : null,
                    motdCurrent.text_sub ? (window.SP_REACT.createElement("span", { className: "motd-subtitle" }, motdCurrent.text_sub)) : null)),
            motdCurrent.bg_type === 'video' ? (window.SP_REACT.createElement("video", { className: "motd-video-bg", src: motdCurrent.bg_url, autoPlay: true, muted: true, loop: true, playsInline: true })) : null),
        window.SP_REACT.createElement(DFL.DialogButton, { style: { flex: 0 }, className: "motd-hide", noFocusRing: true, onOKActionDescription: trans_string('Button_Hide', 'Hide', true), onClick: hideMotd },
            window.SP_REACT.createElement(HiXMark, { strokeWidth: 1.5 }))));
};

const AssetTab = ({ assetType }) => {
    const { get } = useSettings();
    const { loading: searchLoading, assets, searchAndSetAssets, loadMore, openFilters, isFilterActive, selectedGame, externalSgdbData, endReached, } = useAssetSearch();
    const { appOverview, changeAssetFromUrl } = useSGDB();
    const [downloadingId, setDownloadingId] = SP_REACT.useState(null);
    const [sizingStyles, setSizingStyles] = SP_REACT.useState(undefined);
    const [tabLoading, setTabLoading] = SP_REACT.useState(true);
    const [scrollContainerHeight, setScrollContainerHeight] = SP_REACT.useState();
    const loading = SP_REACT.useMemo(() => !(!searchLoading && !tabLoading), [searchLoading, tabLoading]);
    const toolbarRef = SP_REACT.useRef(null);
    const mainContentRef = SP_REACT.useRef(null);
    const intersectRef = SP_REACT.useRef(null);
    const handleFilterClick = () => openFilters(assetType);
    const handleLogoPosClick = () => DFL.showModal(window.SP_REACT.createElement(LogoPositionerModal, { appId: appOverview.appid }), window);
    const handleOfficialAssetsClick = () => {
        DFL.showModal((window.SP_REACT.createElement(OfficialAssetsModal, { onAssetChange: async (url) => {
                try {
                    await changeAssetFromUrl(url, assetType);
                    toaster.toast({
                        title: appOverview?.display_name,
                        body: trans_string('MSG_ASSET_APPLY_SUCCESS', '{assetType} has been successfully applied!').replace('{assetType}', SGDB_ASSET_TYPE_READABLE[assetType]),
                        icon: window.SP_REACT.createElement(MenuIcon, null),
                        duration: 1500,
                    });
                }
                catch (err) {
                    toaster.toast({
                        title: trans_string('MSG_ASSET_APPLY_ERROR', 'There was a problem applying this asset.'),
                        body: err.message,
                        icon: window.SP_REACT.createElement(MenuIcon, { fill: "#f3171e" }),
                    });
                }
            }, assetType: assetType, data: externalSgdbData })), window);
    };
    const setAsset = async (assetId, url) => {
        if (!downloadingId) {
            try {
                setDownloadingId(assetId);
                await changeAssetFromUrl(url, assetType);
                toaster.toast({
                    title: appOverview?.display_name,
                    body: trans_string('MSG_ASSET_APPLY_SUCCESS', '{assetType} has been successfully applied!').replace('{assetType}', SGDB_ASSET_TYPE_READABLE[assetType]),
                    icon: window.SP_REACT.createElement(MenuIcon, null),
                    duration: 1500,
                });
            }
            catch (err) {
                toaster.toast({
                    title: trans_string('MSG_ASSET_APPLY_ERROR', 'There was a problem applying this asset.'),
                    body: err.message,
                    icon: window.SP_REACT.createElement(MenuIcon, { fill: "#f3171e" }),
                });
            }
            finally {
                setDownloadingId(null);
            }
        }
    };
    /* const focusSettings = () => {
      toolbarRef.current?.focus();
    }; */
    const openDetails = (asset) => {
        DFL.showModal((window.SP_REACT.createElement(DetailsModal, { asset: asset, assetType: assetType, onAssetChange: async () => await setAsset(asset.id, asset.url) })), window);
    };
    SP_REACT.useEffect(() => {
        (async () => {
            setTabLoading(true);
            const filters = await get(`filters_${assetType}`, null);
            await searchAndSetAssets(assetType, 0, filters, () => {
                setTabLoading(false);
            });
        })();
    }, [searchAndSetAssets, assetType, get]);
    SP_REACT.useEffect(() => {
        if (!intersectRef.current || loading || endReached)
            return;
        const observer = new IntersectionObserver(([entry], observer) => {
            if (entry.isIntersecting) {
                loadMore(assetType, (res) => {
                    // End reached
                    if (res.length === 0) {
                        observer.disconnect();
                    }
                });
            }
        }, { threshold: 0, root: mainContentRef.current?.parentElement?.parentElement });
        observer.observe(intersectRef.current);
        // Hack to work around CSS themes that don't adjust padding of tabbed content when changing the size of the footer.
        if (mainContentRef.current?.parentElement?.parentElement) {
            const pb = window.getComputedStyle(mainContentRef.current.parentElement.parentElement).getPropertyValue('padding-bottom');
            setScrollContainerHeight(pb);
        }
        return () => {
            observer.disconnect();
        };
    }, [assetType, endReached, loadMore, loading]);
    if (!appOverview)
        return null;
    return (window.SP_REACT.createElement("div", { className: "tabcontents-wrap" },
        window.SP_REACT.createElement("div", { className: DFL.joinClassNames('spinnyboi', !loading ? 'loaded' : '') },
            window.SP_REACT.createElement("img", { alt: "Loading...", src: "/images/steam_spinner.png" })),
        window.SP_REACT.createElement(Toolbar, { ref: toolbarRef, assetType: assetType, onFilterClick: handleFilterClick, onLogoPosClick: handleLogoPosClick, onOfficialAssetsClick: handleOfficialAssetsClick, onSizeChange: (size) => setSizingStyles(size), disabled: tabLoading, noFocusRing: searchLoading || tabLoading }),
        window.SP_REACT.createElement(Motd, { disabled: tabLoading, noFocusRing: searchLoading || tabLoading }),
        window.SP_REACT.createElement(ResultsStateBar, { loading: loading, selectedGame: selectedGame, isFiltered: isFilterActive, onClick: handleFilterClick }),
        window.SP_REACT.createElement(DFL.Focusable, { ref: mainContentRef, id: "images-container", style: sizingStyles }, !tabLoading && (window.SP_REACT.createElement(window.SP_REACT.Fragment, null,
            assets.map((asset) => (window.SP_REACT.createElement(Asset, { key: asset.id, scrollContainer: mainContentRef.current?.parentElement?.parentElement, author: asset.author, notes: asset.notes, src: asset.thumb, width: asset.width, height: asset.height, humor: asset.humor, epilepsy: asset.epilepsy, nsfw: asset.nsfw, assetType: assetType, isAnimated: asset.thumb.includes('.webm'), isDownloading: downloadingId === asset.id, onActivate: () => setAsset(asset.id, asset.url), onOKActionDescription: trans_string('ACTION_ASSET_APPLY', 'Apply {assetType}').replace('{assetType}', SGDB_ASSET_TYPE_READABLE[assetType]), onSecondaryActionDescription: trans_string('ACTION_OPEN_FILTER', 'Filter'), onSecondaryButton: handleFilterClick, onMenuActionDescription: trans_string('ACTION_OPEN_DETAILS', 'Details'), onMenuButton: () => openDetails(asset), onContextMenu: (evt) => {
                    evt.preventDefault();
                    openDetails(asset);
                } }))),
            window.SP_REACT.createElement("div", { ref: intersectRef, style: { gridColumn: '1 / -1', height: '5px', marginBottom: scrollContainerHeight } }),
            assets.length === 0 && window.SP_REACT.createElement("div", { style: { gridColumn: '1 / -1', justifySelf: 'center' } }, trans_string('Search_NoResults', 'No Results Found.', true)))))));
};

const AssetTabs = ({ currentTab, onShowTab }) => {
    const { get, set } = useSettings();
    const { appOverview } = useSGDB();
    const { openFilters } = useAssetSearch();
    const [tabPositions, setTabPositions] = SP_REACT.useState(null);
    const [hiddenTabs, setHiddenTabs] = SP_REACT.useState(null);
    SP_REACT.useEffect(() => {
        (async () => {
            setTabPositions(await get('tabs_order', DEFAULT_TABS));
            setHiddenTabs(await get('tabs_hidden', []));
            // Amount of times tabs page opened, used to hide tutorial after a while
            const useCount = await get('plugin_use_count', 0);
            set('plugin_use_count', useCount + 1, true);
            // Donation message if plugin is used a lot
            if ([15, 75, 200, 1337].includes(useCount)) {
                DFL.showModal(window.SP_REACT.createElement(BeggingModal, null));
            }
        })();
    }, [get, set]);
    if (!tabPositions || !hiddenTabs)
        return null;
    let tabs = [
        ...tabPositions
            /*
              Filter out icons if:
                - App is a mod, editing edit liblist.gam/gameinfo.txt is destructive and out of scope for this plugin
                - Shortcut is not locally installed, can't edit shortcuts.vdf remotely.
            */
            .filter((type) => !(type === 'icon' && (appOverview.third_party_mod ||
            (appOverview.BIsShortcut() && appOverview.selected_clientid != '0'))))
            // Filter hidden tabs
            .filter((x) => !hiddenTabs.includes(x)),
    ];
    /*
      If no tabs are left, force show manage tab. Useful for when only icons are selected and trying to view a mod.
    */
    if (tabs.length === 0) {
        tabs = ['manage'];
    }
    return (window.SP_REACT.createElement(DFL.Tabs, { autoFocusContents: true, activeTab: currentTab, onShowTab: onShowTab, tabs: tabs.map((type) => {
            if (type === 'manage') {
                return {
                    title: tabStrs[type],
                    content: window.SP_REACT.createElement(LocalTab, null),
                    id: 'manage',
                };
            }
            return {
                id: type,
                title: tabStrs[type],
                content: window.SP_REACT.createElement(AssetTab, { assetType: type }),
                footer: {
                    onSecondaryActionDescription: trans_string('ACTION_OPEN_FILTER', 'Filter'),
                    onSecondaryButton: () => openFilters(type),
                },
            };
        }) }));
};
var AssetTabs$1 = SP_REACT.memo(AssetTabs);

const SGDBPage = () => {
    const { get } = useSettings();
    const { setAppId, appOverview } = useSGDB();
    const { appid, assetType = 'grid_p' } = DFL.useParams();
    const [currentTab, setCurrentTab] = SP_REACT.useState();
    const onShowTab = SP_REACT.useCallback((tabID) => {
        setCurrentTab(tabID);
    }, []);
    SP_REACT.useEffect(() => {
        setAppId(parseInt(appid, 10));
    }, [appid, setAppId]);
    SP_REACT.useEffect(() => {
        (async () => {
            const positions = await get('tabs_order', DEFAULT_TABS);
            const hidden = await get('tabs_hidden', []);
            let tabDefault = await get('tab_default', assetType);
            const filtered = positions.filter((x) => !hidden.includes(x));
            // Set first tab as default if default is hidden
            if (!filtered.includes(tabDefault)) {
                tabDefault = filtered[0];
            }
            setCurrentTab(tabDefault);
        })();
    }, [get, assetType]);
    if (!appOverview || !currentTab)
        return null;
    return (window.SP_REACT.createElement(window.SP_REACT.Fragment, null,
        window.SP_REACT.createElement("style", null, style),
        window.SP_REACT.createElement("div", { id: "sgdb-wrap" },
            window.SP_REACT.createElement(AssetSearchContext, null,
                window.SP_REACT.createElement(AssetTabs$1, { currentTab: currentTab, onShowTab: onShowTab })))));
};

// Always add before "Properties..."
const spliceArtworkItem = (children, appid) => {
    children.find((x) => x?.key === 'properties');
    const propertiesMenuItemIdx = children.findIndex((item) => DFL.findInReactTree(item, (x) => x?.onSelected && x.onSelected.toString().includes('AppProperties')));
    children.splice(propertiesMenuItemIdx, 0, (window.SP_REACT.createElement(DFL.MenuItem, { key: "sgdb-change-artwork", onSelected: () => {
            DFL.Navigation.Navigate(`/steamgriddb/${appid}`);
        } }, trans_string('ACTION_CHANGE_ARTWORK', 'Change Artwork...'))));
};
// Check if correct menu by looking at the code of the onSelected function
// Should be enough to ignore the screenshots and other menus.
const isOpeningAppContextMenu = (items) => {
    if (items.length === 0 || items.length === undefined) {
        return false;
    }
    return items.findIndex((item) => DFL.findInReactTree(item, (x) => x?.onSelected &&
        x.onSelected.toString().includes('AddToNewCollection'))) !== -1;
};
const handleItemDupes = (items) => {
    const sgdbIdx = items.findIndex((x) => x?.key === 'sgdb-change-artwork');
    if (sgdbIdx != -1)
        items.splice(sgdbIdx, 1);
};
const patchMenuItems = (menuItems, appid) => {
    let updatedAppid = appid;
    // find the first menu component that has the correct appid assigned to _owner
    const parentOverview = menuItems.find((x) => x?._owner?.pendingProps?.overview?.appid &&
        x._owner.pendingProps.overview.appid !== appid);
    // if found then use that appid
    if (parentOverview) {
        updatedAppid = parentOverview._owner.pendingProps.overview.appid;
    }
    spliceArtworkItem(menuItems, updatedAppid);
};
/**
 * Patches the game context menu.
 * @param LibraryContextMenu The game context menu.
 * @returns A patch to remove when the plugin dismounts.
 */
const contextMenuPatch = (LibraryContextMenu) => {
    const patches = { unpatch: () => { return null; } };
    patches.outer = DFL.afterPatch(LibraryContextMenu.prototype, 'render', (_, component) => {
        const appid = component._owner.pendingProps.overview.appid;
        if (!patches.inner) {
            patches.inner = DFL.afterPatch(component, 'type', (_, ret) => {
                // initial render
                DFL.afterPatch(ret.type.prototype, 'render', (_, ret2) => {
                    const menuItems = ret2.props.children[0]; // always the first child
                    if (!isOpeningAppContextMenu(menuItems))
                        return ret2;
                    try {
                        handleItemDupes(menuItems);
                    }
                    catch (error) {
                        // wrong context menu (probably)
                        return ret2;
                    }
                    patchMenuItems(menuItems, appid);
                    return ret2;
                });
                // when steam decides to regresh app overview
                DFL.afterPatch(ret.type.prototype, 'shouldComponentUpdate', ([nextProps], shouldUpdate) => {
                    try {
                        handleItemDupes(nextProps.children);
                    }
                    catch (error) {
                        // wrong context menu (probably)
                        return shouldUpdate;
                    }
                    if (shouldUpdate === true) {
                        patchMenuItems(nextProps.children, appid);
                    }
                    return shouldUpdate;
                });
                return ret;
            });
        }
        else {
            spliceArtworkItem(component.props.children, appid);
        }
        return component;
    });
    patches.unpatch = () => {
        patches.outer?.unpatch();
        patches.inner?.unpatch();
    };
    return patches;
};
/**
 * Game context menu component.
 */
const LibraryContextMenu = DFL.fakeRenderComponent(Object.values(DFL.findModuleByExport((e) => e?.toString && e.toString().includes('().LibraryContextMenu'))).find((sibling) => (sibling?.toString().includes('createElement') &&
    sibling?.toString().includes('navigator:')))).type;

var index = DFL.definePlugin(() => {
    const getSetting = async (key, fallback) => {
        return await call('get_setting', key, fallback);
    };
    routerHook.addRoute('/steamgriddb/:appid/:assetType?', () => (window.SP_REACT.createElement(SettingsProvider, null,
        window.SP_REACT.createElement(SGDBProvider, null,
            window.SP_REACT.createElement(SGDBPage, null)))), {
        exact: true,
    });
    const menuPatches = contextMenuPatch(LibraryContextMenu);
    Promise.all([
        getSetting('squares', false),
        getSetting('uniform_featured', false),
    ]).then(([squares, uniformFeatured]) => {
        if (squares || uniformFeatured) {
            if (squares) {
                addSquareLibraryPatch(true);
            }
            addHomePatch(true, squares, uniformFeatured);
        }
    });
    getSetting('capsule_glow_amount', 100).then((amount) => {
        addCapsuleGlowPatch(parseInt(amount, 10));
    });
    return {
        title: window.SP_REACT.createElement("div", { className: DFL.quickAccessMenuClasses.Title }, "SteamGridDB"),
        content: window.SP_REACT.createElement(SettingsProvider, null,
            window.SP_REACT.createElement(QuickAccessSettings, null)),
        icon: window.SP_REACT.createElement(MenuIcon, null),
        onDismount() {
            routerHook.removeRoute('/steamgriddb/:appid/:assetType?');
            menuPatches?.unpatch();
            removeSquareLibraryPatch(true);
            removeHomePatch(true);
            removeStyles('sgdb-square-capsules-library', 'sgdb-square-capsules-home', 'sgdb-capsule-glow', 'sgdb-carousel-logo');
        },
    };
});

export { index as default };
//# sourceMappingURL=index.js.map
